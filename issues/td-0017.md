## CW 17 (simpler form)



**Currently**

`K:V` is 'weak', only requires one matching $k,$v.

    - This is not very well expressed by the syntax, except whene K is a literal or bare var, but we have not found a better syntax that is simple (this is the common case) and also JSON-ish.
      The special construction `K:V else !` is strong, requiring at least one matching `$k,$v`, and also that `$k~K => $v~V`.

` K: V -> @bucket  `  means collect all `K:V` (or `{k:v}`) pairs into a bucket. This is a legitimate object slice. And can be used in search and replace.
` K: [ A -> @bucket ]  `  means collect all `K:A` (or `{k:a}`) pairs into a bucket. This is useful information, but it's not a legitimate object slice and you can't use it for search and replace.
`§L  K: [A -> {name:_->@bucket<^L> }]`  the marked item is a deeper structure in the AST, With an extra layer of branching, so we have to label which of the surrounding object patterns it's collecting over, plus deal with collisions.
`K:V?`  Makes **no assertion** And is used only for binding/joining.
or `K:V else !?` Means that there are no entries such that (k~K and not v~V), but does not assert that there exists k~K.  

**Proposal**

1. **Drop the nominclature 'strong' and 'weak'** Don't mention those terms.

2. **Keep the 'weak' grammar `K:V` but call it the "field existence" operator.**

3. **Replace the 'strong' grammar `K:V else !` with the "field validation operator":**

```
bucket:= '->' (SLICE_EXPR|'ignore')
Field_scan:= `'each' K ':' V bucket? (else V bucket?)* 
```

Examples:  
```
{ $k: _number }  // existence 

{ each $k: _number -> @numbers 
           else /\w+/ -> @goodStrings }   // "else fail" at the end is now redundant/implicit
{ each $k: _number -> @numbers 
           else /\w+/ -> @goodStrings 
           else "Ignore me" -> ignore
           else _ -> @badStrings }
```
We document that this is both for validation and for partitioning.

The terminal 'else !' is no longer supported, because it is implicit in the meaning of "each K:V". (Note: I have discussed at length whether people will wrongly assume an implicit "else ignore". We are going to address this through examples and through emphasizing that "each" is strict and that "else", like "or", doesn't have an invisible failover, not by adding new syntax.)

We needn't explain to the user that this is a fixed grammatical construct. It still behaves as if it were a composition of ordinary 'else' operators. Making it separate in the grammar is a convenience to aid static analysis.

4. **interaction with slices, remainder, quantifiers**

As before, `(K:V as @slice)` denotes the slice consisting of all key–value pairs `{k:v}` such that `k~K` and `v~V`. The requirement that the slice be nonempty comes from an implicit `#{1,}`, which may be overridden with an explicit cardinality. If the clause succeeds, **all keys `k` such that `k~K` are considered touched** and are therefore excluded from the remainder `%`, regardless of whether their values matched `V`.

The same rules apply to `(each K:V as @slice)`. In this case, success additionally guarantees that `k~K` is equivalent to `k~K ∧ v~V`.


5. **Retire `K:V ?` and `K:V else !?`.**

Those original forms are somewhat confusing, especially the first, which makes no assertion whatsoever.

Instead, those needs can be served with **existing constructs**. For example, the following idioms.
```
    // Makes no assertion but can be used for binding. This time it's not surprising, it's explicit. 
   { K:V #{0,} }  
   
   // The key doesn't have to exist, but if it does, then validate it.
   { each K:V #{0,} }
   
   // It's okay for the normal expectation to fail, but if it succeeds, then we perform the bindings.
   // (? $k:$v)
     
```



## CW 17b.

This is optional, but I like it.

1. Use @foo for array slices and %foo for object slices. This enables the following as well as potentially enabling other behaviors and reducing confusion between array slices and object slices.

The field validation idiom is now
```
{ each $k: _number -> %numbers
           else /\w+/ -> %goodStrings }
```
And these buckets will be object slices collecting the K:V pairs.

Rename '%' (the remainder) to '%%'.

2. Add the ability to use the arrow operator elsewhere, enabling collection of values from within structures.
```
// FORM 1: COLLECTING INTO AN ARRAY SLICE
// Collect both usernames and admin names. All the branches (not counting those that were pruned or backtracked) under the label are contributing to the collector.  
// Because we're collecting into an array slice, not an object slice, there is no concern with collisions or repetitions.  
§SCOPE 
{
 users: { each _:{name:_ -> @names<^SCOPE>} }
 admins: { each _:{adminName:(_ -> @names<^SCOPE>} }
}

// FORM 2: COLLECTING INTO AN OBJECT SLICE
// Collect the names as *values*. Use the *keys* from the labeled map.
// This only works if you can guarantee uniqueness of values per key. If there is a collision, it will be a runtime error.  (In future, this may be a controllable policy.)
// Scope labels are not necessary if you are targeting the nearest "each K:V" validation clause, as in this example.
{ each $k:{name:($name -> %names) }}   // collects $k:$name
```

As is already implemented, the buckets are visible in all of the branches that touched them. The last example, `{ each $k:{name:($name -> %names) }}`, will have a solution set like
```
[
   {k:123, name:'Mark', names: {'123':'Mark', '124':'Sue' }},
   {k:124, name:'Sue',  names: {'123':'Mark', '124':'Sue' }}
]
```
(Yes, there is cross-branch leakage, and that's the point.) 

Test the same value being sent to two buckets, (_ -> @b1) -> @b2 


## **UPDATE**

1. Kept % for remainder (not %%)
2. Object group bindings use %: (K:V as %slice) not @slice
3. Array group bindings use @: (... as @slice) unchanged
4. @bucket in object context collects values only (array output, loses keys)
5. %bucket in array context collects index:value pairs (object output)
6. Flow in fixed-position array elements uses outer object key (not array index)
7. Flow in quantified array elements uses array index ([(_ -> @bucket)*])
8. Wrong sigil in wrong context = parse error (generic, not specific message)


