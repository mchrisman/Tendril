---
id: td-0012
title: Simplified regex integration
status: backlog
priority: medium
type: feature
created: 2026-01-05T00:49:25-08:00
updated: 2026-01-05T00:49:25-08:00
tags: [regex, syntax]
---

# DESCRIPTION

## CW 12. Simplify and integrate regex.

1. Make /foo/ anchored.
2. In RE group syntax: /.*[.](?<$ext>\w+)/ -- Named groups that start with the $ sigil are lifted into Tendril land and participate in binding logic.. By default, this will not cause branching in Tendril (at most one regex solution per Tendril branch, as is usual for regexes). nitpicky details are mostly answered by the following equivalence:
   `[ /(?<$x>[ab])|[bc]/ ]`
   acts *exactly* like
   [ $x=(/[ab]/) else /[bc]/ ]
   (where 'else' is the non-backtracking form of '|' as desscribed earlier), with regard to backtracking, binding, and so on.
3. Provide consistent ergonomic quoting options:

'...' "..." «...» --- literals
/.../, r'...' r"..." r«...» --- Tendril regex (like JS regex, but with (1)+(2))
jr/.../ - JavaScript compatible regex (disables (1) and (2))

~ LITERAL_OR_REGEX --- Substring match (unanchored)

This is brainstorming, not a polished proposal. Any suggestions? (Ignore missing details with obvious resolutions.)

Below is how I would rewrite **CW 12** as a *user-guide* section.
It assumes no prior knowledge of the old rules, avoids grammar talk, and focuses on “what you type” and “what it means,” with motivation first and corner cases last.

---

        Below is how I would rewrite **CW12** in *user-guide style*, with:

1. a **short, high-level summary** about the size/density of your original CW12, and
2. the **longer explanatory section** (the one you liked earlier), revised so that **Plan B is the default** and explained using your “bind-if-unknown, assert-if-known” framing rather than “constrain the search.”

---

            ## Regex in Tendril — Summary
            
            Tendril integrates regex as a **single, predictable matching step**, not as a second pattern language.
            
            Key rules:
            
            1. **Regexes are anchored by default.**
               `/foo/` matches `"foo"`, not `"seafood"`.
            
            2. **Named capture groups bind Tendril variables.**
               A group named `(?<$x>…)` binds `$x` if it is unbound, or asserts its value if it is already bound.
            
            3. **Regexes do not enumerate solutions.**
               Each regex produces at most one result per Tendril branch.
            
            4. **Substring matching is explicit.**
               Use `~ /foo/` or `~ "foo"` when you want “contains” behavior.
            
            5. **Regex binding follows Tendril’s normal unification rules.**
               A bound variable is tested, not re-chosen.
            
            6. **JavaScript-compatible regex is available as an escape hatch.**
               `jr/.../` disables Tendril-specific behavior.
            
            This makes regex behave like other Tendril matchers:
            *bind if unknown, assert if known, never silently multiply solutions.*
            
            ---
            
            ## Regex in Tendril (Predictable and Integrated)
            
            Regexes are useful in Tendril, but they should not introduce hidden search behavior or surprise interactions with unification. Tendril therefore treats regex as a **single matching operation with optional extraction**, fully integrated into the existing binding model.
            
            This section explains how regex behaves in Tendril and how it differs from JavaScript regex.
            
            ---
            
            ### 1. Regexes match the entire value
            
            In Tendril, a regex literal like:
            
            ```
            /foo/
            ```
            
            matches the **entire string**, not a substring.
            
            ```
            /foo/     // matches "foo"
                      // does NOT match "seafood"
            ```
            
            This aligns regex with all other Tendril patterns: a value either matches or it doesn’t.
            
            If you want substring matching, see **Substring matching** below.
            
            ---
            
            ### 2. Regex alternation does not create Tendril branches
            
            Regex alternation (`|`) is handled entirely inside the regex engine.
            
            Even if a regex has multiple internal matches, Tendril treats it as **one atomic test** and never enumerates alternatives as separate solutions.
            
            ```
            /foo|bar/
            ```
            
            either matches or fails; it does not produce two Tendril branches.
            
            This prevents accidental solution explosion.
            
            ---
            
            ### 3. Named capture groups bind Tendril variables
            
            Regex groups whose names start with `$` participate directly in Tendril binding.
            
            ```
            /(?<$ext>\w+)/
            ```
            
            Example:
            
            ```js
            Tendril("{ file: /.*\\.(?<$ext>\\w+)/ }")
              .match({ file: "report.pdf" })
              .solutions().first()
            // → { ext: "pdf" }
            ```
            
            ---
            
            ### 4. Bound variables turn captures into assertions
            
            A `$`-named capture group behaves differently depending on whether the variable is already bound.
            
            #### If the variable is unbound
            
            The group captures a value and binds it, like a normal regex capture.
            
            #### If the variable is already bound
            
            The group **does not choose a new value**.
            Instead, it **asserts** that the bound value appears at that position and satisfies the group’s pattern.
            
            In effect:
            
            > A `$`-named regex group means “bind if unknown; assert if known.”
            
            This mirrors Tendril’s behavior everywhere else.
            
            ---
            
            ### 5. Example: why this matters
            
            Consider this regex:
            
            ```
            /(?<$x>a)b | a(?<$x>b)/
            ```
            
            On the string `"ab"`, both alternatives are valid.
            
            Now suppose `$x` is already bound to `"b"` elsewhere in the pattern.
            
            Under Tendril semantics:
            
            * The first alternative is rejected (it would require `$x = "a"`).
            * The second alternative succeeds.
            
            So `"ab"` **does match**, and `$x` remains `"b"`.
            
            This is equivalent to the Tendril pattern:
            
            ```
            [ $x=(a) b | a $x=(b) ]
            ```
            
            Once `$x` is known, each occurrence simply tests it.
            
            ---
            
            ### 6. How to think about it
            
            You do **not** need to think about regex backtracking.
            
            The mental model is:
            
            > Regex runs once.
            > `$`-named groups bind variables if they are unknown,
            > and assert those variables if they are already known.
            
            This avoids the “regex picked the wrong witness” surprise and keeps regex commutative with other Tendril matchers in the same way that repeated variables are.
            
            ---
            
            ### 7. Substring matching is explicit
            
            Because regexes are anchored, substring matching must be explicit.
            
            Use the substring operator:
            
            ```
            ~ /foo/
            ~ "foo"
            ```
            
            Examples:
            
            ```
            ~ /foo/    // matches "seafood"
            ~ "foo"    // matches "seafood"
            ```
            
            Substring matching applies only to strings; other types do not coerce silently.
            
            ---
            
            ### 8. Regex vs literals
            
            Often you don’t need regex at all.
            
            ```
            foo/i
            ```
            
            is usually clearer and safer than:
            
            ```
            /foo/i
            ```
            
            Use regex when you need structure or extraction:
            
            ```
            /\d{4}-\d{2}-\d{2}/
            /(?<$user>[a-z]+)@/
            ```
            
            ---
            
            ### 9. Regex flavors
            
            #### Tendril regex (default)
            
            ```
            /.../flags
            ```
            
            * Anchored
            * Supports `$`-named capture groups
            * Participates in unification
            * Disallows stateful flags (`g`, `y`)
            * Allowed flags: `i m s u`
            
            This is the regex you usually want.
            
            #### JavaScript regex (escape hatch)
            
            ```
            jr/.../flags
            ```
            
            * JavaScript behavior
            * Substring matching
            * No Tendril bindings
            * No anchoring changes
            
            Use this only when you need exact JS compatibility.
            
            ---
            
            ### 10. What regex does *not* do in Tendril
            
            Regex does not:
            
            * enumerate alternatives
            * create multiple Tendril solutions
            * override unification rules
            * silently coerce non-strings
            * introduce hidden backtracking across the pattern
            
            If you want enumeration, use Tendril alternation.
            If you want validation, use guards.
            If you want search, use `~`.
            
            ---
            
            ### One-sentence takeaway
            
            > In Tendril, regex is a **single match with optional binding**:
            > it binds unknown variables and asserts known ones, just like the rest of the language.
            
            If you want, next we can:
            
            * tighten this further for README length, or
            * add a migration note showing how existing `/foo/` patterns change under anchoring.

# LOG [2026-01-05T00:49:25-08:00]

Opened.
