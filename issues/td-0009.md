#### CW 9. Currently If a variable in an EL expression is unbound, the evaluation is deferred. If the variable never gets bound by the time the entire pattern is matched, then it fails.

Proposal. Permit defaults. An expression with a default may be evaluated immediately if the expression is closed. Otherwise, it is deferred, but evaluated as soon as it becomes closed (to allow pruning ASAP).
If after the entire pattern is matched, it is still open and cannot be evaluated, then we evaluate the expression using the defaults. (If there are still free variables without defaults, then it fails. )
This honors our current support for forward reference expressions having deferred evaluation.

`{
    sum: $sum=(_ where $sum==default($n,0)+default($s,0))
    ( 
      number: $n ?
      string: $s ?
    )
}`
For now, we only propose to support primitive defaults.
It is a syntax error to declare a default for a variable that does not appear anywhere else in the pattern. (guard against typos).

To rephrase:

Treat default($x, v) as a three-valued reference at evaluation time:

If $x is bound, it evaluates to that value.

If $x is unbound but might still be bound later, the whole guard is not yet evaluable (defer).

Only if the guard reaches the end of pattern evaluation and $x is still unbound, then default($x, v) evaluates to v.

Operationally: defaults don’t make expressions “closed”; they only change what happens at the final “still-open” check.

Tiny doc-friendly phrasing

Something like:

default($x, v) does not count as binding $x. Guards are still deferred until all referenced variables are bound. Defaults apply only at the end of matching, if some referenced variables remain unbound.

