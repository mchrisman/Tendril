{
  "permissions": {
    "allow": [
      "Bash(chmod:*)",
      "Bash(node test:*)",
      "Bash(node:*)",
      "Bash(npm test:*)",
      "Bash(cat:*)",
      "Bash(npm run:*)",
      "Bash(DEBUG_REPLACE=1 node:*)",
      "Bash(./run-all:*)",
      "Bash(awk:*)",
      "Bash(./test/run-all.cjs:*)",
      "Bash(ls:*)",
      "Bash(grep:*)",
      "Bash(find:*)",
      "Bash(rg:*)",
      "Bash(xxd:*)",
      "Bash(git mv:*)",
      "Bash(git show:*)",
      "Bash(git -C /Users/mchrisman/s/Tendril diff --stat)",
      "Bash(git -C /Users/mchrisman/s/Tendril log --oneline -5)",
      "Bash(gh issue create --title \"TD-25: Universal \\\\`!\\\\` Suffix Syntax\" --body \"$\\(cat <<''EOF''\n## Summary\n\nUnify \"for all\" / \"no bad entries\" semantics across objects, arrays, and paths using a `!` suffix on patterns and wildcards.\n\n## Motivation\n\nCurrently, the `each` keyword provides universal quantification in objects:\n```\n{each K: V}     // all keys matching K must have values matching V\n```\n\nBut there''s no elegant equivalent for arrays. The `!` suffix could unify both contexts.\n\n## Proposed Syntax\n\n### Objects\n\n| Syntax | Meaning | Current Equivalent |\n|--------|---------|-------------------|\n| `K: V` | existential: at least one | `K: V` |\n| `K!: V` | universal: all K must have V | `each K: V` |\n| `K?: V` | optional existential | `K: V ?` or `K?: V` |\n| `K!?: V` | optional universal | `each K?: V` |\n\n### Arrays via Path Notation\n\n| Syntax | Meaning |\n|--------|---------|\n| `_[$x]` | existential: some element matches |\n| `_[$x!]` | universal: ALL elements must match |\n\n### Paths\n\n```\n{items[$i].id: $x}      // some item has id\n{items[$i!].id: $x}     // ALL items have id\n\n{users._!.active: true} // all fields of users have active:true\n\n{foo[$i!].bar[$j!]: $x} // every foo element''s every bar element\n{foo[$i!].bar[$j]: $x}  // every foo element has at least one bar\n{foo[$i].bar[$j!]: $x}  // some foo element has all bars matching\n```\n\n### Combining with Implication\n\nThe `!` suffix works orthogonally with `=>` \\(implication\\):\n```\n{items[$i!]: \\({} => {type:_}\\)}\n// Every item: if it''s an object, it must have a ''type'' field\n```\n\n## Design Questions\n\n1. **Deprecate `each`?** Is `K!:V` clear enough on its own, or keep `each K:V` as verbose synonym?\n\n2. **Syntax conflicts?** Does `!` conflict with negative lookahead `\\(!...\\)`? Context should disambiguate: `\\(!` is lookahead, `!:` or `!]` is universal suffix.\n\n3. **Binding semantics:** Does `_[$x!]` yield:\n   - One solution with all elements \\(like `[\\(P* as @x\\)]`\\)\n   - N solutions, one per element \\(like iteration\\)\n   - Both depending on `$` vs `@`?\n\n4. **Standalone `_!`:** Does `_!` alone mean anything? Current thinking: no, `!` only meaningful on wildcards in paths/indices.\n\n## Related\n\n- TD-2: Language pruning and simplification\n- TD-17: Simplified object field semantics\n- `=>` implication syntax \\(not yet ticketed\\)\n\n---\n*Migrated from `issues/td-25-universal-suffix-syntax.md`*\nEOF\n\\)\")",
      "Bash(git add:*)",
      "Bash(git commit:*)"
    ],
    "deny": [],
    "ask": []
  }
}
