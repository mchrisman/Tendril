+++ api.js
@@ -0,0 +1,596 @@
+// api.js
+// Fluent Tendril API: Tendril and Solutions classes.
+// Exposes logical solutions, positional occurrences, projection utilities,
+// and replacement/editing without author-authored >>…<< markers.
+//
+// JSDoc types are provided for editor tooling without TypeScript.
+//
+// This layer delegates matching to the Milestone 4 interpreter helpers
+// exported from objects-sets-paths-replace.js. It does not change core
+// language semantics (anchoring, unification, lookaheads).
+
+import { parseAndValidate } from "./syntax.js";
+import {
+  parseAndLower,
+  matchAll,
+} from "./objects-sets-paths-replace.js";
+
+/**
+ * @typedef {Object} OccurrenceRef
+ * @property {"array-slice"|"object-value"|"object-keys"|"value"} kind
+ * @property {any} [ref]
+ * @property {number} [start]
+ * @property {number} [end]
+ * @property {string|number|any} [key]
+ * @property {Array<string|number|any>} [keys]
+ * @property {Array<string|number>} [path]
+ */
+
+/**
+ * @typedef {Object} Solution
+ * @property {Object<string, any>} bindings
+ * @property {Object<string, OccurrenceRef[]>} at
+ * @property {OccurrenceRef[]} where
+ */
+
+/**
+ * Wrapper for a lazy sequence of Solution objects with combinators.
+ */
+class Solutions {
+  /**
+   * @param {() => Iterable<Solution>} genFactory
+   */
+  constructor(genFactory) {
+    this._genFactory = genFactory;
+    /** @type {Array<(sol: Solution) => boolean>} */
+    this._filters = [];
+    /** @type {null|{vars: string[], key?: (b: Record<string, unknown>) => string}} */
+    this._uniqueSpec = null;
+    /** @type {number|null} */
+    this._takeN = null;
+  }
+
+  /**
+   * Deduplicate by selected vars. Overload: unique('$A','$B') or unique(['$A','$B'], {key})
+   * @param  {...any} args
+   * @returns {Solutions}
+   */
+  unique(...args) {
+    /** @type {string[]} */
+    let vars = [];
+    /** @type {((b: Record<string, unknown>) => string)|undefined} */
+    let key;
+    if (args.length === 0) return this;
+    if (Array.isArray(args[0])) {
+      vars = /** @type {string[]} */ (args[0]);
+      if (args[1] && typeof args[1].key === "function") key = args[1].key;
+    } else {
+      vars = /** @type {string[]} */ (args);
+    }
+    const next = new Solutions(this._genFactory);
+    next._filters = this._filters.slice();
+    next._takeN = this._takeN;
+    next._uniqueSpec = { vars, key };
+    return next;
+  }
+
+  /**
+   * @param {(sol: Solution) => boolean} pred
+   * @returns {Solutions}
+   */
+  filter(pred) {
+    const next = new Solutions(this._genFactory);
+    next._filters = this._filters.concat([pred]);
+    next._takeN = this._takeN;
+    next._uniqueSpec = this._uniqueSpec;
+    return next;
+  }
+
+  /**
+   * @param {number} n
+   * @returns {Solutions}
+   */
+  take(n) {
+    const next = new Solutions(this._genFactory);
+    next._filters = this._filters.slice();
+    next._takeN = Math.max(0, n|0);
+    next._uniqueSpec = this._uniqueSpec;
+    return next;
+  }
+
+  /**
+   * Map over bindings lazily.
+   * @template T
+   * @param {(bindings: Record<string, unknown>) => T} f
+   * @returns {Iterable<T>}
+   */
+  map(f) {
+    const self = this;
+    return {
+      [Symbol.iterator](): Iterator<any> {
+        const base = self[Symbol.iterator]();
+        return {
+          next() {
+            const n = base.next();
+            if (n.done) return n;
+            return { value: f(n.value.bindings), done: false };
+          }
+        };
+      }
+    };
+  }
+
+  /**
+   * Eager projection into an array.
+   * @template T
+   * @param {(bindings: Record<string, unknown>) => T} f
+   * @returns {T[]}
+   */
+  extract(f) {
+    const out = [];
+    for (const sol of this) out.push(f(sol.bindings));
+    return out;
+  }
+
+  /**
+   * Alias for extract.
+   * @template T
+   * @param {(bindings: Record<string, unknown>) => T} f
+   * @returns {T[]}
+   */
+  project(f) { return this.extract(f); }
+
+  /**
+   * Side effects over full solutions.
+   * @param {(sol: Solution) => void} f
+   * @returns {void}
+   */
+  forEach(f) { for (const s of this) f(s); }
+
+  /**
+   * Replace all occurrences per-solution by symbol map.
+   * Implementation: gather edits from each solution's at, schedule, apply immutably.
+   * @param {(bindings: Record<string, unknown>) => Partial<Record<string, unknown>>} f
+   * @param {any} root
+   * @returns {any}
+   */
+  replace(f, root) {
+    const edits = [];
+    for (const sol of this) {
+      const plan = f(sol.bindings) || {};
+      for (const [varName, to] of Object.entries(plan)) {
+        const spots = sol.at[varName] || [];
+        for (const ref of spots) edits.push({ ref, to });
+      }
+    }
+    return applyScheduledEdits(root, edits);
+  }
+
+  /**
+   * Replace using explicit ref list per solution.
+   * @param {(sol: Solution) => Array<{ref: OccurrenceRef, to: unknown}>} f
+   * @param {any} root
+   * @returns {any}
+   */
+  edit(f, root) {
+    const edits = [];
+    for (const sol of this) {
+      const list = f(sol) || [];
+      for (const e of list) edits.push(e);
+    }
+    return applyScheduledEdits(root, edits);
+  }
+
+  /**
+   * Materialize solutions into an array.
+   * @returns {Solution[]}
+   */
+  toArray() { return Array.from(this); }
+
+  /**
+   * First solution or null.
+   * @returns {Solution|null}
+   */
+  first() {
+    const it = this[Symbol.iterator]();
+    const n = it.next();
+    return n.done ? null : n.value;
+  }
+
+  /**
+   * Count solutions (consumes iterator).
+   * @returns {number}
+   */
+  count() { let c = 0; for (const _ of this) c++; return c; }
+
+  /**
+   * Iterator composing filters, uniqueness, and take().
+   * @returns {Iterator<Solution>}
+   */
+  [Symbol.iterator]() {
+    const baseIt = this._genFactory()[Symbol.iterator]();
+    const filters = this._filters;
+    const unique = this._uniqueSpec;
+    const takeN = this._takeN;
+    /** @type {Set<string>|null} */
+    const seen = unique ? new Set() : null;
+    let yielded = 0;
+    return {
+      next: () => {
+        while (true) {
+          const n = baseIt.next();
+          if (n.done) return n;
+          /** @type {Solution} */
+          const sol = n.value;
+          let ok = true;
+          for (const f of filters) { if (!f(sol)) { ok = false; break; } }
+          if (!ok) continue;
+          if (seen) {
+            const k = (unique.key
+              ? unique.key(projectBindings(sol.bindings, unique.vars))
+              : stableKey(projectBindings(sol.bindings, unique.vars)));
+            if (seen.has(k)) continue;
+            seen.add(k);
+          }
+          if (takeN != null && yielded >= takeN) return { value: undefined, done: true };
+          yielded++;
+          return { value: sol, done: false };
+        }
+      }
+    };
+  }
+}
+
+/**
+ * Fluent workhorse entrypoint.
+ */
+export class Tendril {
+  /**
+   * @param {string} pattern
+   */
+  constructor(pattern) {
+    this._pattern = String(pattern);
+    /** @type {Record<string, unknown>} */
+    this._env = {};
+    /** @type {{unicodeNormalize?: 'NFC'|'NFD'}} */
+    this._opts = {};
+    /** @type {any} */
+    this._ast = null;
+  }
+
+  /**
+   * @param {Record<string, unknown>} bindings
+   * @returns {Tendril}
+   */
+  withEnv(bindings) {
+    const t = new Tendril(this._pattern);
+    t._env = Object.assign({}, this._env, bindings || {});
+    t._opts = this._opts;
+    t._ast = this._ast;
+    return t;
+  }
+
+  /**
+   * @param {{unicodeNormalize?: 'NFC'|'NFD'}} opts
+   * @returns {Tendril}
+   */
+  withOptions(opts) {
+    const t = new Tendril(this._pattern);
+    t._env = this._env;
+    t._opts = Object.assign({}, this._opts, opts || {});
+    t._ast = this._ast;
+    return t;
+  }
+
+  /**
+   * @param {any} input
+   * @returns {Solutions}
+   */
+  solutions(input) {
+    const ast = this._ast || (this._ast = parseAndLower(parseAndValidate(this._pattern)));
+    const env = this._env;
+    const opts = this._opts;
+    return new Solutions(function* () {
+      yield* matchAll(ast, input, { envSeed: env, semOpts: opts, mode: "logical" });
+    });
+  }
+
+  /**
+   * @param {any} input
+   * @returns {Solutions}
+   */
+  occurrences(input) {
+    const ast = this._ast || (this._ast = parseAndLower(parseAndValidate(this._pattern)));
+    const env = this._env;
+    const opts = this._opts;
+    return new Solutions(function* () {
+      yield* matchAll(ast, input, { envSeed: env, semOpts: opts, mode: "scan" });
+    });
+  }
+
+  /**
+   * First logical solution or null.
+   * @param {any} input
+   * @returns {Solution|null}
+   */
+  match(input) {
+    return this.solutions(input).first();
+  }
+
+  /**
+   * All logical solutions as an array.
+   * @param {any} input
+   * @returns {Solution[]}
+   */
+  all(input) {
+    return this.solutions(input).toArray();
+  }
+}
+
+/**
+ * Convenience: true if any logical solution exists.
+ * @param {string} pattern
+ * @param {any} input
+ */
+export function matches(pattern, input) {
+  return new Tendril(pattern).match(input) !== null;
+}
+
+/**
+ * Convenience: bindings from first logical solution or null.
+ * @param {string} pattern
+ * @param {any} input
+ * @returns {Record<string, unknown>|null}
+ */
+export function extract(pattern, input) {
+  const s = new Tendril(pattern).match(input);
+  return s ? s.bindings : null;
+}
+
+/**
+ * Convenience: bindings from all logical solutions.
+ * @param {string} pattern
+ * @param {any} input
+ * @returns {Record<string, unknown>[]}
+ */
+export function extractAll(pattern, input) {
+  return new Tendril(pattern).solutions(input).extract(b => b);
+}
+
+/**
+ * Convenience: pattern → template rewrite.
+ * Caller should bind the intended target symbol in the pattern and emit it from builder.
+ * @template T
+ * @param {string} pattern
+ * @param {(bindings: Record<string, unknown>) => T} builder
+ * @param {any} input
+ * @returns {any}
+ */
+export function replaceAll(pattern, builder, input) {
+  // Default idiom: user binds $out or similar in their pattern
+  return new Tendril(pattern).occurrences(input).replace(b => ({ $out: builder(b) }), input);
+}
+
+/**
+ * Convenience: unique projected bindings for selected vars.
+ * @param {string} pattern
+ * @param {any} input
+ * @param  {...string} vars
+ * @returns {Record<string, unknown>[]}
+ */
+export function uniqueMatches(pattern, input, ...vars) {
+  return new Tendril(pattern)
+    .solutions(input)
+    .unique(vars)
+    .extract(b => projectBindings(b, vars));
+}
+
+/* ======================= helpers ======================= */
+
+/**
+ * @param {Record<string, unknown>} b
+ * @param {string[]} vars
+ */
+function projectBindings(b, vars) {
+  const out = {};
+  for (const v of vars) if (Object.prototype.hasOwnProperty.call(b, v)) out[v] = b[v];
+  return out;
+}
+
+/**
+ * Build a stable structural key aligned with deep-structural equality.
+ * @param {any} v
+ * @returns {string}
+ */
+function stableKey(v) {
+  const seen = new WeakMap();
+  let id = 0;
+  const enc = (x) => {
+    if (x === null) return ["null"];
+    const t = typeof x;
+    if (t === "undefined") return ["u"];
+    if (t === "number") return ["n", Number.isNaN(x) ? "NaN" : String(x)];
+    if (t === "boolean") return ["b", x ? "1" : "0"];
+    if (t === "string") return ["s", x];
+    if (t === "function") return ["f"];
+    if (t !== "object") return ["o", String(x)];
+    if (seen.has(x)) return ["r", seen.get(x)];
+    seen.set(x, ++id);
+    // Array
+    if (Array.isArray(x)) return ["A", x.map(enc)];
+    // Set
+    if (x instanceof Set) {
+      const arr = Array.from(x).map(enc).map(JSON.stringify).sort();
+      return ["S", arr];
+    }
+    // Map
+    if (x instanceof Map) {
+      const pairs = Array.from(x.entries()).map(([k, v]) => [enc(k), enc(v)].map(JSON.stringify));
+      pairs.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0));
+      return ["M", pairs];
+    }
+    // Plain object
+    const keys = Object.keys(x).sort();
+    return ["O", keys.map(k => [k, enc(x[k])])];
+  };
+  return JSON.stringify(enc(v));
+}
+
+/**
+ * Apply non-overlapping edits left→right to root; returns a new root.
+ * Supports array-slice, object-value, object-keys (rename), and generic value paths.
+ * @param {any} root
+ * @param {Array<{ref: OccurrenceRef, to: unknown}>} edits
+ * @returns {any}
+ */
+function applyScheduledEdits(root, edits) {
+  // Compute a deterministic left→right order:
+  const orderKey = (e) => {
+    const r = e.ref;
+    if (r.kind === "array-slice") return ["A", String(r.ref?.length || 0), r.start, r.end].join("|");
+    if (r.kind === "object-value") return ["O", String(r.key)].join("|");
+    if (r.kind === "object-keys") return ["K", JSON.stringify(r.keys || [])].join("|");
+    if (r.kind === "value") return ["V", JSON.stringify(r.path || [])].join("|");
+    return "Z";
+  };
+  const plan = edits.slice().sort((a, b) => (orderKey(a) < orderKey(b) ? -1 : orderKey(a) > orderKey(b) ? 1 : 0));
+  // Naive overlap filter: drop exact-duplicate refs (simple safeguard).
+  const seen = new Set();
+  const uniq = [];
+  for (const e of plan) {
+    const k = JSON.stringify(e.ref);
+    if (seen.has(k)) continue;
+    seen.add(k);
+    uniq.push(e);
+  }
+  let out = root;
+  for (const e of uniq) {
+    const r = e.ref;
+    if (r.kind === "array-slice") {
+      const arr = r.ref;
+      const start = r.start|0, end = r.end|0;
+      const parent = arr;
+      const before = parent.slice(0, start);
+      const after = parent.slice(end);
+      const mid = Array.isArray(e.to) ? e.to : [e.to];
+      const newArr = before.concat(mid, after);
+      // Replace array in its parent if we can, otherwise if root equals this arr, replace root
+      if (out === parent) out = newArr;
+    } else if (r.kind === "object-value") {
+      if (r.ref instanceof Map) {
+        const m = new Map(r.ref);
+        m.set(r.key, e.to);
+        if (out === r.ref) out = m;
+      } else {
+        const o = Array.isArray(r.ref) ? r.ref.slice() : Object.assign({}, r.ref);
+        o[r.key] = e.to;
+        if (out === r.ref) out = o;
+      }
+    } else if (r.kind === "object-keys") {
+      // Basic support: if keys array has single key and 'to' is a string, rename.
+      const keys = r.keys || [];
+      if (keys.length === 1 && typeof e.to === "string") {
+        if (r.ref instanceof Map) {
+          const m = new Map(r.ref);
+          const k0 = keys[0];
+          const val = m.get(k0);
+          m.delete(k0);
+          m.set(e.to, val);
+          if (out === r.ref) out = m;
+        } else {
+          const o = Object.assign({}, r.ref);
+          const k0 = keys[0];
+          const val = o[k0];
+          delete o[k0];
+          o[e.to] = val;
+          if (out === r.ref) out = o;
+        }
+      }
+    } else if (r.kind === "value") {
+      // Follow path on a shallow-clone basis; only support simple object/array descent.
+      const path = r.path || [];
+      out = setAtPathImmutable(out, path, e.to);
+    }
+  }
+  return out;
+}
+
+/**
+ * Immutable set at JSON path for plain objects/arrays/maps. Minimal support.
+ * @param {any} root
+ * @param {Array<string|number>} path
+ * @param {any} to
+ * @returns {any}
+ */
+function setAtPathImmutable(root, path, to) {
+  if (path.length === 0) return to;
+  const [h, ...t] = path;
+  if (Array.isArray(root)) {
+    const idx = /** @type {number} */ (h);
+    const next = setAtPathImmutable(root[idx], t, to);
+    const copy = root.slice();
+    copy[idx] = next;
+    return copy;
+  }
+  if (root instanceof Map) {
+    const copy = new Map(root);
+    const next = setAtPathImmutable(root.get(h), t, to);
+    copy.set(h, next);
+    return copy;
+  }
+  if (root && typeof root === "object") {
+    const copy = Object.assign({}, root);
+    copy[h] = setAtPathImmutable(root[h], t, to);
+    return copy;
+  }
+  // Fallback: cannot descend; return root unchanged.
+  return root;
+}
+
--- objects-sets-paths-replace.js
+++ objects-sets-paths-replace.js
@@ -1 +1 @@
-import { parseAndValidate, PatternSyntaxError } from "./syntax.js";
+import { parseAndValidate, PatternSyntaxError } from "./syntax.js";
@@ -100,0 +101,28 @@
+/**
+ * Public helper: parse then lower vertical paths everywhere.
+ * @param {string|object} sourceOrAst
+ * @returns {object}
+ */
+export function parseAndLower(sourceOrAst) {
+  const ast = typeof sourceOrAst === "string" ? parseAndValidate(sourceOrAst) : sourceOrAst;
+  return lowerVerticalEverywhere(ast);
+}
+
+/**
+ * Build a Solution object from current context.
+ * @param {Env} env
+ * @param {Map<string, Array<any>>} varOcc
+ * @param {Array<any>} pathStack
+ */
+function makeSolution(env, varOcc, pathStack) {
+  const bindings = Object.fromEntries(env.map.entries());
+  const at = {};
+  for (const [k, arr] of varOcc.entries()) at[k] = arr.slice();
+  const where = pathStack.slice();
+  return { bindings, at, where };
+}
+
+/**
+ * Traverse a structure to yield positional "occurrence" candidates (value, pathStack).
+ * @param {any} val
+ * @param {Array<any>} path
+ * @param {(v:any, path:any[])=>void} cb
+ */
+function traverseAll(val, path, cb) {
+  cb(val, path);
+  if (Array.isArray(val)) {
+    for (let i = 0; i < val.length; i++) {
+      const ref = { kind: "array-slice", ref: val, start: i, end: i + 1 };
+      traverseAll(val[i], path.concat([ref]), cb);
+    }
+    return;
+  }
+  if (isObj(val)) {
+    for (const k of Object.keys(val)) {
+      const ref = { kind: "object-value", ref: val, key: k };
+      traverseAll(val[k], path.concat([ref]), cb);
+    }
+    return;
+  }
+  if (isMap(val)) {
+    for (const [k, v] of val.entries()) {
+      const ref = { kind: "object-value", ref: val, key: k };
+      traverseAll(v, path.concat([ref]), cb);
+    }
+  }
+}
+
 // Shared matching logic for Object and Map patterns (differ only in type check)
 function* matchObjectLike(n, val, ctx, typeCheck) {
   if (!typeCheck(val)) return;
   const cov = new Coverage(val);
@@
   yield ctx.env;
 }
 
 function* matchNode(n, val, ctx) {
   // ctx: { env: Env, path: any[], captures: {arrSlices:[], objKeys:[], objVals:[]}, opts }
   switch (n.type) {
+    /* ---- Variables & Bindings ---- */
+    case "Var": {
+      const ok = ctx.env.bindOrCheck(n.name, val, ctx.opts);
+      if (!ok) return;
+      // Record occurrence ref if we have a concrete currentRef on stack; else generic breadcrumb.
+      recordVarOcc(ctx, n.name);
+      yield ctx.env;
+      return;
+    }
+    case "Bind": {
+      for (const _ of matchNode(n.pat, val, ctx)) {
+        const ok = ctx.env.bindOrCheck(n.name, val, ctx.opts);
+        if (!ok) continue;
+        recordVarOcc(ctx, n.name);
+        yield ctx.env;
+      }
+      return;
+    }
@@
     /* ---- Arrays (anchored by default; Spread = _*?) ---- */
     case "Array": {
       if (!isArr(val)) return;
       // Build element program
       const elems = n.elems.slice();
@@
         // Normal element: match single array element
         if (j >= val.length) return;
-        for (const _ of matchNode(el, val[j], ctx)) {
+        // Push a concrete ref for breadcrumb and var occurrence capture
+        ctx.path.push({ kind: "array-slice", ref: val, start: j, end: j + 1 });
+        for (const _ of matchNode(el, val[j], ctx)) {
           yield* matchFrom(i + 1, j + 1);
         }
+        ctx.path.pop();
       }
 
       yield* matchFrom(0, 0);
       return;
     }
@@
     case "Object": {
-      yield* matchObjectLike(n, val, ctx, isObj);
+      yield* matchObjectLike(n, val, ctx, isObj);
       return;
     }
@@
     case "Map": {
-      yield* matchObjectLike(n, val, ctx, isMap);
+      yield* matchObjectLike(n, val, ctx, isMap);
       return;
     }
@@
     default:      return n;
   }
 }
 
+/**
+ * Record a variable occurrence for the current location (top of ctx.path),
+ * or a generic value ref if no path info exists.
+ * @param {{varOcc: Map<string, any[]>, path: any[]}} ctx
+ * @param {string} name
+ */
+function recordVarOcc(ctx, name) {
+  let arr = ctx.varOcc.get(name);
+  if (!arr) { arr = []; ctx.varOcc.set(name, arr); }
+  const top = ctx.path[ctx.path.length - 1];
+  if (top) arr.push(top);
+  else arr.push({ kind: "value", ref: undefined, path: [] });
+}
+
+/* ============================== Public matching API ============================== */
+
+/**
+ * Generate Solution objects for logical or scan modes.
+ * @param {object} ast
+ * @param {any} input
+ * @param {{envSeed?: Record<string, any>, semOpts?: import('./semantics.js').SemanticsOptions, mode?: "logical"|"scan"}} opts
+ */
+export function* matchAll(ast, input, opts = {}) {
+  const mode = opts.mode || "logical";
+  const semOpts = opts.semOpts || undefined;
+  if (mode === "logical") {
+    const baseCtx = {
+      env: new Env(opts.envSeed || null),
+      opts: semOpts,
+      path: [],
+      varOcc: new Map(),
+      captures: { arrSlices: [], objKeys: [], objVals: [] },
+    };
+    for (const _ of matchNode(ast, input, baseCtx)) {
+      yield makeSolution(baseCtx.env, baseCtx.varOcc, baseCtx.path);
+      // backtracking will naturally roll env; varOcc must be cleared per solution
+      baseCtx.varOcc = new Map();
+    }
+    return;
+  }
+  // scan mode
+  traverseAll(input, [], (v, path) => {
+    const baseCtx = {
+      env: new Env(opts.envSeed || null),
+      opts: semOpts,
+      path: path.slice(),
+      varOcc: new Map(),
+      captures: { arrSlices: [], objKeys: [], objVals: [] },
+    };
+    for (const _ of matchNode(ast, v, baseCtx)) {
+      yield makeSolution(baseCtx.env, baseCtx.varOcc, baseCtx.path);
+      baseCtx.varOcc = new Map();
+    }
+  });
+}
+
*** End Patch
