{
  "version": 3,
  "sources": ["../src/tendril-util.js", "../src/microparser.js", "../src/tendril-parser.js", "../src/tendril-engine.js", "../src/tendril-api.js"],
  "sourcesContent": ["// tendril-util.js \u2014 shared utility functions\n\n/**\n * Deep equality check for structural comparison\n */\nexport function deepEqual(a, b) {\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== 'object') return Object.is(a, b); // handles NaN\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  if (Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n", "// microparser.js \u2014 minimal tokenizer + parser skeleton for Tendril\n// Focus: correctness & brevity; serves as the base for parser/engine.\n\nimport { deepEqual } from './tendril-util.js';\n\n// ---------- Tokenizer ----------\n\n/**\n * Token: { k, v, pos }\n *  - k: kind (e.g., 'id','num','str','re','any', or a symbol literal '.' '[' '..' '|' '{' etc.)\n *  - v: value (e.g., number, string, RegExp parts, symbol literal)\n *  - pos: source index where token starts (used for errors)\n */\nexport function tokenize(src) {\n  const toks = [];\n  let i = 0;\n\n  const push = (k, v, len) => { toks.push({ k, v, pos: i }); i += len; };\n  const reWS = /\\s+/y;\n  const reNum = /\\d+/y;\n  const reId  = /[A-Za-z_][A-Za-z0-9_]*/y;\n\n  while (i < src.length) {\n    // whitespace (incl. newlines)\n    reWS.lastIndex = i;\n    if (reWS.test(src)) { i = reWS.lastIndex; continue; }\n\n    const c = src[i], c2 = src.slice(i, i + 2), c3 = src.slice(i, i + 3);\n\n    // comments //... to end-of-line (optional but handy)\n    if (c2 === '//') {\n      let j = i + 2;\n      while (j < src.length && src[j] !== '\\n') j++;\n      i = j; continue;\n    }\n\n    // strings: \"...\" or '...'\n    if (c === '\"' || c === \"'\") {\n      const q = c;\n      let j = i + 1, out = '';\n      while (j < src.length && src[j] !== q) {\n        if (src[j] === '\\\\') {\n          const { chr, adv } = readEsc(src, j + 1);\n          out += chr; j += adv + 1;\n        } else {\n          out += src[j++]; \n        }\n      }\n      if (src[j] !== q) throw syntax(`unterminated string`, src, i);\n      push('str', out, (j + 1) - i);\n      continue;\n    }\n\n    // regex literal: /.../flags  (no division in this DSL; treat leading / as regex)\n    if (c === '/' && src[i + 1] !== '/') {\n      // Parse regex by trying each '/' as potential terminator, validating with RegExp constructor\n      let found = false;\n      for (let j = i + 1; j < src.length && !found; ) {\n        j = src.indexOf('/', j);\n        if (j < 0) break; // no more '/' found\n\n        // Capture flags after this potential terminator\n        let k = j + 1;\n        while (k < src.length && /[a-z]/i.test(src[k])) k++;\n\n        const pattern = src.slice(i + 1, j);\n        const flags = src.slice(j + 1, k);\n\n        // Try to construct RegExp to validate this is a valid endpoint\n        try {\n          new RegExp(pattern, flags);\n          // Valid! This is the correct endpoint\n          push('re', { source: pattern, flags: flags }, k - i);\n          found = true;\n        } catch {\n          // Invalid regex, try next '/'\n          j++;\n        }\n      }\n\n      if (!found) throw syntax(`unterminated or invalid regex`, src, i);\n      continue;\n    }\n\n    // number\n    reNum.lastIndex = i;\n    if (reNum.test(src)) {\n      const j = reNum.lastIndex;\n      push('num', Number(src.slice(i, j)), j - i);\n      continue;\n    }\n\n    // identifier / keyword / ANY\n    reId.lastIndex = i;\n    if (reId.test(src)) {\n      const j = reId.lastIndex;\n      const w = src.slice(i, j);\n      // if (w === 'AND')   { push('kw', 'AND', j - i); continue; }\n      if (w === '_')     { push('any', '_',   j - i); continue; }\n      if (w === 'true')  { push('bool', true, j - i); continue; }\n      if (w === 'false') { push('bool', false, j - i); continue; }\n      if (w === 'null')  { push('null', null, j - i); continue; }\n      push('id', w, j - i);\n      continue;\n    }\n\n    // multi-character punctuation/operators (order matters - check longer tokens first!)\n    if (c3 === '(?=') { push('(?=', '(?=', 3); continue; }   // positive lookahead\n    if (c3 === '(?!') { push('(?!', '(?!', 3); continue; }   // negative lookahead\n    if (c2 === '..')  { push('..', '..', 2); continue; }\n    if (c2 === '?:')  { push('?:', '?:', 2); continue; }   // optional assertion operator\n    if (c2 === '??')  { push('??', '??', 2); continue; }   // lazy optional\n    if (c2 === '++')  { push('++', '++', 2); continue; }   // possessive plus\n    if (c2 === '*+')  { push('*+', '*+', 2); continue; }   // possessive star\n    if (c2 === '+?')  { push('+?', '+?', 2); continue; }   // lazy plus\n    if (c2 === '*?')  { push('*?', '*?', 2); continue; }   // lazy star\n\n    // one-character punctuation/operators\n    const single = '[](){}:,.$@=|*+?!-#'.includes(c) ? c : null;\n    if (single) { push(single, single, 1); continue; }\n\n    throw syntax(`unexpected character '${c}'`, src, i);\n  }\n  return toks;\n}\n\n// Escapes inside strings: \\n \\r \\t \\\" \\' \\\\ \\uXXXX \\u{...}\nfunction readEsc(s, i) {\n  const ch = s[i];\n  if (ch === 'n')  return { chr: '\\n', adv: 1 };\n  if (ch === 'r')  return { chr: '\\r', adv: 1 };\n  if (ch === 't')  return { chr: '\\t', adv: 1 };\n  if (ch === '\"' || ch === \"'\" || ch === '\\\\') return { chr: ch, adv: 1 };\n  if (ch === 'u') {\n    if (s[i + 1] === '{') {\n      let j = i + 2, hex = '';\n      while (j < s.length && s[j] !== '}') hex += s[j++];\n      if (s[j] !== '}') return { chr: 'u', adv: 1 }; // fallback\n      return { chr: String.fromCodePoint(parseInt(hex, 16) || 0), adv: (j + 1) - i };\n    } else {\n      const hex = s.slice(i + 1, i + 5);\n      return { chr: String.fromCharCode(parseInt(hex, 16) || 0), adv: 5 };\n    }\n  }\n  // default: identity (e.g., \\x => 'x')\n  return { chr: ch, adv: 1 };\n}\n\nfunction syntax(msg, src, pos) {\n  const caret = `${src}\\n${' '.repeat(pos)}^`;\n  const err = new Error(`${msg}\\n${caret}`);\n  err.pos = pos;\n  return err;\n}\n\n// ---------- Parser skeleton ----------\n\nexport class Parser {\n  constructor(src, tokens = tokenize(src)) {\n    this.src = src;\n    this.toks = tokens;\n    this.i = 0;\n    this._cut = null;\n    this.farthest = { i: 0, exp: new Set() };\n  }\n\n  // --- cursor\n  atEnd() { return this.i >= this.toks.length; }\n  cur()   { return this.toks[this.i]; }\n\n  /**\n   * peek(...alts): if no args, returns current token or null.\n   * If args given, returns truthy if current token matches any by kind or value.\n   */\n  peek(...alts) {\n    const t = this.toks[this.i];\n    if (!t) return null;\n    if (!alts.length) return t;\n    for (const a of alts) if (t.k === a || t.v === a) return t;\n    return null;\n  }\n\n  // eat specific kind/value; when kind omitted, consumes current\n  eat(kind, msg) {\n    const t = this.toks[this.i];\n    if (!t) return this.fail(msg || `unexpected end of input`);\n    if (kind && !(t.k === kind || t.v === kind))\n      return this.fail(msg || `expected ${kind}`);\n    this.i++;\n    return t;\n  }\n\n  maybe(kindOrVal) {\n    const t = this.toks[this.i];\n    if (t && (t.k === kindOrVal || t.v === kindOrVal)) { this.i++; return t; }\n    return null;\n  }\n\n  expect(...alts) {\n    const t = this.peek(...alts);\n    if (!t) this.fail(`expected ${alts.join('|')}`);\n    // prefer consuming by exact match for better messages\n    return this.eat(t.k);\n  }\n\n  // --- error control\n  cut() { this._cut = this.i; }              // commit to branch to localize errors\n  mark() { return { i: this.i, cut: this._cut }; }\n  restore(m) { this.i = m.i; this._cut = m.cut; }\n\n  fail(msg = 'syntax error') {\n    // record farthest error (for tooling, if desired)\n    if (this.i >= this.farthest.i) {\n      const set = new Set(this.farthest.exp);\n      set.add(msg);\n      this.farthest = { i: this.i, exp: set };\n    }\n    const pos = this.toks[this.i]?.pos ?? this.src.length;\n    throw syntax(msg, this.src, pos);\n  }\n\n  // --- backtracking\n  backtrack(fn) {\n    const save = this.mark();\n    try { return fn(); }\n    catch (e) {\n      if (this._cut != null && save.i >= this._cut) throw e; // committed\n      this.restore(save);\n      return null;\n    }\n  }\n\n  many(parseOne) {\n    const out = [];\n    for (;;) {\n      const save = this.mark();\n      const node = this.backtrack(parseOne);\n      if (node == null) { this.restore(save); break; }\n      out.push(node);\n    }\n    return out;\n  }\n\n  until(parseOne, stopPred) {\n    const out = [];\n    while (!this.atEnd() && !stopPred()) out.push(parseOne());\n    return out;\n  }\n\n  // --- Pratt machinery (used for low-precedence '|')\n  parseExpr(spec, minPrec = 0) {\n    let lhs = spec.primary(this);\n    for (;;) {\n      const op = spec.peekOp(this);\n      if (!op) break;\n      const { prec, assoc, kind } = spec.info(op);\n      if (prec < minPrec) break;\n\n      if (kind === 'postfix') {\n        this.eat(op);\n        lhs = spec.buildPostfix(op, lhs);\n        continue;\n      }\n      // infix\n      this.eat(op);\n      const rhs = this.parseExpr(spec, assoc === 'right' ? prec : prec + 1);\n      lhs = spec.buildInfix(op, lhs, rhs);\n    }\n    return lhs;\n  }\n}\n\n// ---------- Binding helpers (shared across engine/parser) ----------\n\n/**\n * env: Map<string, {kind:'scalar'|'group', value:any}>\n * We keep it simple and explicit; engine will ensure no accidental mutation.\n */\nexport function cloneEnv(env) {\n  const e = new Map();\n  for (const [k, v] of env) e.set(k, v);\n  return e;\n}\n\nexport function isBound(env, name) {\n  return env.has(name);\n}\n\nexport function bindScalar(env, name, val) {\n  const cur = env.get(name);\n  if (!cur) { env.set(name, { kind: 'scalar', value: val }); return true; }\n  return cur.kind === 'scalar' && deepEqual(cur.value, val);\n}\n\nexport function bindGroup(env, name, group) {\n  const cur = env.get(name);\n  if (!cur) { env.set(name, { kind: 'group', value: group }); return true; }\n  if (cur.kind !== 'group') return false; // Never group<->scalar\n  // Unify groups using structural equality\n  return deepEqual(cur.value, group);\n}\n\n// Utilities to build real RegExp at parse-time when convenient\nexport function makeRegExp(spec) {\n  // spec: { source, flags }\n  try { return new RegExp(spec.source, spec.flags || ''); }\n  catch (e) { throw new Error(`invalid regex: /${spec.source}/${spec.flags||''}`); }\n}\n\n// Pretty location (optional; parse errors already caret-print)\nexport function where(p) {\n  const t = p.cur();\n  const pos = t ? t.pos : p.src.length;\n  return { pos };\n}\n", "// tendril-parser.js \u2014 v5-A compliant parser\n// Implements the v5-A grammar from README-v5-A.md exactly.\n//\n// Grammar structure:\n//   ROOT_PATTERN := ITEM\n//   ITEM := atoms, bindings, objects, arrays, alternations\n//   A_GROUP := array group patterns (with quantifiers, @x, $x)\n//   O_GROUP := object group patterns (with breadcrumbs, @x)\n//\n// AST Node Types:\n//   Atoms: Any, Lit, Re, Bool, Null\n//   Containers: Arr, Obj\n//   Bindings: SBind (scalar $x), GroupBind (group @x)\n//   Operators: Alt, Look, Quant\n//   Object: OTerm (with breadcrumbs), Spread (..)\n//   Breadcrumbs: Breadcrumb (no quantifiers in v5)\n\nimport {Parser, makeRegExp} from './microparser.js';\n\n// ---------- Public API ----------\n\nexport function parsePattern(src) {\n  const p = new Parser(src);\n  const ast = parseRootPattern(p);\n  if (!p.atEnd()) p.fail('trailing input after pattern');\n  return ast;\n}\n\n// ---------- AST Node Constructors ----------\n\n// Atoms\nconst Any = () => ({type: 'Any'});\nconst Lit = (v) => ({type: 'Lit', value: v});\nconst Re = (r) => ({type: 'Re', re: r});\nconst Bool = (v) => ({type: 'Bool', value: v});\nconst Null = () => ({type: 'Null'});\nconst RootKey = () => ({type: 'RootKey'}); // Special marker for leading .. in paths\n\n// Bindings\nconst SBind = (name, pat) => ({type: 'SBind', name, pat});  // $x=(pat)\nconst GroupBind = (name, pat) => ({type: 'GroupBind', name, pat});  // @x=(pat)\n\n// Containers\nconst Arr = (items) => ({type: 'Arr', items});\nconst Obj = (terms, spread = null) => ({type: 'Obj', terms, spread});\n\n// Operators\nconst Alt = (alts) => ({type: 'Alt', alts});\nconst Look = (neg, pat) => ({type: 'Look', neg, pat});\nconst Quant = (sub, op, min = null, max = null) => ({\n  type: 'Quant',\n  sub,\n  op,  // '?', '??', '+', '++', '+?', '*', '*+', '*?', '*{...}'\n  min,\n  max\n});\n\n// Object terms\nconst OTerm = (key, breadcrumbs, op, val, quant) => ({\n  type: 'OTerm',\n  key,           // ITEM\n  breadcrumbs,   // Breadcrumb[]\n  op,            // '=' or '?='\n  val,           // ITEM\n  quant          // null or {min, max}\n});\n\nconst Spread = (quant) => ({type: 'Spread', quant});  // .. with optional #{...}\n\nconst Breadcrumb = (kind, key, quant) => ({\n  type: 'Breadcrumb',\n  kind,   // 'dot' or 'bracket'\n  key,    // ITEM\n  quant   // null or {op: '?'|'+'|'*', min, max}\n});\n\n// ---------- ROOT_PATTERN ----------\n\nfunction parseRootPattern(p) {\n  return parseItem(p);\n}\n\n// ---------- ITEM ----------\n\nfunction parseItem(p) {\n  // Handle alternation at this level (lowest precedence)\n  // ITEM := Term ('|' Term)*\n  let left = parseItemTerm(p);\n\n  if (p.peek('|')) {\n    const alts = [left];\n    while (p.maybe('|')) {\n      alts.push(parseItemTerm(p));\n    }\n    return Alt(alts);\n  }\n\n  return left;\n}\n\nfunction parseItemTerm(p) {\n  // ITEM := '(' ITEM ')'\n  //       | S_ITEM\n  //       | S_ITEM '=' '(' ITEM ')'\n  //       | '_'\n  //       | LITERAL\n  //       | OBJ\n  //       | ARR\n\n  // Parenthesized item\n  if (p.peek('(?=') || p.peek('(?!')) {\n    // Lookahead: (?= or (?!\n    return parseLookahead(p);\n  }\n\n  if (p.peek('(')) {\n    // Could be grouping or binding with parens\n    // Just grouping\n    p.eat('(');\n    const inner = parseItem(p);\n    p.eat(')');\n    return inner;\n  }\n\n  // Scalar binding: $x or $x=(...)\n  if (p.peek('$')) {\n    p.eat('$');\n    const name = p.eat('id').v;\n    if (p.maybe('=')) {\n      p.eat('(');\n      const pat = parseItem(p);\n      p.eat(')');\n      return SBind(name, pat);\n    }\n    // Bare $x means $x=(_)\n    return SBind(name, Any());\n  }\n\n  // Group binding: @x or @x=(...)\n  if (p.peek('@')) {\n    p.eat('@');\n    const name = p.eat('id').v;\n    if (p.maybe('=')) {\n      p.eat('(');\n      const pat = parseAGroup(p);\n      p.eat(')');\n      return GroupBind(name, pat);\n    }\n    // Bare @x means @x=(_*)\n    return GroupBind(name, Quant(Any(), '*', 0, Infinity));\n  }\n\n  // Wildcard\n  if (p.maybe('any')) {\n    return Any();\n  }\n\n  // Literals\n  if (p.peek('num')) {\n    return Lit(p.eat('num').v);\n  }\n  if (p.peek('bool')) {\n    return Bool(p.eat('bool').v);\n  }\n  if (p.peek('null')) {\n    p.eat('null');\n    return Null();\n  }\n  if (p.peek('str')) {\n    return Lit(p.eat('str').v);\n  }\n  if (p.peek('id')) {\n    // Bareword string\n    return Lit(p.eat('id').v);\n  }\n  if (p.peek('re')) {\n    const {source, flags} = p.eat('re').v;\n    return Re(makeRegExp({source, flags}));\n  }\n\n  // Object\n  if (p.peek('{')) {\n    return parseObj(p);\n  }\n\n  // Array\n  if (p.peek('[')) {\n    return parseArr(p);\n  }\n\n  p.fail('expected item (literal, wildcard, $var, @var, array, object, or parenthesized expression)');\n}\n\nfunction parseLookahead(p) {\n  // (?= A_GROUP) or (?! A_GROUP)\n  let neg = false;\n  if (p.peek('(?=')) {\n    p.eat('(?=');\n  } else if (p.peek('(?!')) {\n    p.eat('(?!');\n    neg = true;\n  } else {\n    p.fail('expected (?= or (?! for lookahead');\n  }\n  const pat = parseAGroup(p);\n  p.eat(')');\n  return Look(neg, pat);\n}\n\nfunction parseObjectLookahead(p) {\n  // (?= O_GROUP) or (?! O_GROUP)\n  let neg = false;\n  if (p.peek('(?=')) {\n    p.eat('(?=');\n  } else if (p.peek('(?!')) {\n    p.eat('(?!');\n    neg = true;\n  } else {\n    p.fail('expected (?= or (?! for object lookahead');\n  }\n  const pat = parseOGroup(p);\n  p.eat(')');\n  return {type: 'OLook', neg, pat};\n}\n\n// ---------- ARRAYS ----------\n\n// A_BODY := (A_GROUP (','? A_GROUP)*)?\nfunction parseABody(p, stopToken) {\n  const items = [];\n  while (!p.peek(stopToken)) {\n    items.push(parseAGroup(p));\n    p.maybe(',');  // Optional comma\n  }\n  return items;\n}\n\nfunction parseArr(p) {\n  // ARR := '[' A_BODY ']'\n  p.eat('[');\n  const items = parseABody(p, ']');\n  p.eat(']');\n  return Arr(items);\n}\n\nfunction parseAGroup(p) {\n  // A_GROUP := '(' A_BODY ')'\n  //          | S_GROUP\n  //          | S_GROUP '=' '(' A_BODY ')'\n  //          | S_ITEM\n  //          | S_ITEM '=' '(' A_BODY ')'\n  //          | ITEM\n  //          | OBJ\n  //          | ARR\n  //          | A_GROUP A_QUANT\n  //          | A_GROUP '|' A_GROUP\n  //          | '(?=' A_GROUP ')'\n  //          | '(?!' A_GROUP ')'\n\n  // Special handling for .. (spread)\n  if (p.peek('..')) {\n    p.eat('..');\n    // .. in array context is a Spread, optionally followed by quantifier\n    const quant = p.backtrack(() => parseAQuant(p));\n    return Spread(quant ? `${quant.op}` : null);\n  }\n\n  let base = parseAGroupBase(p);\n\n  // Handle quantifier\n  const q = p.backtrack(() => parseAQuant(p));\n  if (q) {\n    base = Quant(base, q.op, q.min, q.max);\n  }\n\n  // Handle alternation\n  if (p.peek('|')) {\n    const alts = [base];\n    while (p.maybe('|')) {\n      let alt = parseAGroupBase(p);\n      const q = p.backtrack(() => parseAQuant(p));\n      if (q) {\n        alt = Quant(alt, q.op, q.min, q.max);\n      }\n      alts.push(alt);\n    }\n    return Alt(alts);\n  }\n\n  return base;\n}\n\nfunction parseAGroupBase(p) {\n  // Base A_GROUP without quantifiers or alternation\n\n  // Lookahead\n  if (p.peek('(?=') || p.peek('(?!')) {\n    return parseLookahead(p);\n  }\n\n  // Parenthesized A_BODY\n  if (p.peek('(')) {\n    p.eat('(');\n    const items = parseABody(p, ')');\n    p.eat(')');\n    // If single item, return it; otherwise wrap in Seq node\n    if (items.length === 1) return items[0];\n    return {type: 'Seq', items};\n  }\n\n  // Group binding: @x or @x=(...)\n  if (p.peek('@')) {\n    p.eat('@');\n    const name = p.eat('id').v;\n    if (p.maybe('=')) {\n      p.eat('(');\n      const items = parseABody(p, ')');\n      p.eat(')');\n      // If single item, use directly; otherwise create Seq\n      const pat = items.length === 1 ? items[0] : {type: 'Seq', items};\n      return GroupBind(name, pat);\n    }\n    return GroupBind(name, Quant(Any(), '*', 0, Infinity));\n  }\n\n  // Scalar binding: $x or $x=(...)\n  if (p.peek('$')) {\n    p.eat('$');\n    const name = p.eat('id').v;\n    if (p.maybe('=')) {\n      p.eat('(');\n      const items = parseABody(p, ')');\n      p.eat(')');\n      // If single item, use directly; otherwise create Seq\n      const pat = items.length === 1 ? items[0] : {type: 'Seq', items};\n      return SBind(name, pat);\n    }\n    return SBind(name, Any());\n  }\n\n  // Otherwise, parse as ITEM\n  return parseItemTerm(p);\n}\n\n// isAQuant removed - use backtracking with parseAQuant instead\n\nfunction parseAQuant(p) {\n  // A_QUANT := '?' | '??'\n  //          | '+' | '+?' | '++'\n  //          | '*' | '*?' | '*+'\n  //          | '{' INTEGER '}'\n  //          | '{' INTEGER ',' INTEGER? '}'\n  //          | '{' ',' INTEGER '}'\n\n  if (p.maybe('??')) return {op: '??', min: 0, max: 1};\n  if (p.maybe('?'))  return {op: '?', min: 0, max: 1};\n  if (p.maybe('++')) return {op: '++', min: 1, max: null};\n  if (p.maybe('+?')) return {op: '+?', min: 1, max: null};\n  if (p.maybe('+'))  return {op: '+', min: 1, max: null};\n  if (p.maybe('*+')) return {op: '*+', min: 0, max: null};\n  if (p.maybe('*?')) return {op: '*?', min: 0, max: null};\n  if (p.maybe('*'))  return {op: '*', min: 0, max: null};\n\n  // {m}, {m,n}, {m,}, {,n}\n  if (p.maybe('{')) {\n    let min = null, max = null;\n\n    if (p.maybe(',')) {\n      // {,n}\n      min = 0;\n      max = p.eat('num').v;\n    } else {\n      min = p.eat('num').v;\n      if (p.maybe(',')) {\n        if (p.peek('num')) {\n          max = p.eat('num').v;\n        } else {\n          max = null;  // unbounded\n        }\n      } else {\n        max = min;  // exact count\n      }\n    }\n\n    p.eat('}');\n    return {op: `{${min},${max ?? ''}}`, min, max};\n  }\n\n  p.fail('expected quantifier');\n}\n\n// ---------- OBJECTS ----------\n\nfunction parseObj(p) {\n  // OBJ := '{' O_BODY O_REMNANT? '}'\n  // O_REMNANT := S_GROUP ':' '(' 'remainder' ')'\n  //            | '(?!' 'remainder' ')'\n  //            | 'remainder'\n  p.eat('{');\n  const terms = [];\n\n  // Parse O_BODY: greedily parse O_GROUPs until we can't\n  while (true) {\n    const group = p.backtrack(() => {\n      if (p.peek('}')) return null;\n      const s = parseOGroup(p);\n      p.maybe(',');\n      return s;\n    });\n    if (!group) break;\n    terms.push(group);\n  }\n\n  // Now try to parse optional O_REMNANT\n  const remnant = parseORemnant(p);\n\n  p.eat('}');\n  return Obj(terms, remnant);\n}\n\nfunction parseORemnant(p) {\n  // O_REMNANT := S_GROUP '=' '(' 'remainder' '?'? ')'\n  //            | '(?!' 'remainder' ')'\n  //            | 'remainder' '?'?\n\n  // Try @x=(remainder) or @x=(remainder?)\n  const bindRemnant = p.backtrack(() => {\n    if (!p.peek('@')) return null;\n    p.eat('@');\n    const name = p.eat('id').v;\n    if (!p.maybe('=')) return null;\n    p.eat('(');\n    if (!(p.peek('id') && p.peek().v === 'remainder')) return null;\n    p.eat('id');\n    const quant = p.maybe('?') ? '?' : null;\n    p.eat(')');\n    p.maybe(',');\n    return GroupBind(name, Spread(quant));\n  });\n  if (bindRemnant) return bindRemnant;\n\n  // Try bare 'remainder' or 'remainder?'\n  const bareRemnant = p.backtrack(() => {\n    if (!(p.peek('id') && p.peek().v === 'remainder')) return null;\n    p.eat('id');\n    const quant = p.maybe('?') ? '?' : null;\n    p.maybe(',');\n    return Spread(quant);\n  });\n  if (bareRemnant) return bareRemnant;\n\n  // Try (?!remainder)\n  const negRemnant = p.backtrack(() => {\n    if (!p.peek('(?!')) return null;\n    p.eat('(?!');\n    if (!(p.peek('id') && p.peek().v === 'remainder')) return null;\n    p.eat('id');\n    p.eat(')');\n    p.maybe(',');\n    return {type: 'OLook', neg: true, pat: Spread(null)};\n  });\n  if (negRemnant) return negRemnant;\n\n  // Check for common mistake: using '..' instead of 'remainder'\n  if (p.peek('..')) {\n    p.fail('bare \"..\" not allowed in objects; use \"remainder\" or \"@x=(remainder)\" instead');\n  }\n\n  return null;\n}\n\nfunction parseOGroup(p) {\n  // O_GROUP := '(' O_BODY ')'\n  //          | S_GROUP\n  //          | S_GROUP '=' '(' O_GROUP* ')'\n  //          | O_TERM\n  //          | '(?=' O_GROUP ')'\n  //          | '(?!' O_GROUP ')'\n\n  // Try lookahead first\n  if (p.peek('(?=') || p.peek('(?!')) {\n    return parseObjectLookahead(p);\n  }\n\n  // Try parenthesized O_BODY: '(' O_BODY ')'\n  // Use backtracking because '(' could also be part of O_TERM's key pattern\n  const groupResult = p.backtrack(() => {\n    p.eat('(');\n    const groups = [];\n    while (!p.peek(')')) {\n      groups.push(parseOGroup(p));\n      p.maybe(',');\n    }\n    p.eat(')');\n    return {type: 'OGroup', groups};\n  });\n  if (groupResult) return groupResult;\n\n  // S_GROUP: Group binding @x=(O_BODY)\n  if (p.peek('@')) {\n    p.eat('@');\n    const name = p.eat('id').v;\n    if (p.maybe('=')) {\n      p.eat('(');\n      // Parse O_BODY: @x=(pattern)\n      const groups = [];\n      while (!p.peek(')')) {\n        groups.push(parseOGroup(p));\n        p.maybe(',');\n      }\n      p.eat(')');\n      return GroupBind(name, {type: 'OGroup', groups});\n    }\n    // Bare @x in object context is not allowed\n    p.fail('bare @x not allowed in objects; use @x=(remainder) to bind residual keys');\n  }\n\n  // Otherwise parse O_TERM\n  // O_TERM will parse KEY (including $x=(ITEM) patterns) normally via parseItem\n  // Leading .. is now allowed in OTerm for paths like {..password:$x}\n  return parseOTerm(p);\n}\n\nfunction parseOTerm(p) {\n  // O_TERM := KEY BREADCRUMB* '?'? (':' | '?:') VALUE O_QUANT?\n  //         | '..' BREADCRUMB* '?'? (':' | '?:') VALUE O_QUANT?  (leading .. for zero-depth)\n\n  // Check for leading .. (e.g., {..password:$x})\n  let key;\n  const breadcrumbs = [];\n\n  if (p.peek('..')) {\n    // Leading .. means \"start from root, match at any depth including zero\"\n    // Use special RootKey marker\n    key = RootKey();\n    // Don't consume the '..' yet - it will be parsed as first breadcrumb\n  } else {\n    // KEY BREADCRUMB* op VALUE\n    key = parseItem(p);\n  }\n\n  // Parse breadcrumbs (. .. or [)\n  while (p.peek('.') || p.peek('..') || p.peek('[')) {\n    const bc = parseBreadcrumb(p);\n    if (bc) breadcrumbs.push(bc);\n    else break;\n  }\n\n  // '?'? (':' | '?:') \u2192 canonicalize to '?:'\n  // Try longer patterns first: '? ?:', '? :', '?:', ':'\n  let op = null;\n\n  // Try '? ?:' or '? :'\n  const questOp = p.backtrack(() => {\n    if (!p.maybe('?')) return null;\n    if (p.maybe('?:')) return '?:';\n    if (p.maybe(':')) return '?:'; // canonicalize '? :' to '?:'\n    return null;\n  });\n  if (questOp) {\n    op = questOp;\n  } else if (p.maybe('?:')) {\n    op = '?:';\n  } else if (p.maybe(':')) {\n    op = ':';\n  } else {\n    p.fail('expected : or ?: in object term');\n  }\n\n  // VALUE\n  const val = parseItem(p);\n\n  // O_QUANT?\n  const quant = parseOQuant(p);\n\n  return OTerm(key, breadcrumbs, op, val, quant);\n}\n\nfunction parseBreadcrumb(p) {\n  // BREADCRUMB := '..' KEY          // skip levels\n  //             | '..' ':' or '?:'  // skip to any key (use _ as key)\n  //             | '.' KEY            // single level\n  //             | '[' KEY ']'        // array index\n\n  // Skip levels: .. KEY\n  if (p.peek('..')) {\n    p.eat('..');\n    // Special case: '..' immediately followed by ':' or '?' means \"any key at any depth\"\n    if (p.peek(':') || p.peek('?:') || p.peek('?')) {\n      return Breadcrumb('skip', Any(), null);\n    }\n    const key = parseItem(p);\n    return Breadcrumb('skip', key, null);\n  }\n\n  // Dot notation: . KEY\n  if (p.peek('.')) {\n    p.eat('.');\n    const key = parseItem(p);\n    return Breadcrumb('dot', key, null);\n  }\n\n  // Bracket notation: [ KEY ]\n  if (p.peek('[')) {\n    p.eat('[');\n    const key = parseItem(p);\n    p.eat(']');\n    return Breadcrumb('bracket', key, null);\n  }\n\n  return null;\n}\n\n// parseBQuant removed - breadcrumbs no longer support quantifiers in v5\n\nfunction parseOQuant(p) {\n  // O_QUANT := '#' ( '?' | '{' INTEGER (',' INTEGER?)? '}' )\n  if (!p.peek('#')) return null;\n\n  p.eat('#');\n  if (p.maybe('?')) {\n    return {min: 0, max: null};  // #{0,\u221E}\n  }\n\n  if (!p.peek('{')) p.fail('expected { or ? after #');\n  p.eat('{');\n\n  const min = p.eat('num').v;\n  let max = min;\n\n  if (p.maybe(',')) {\n    if (p.peek('num')) {\n      max = p.eat('num').v;\n    } else {\n      max = null;  // unbounded\n    }\n  }\n\n  p.eat('}');\n\n  if (max !== null && max < min) p.fail('O_QUANT upper < lower');\n  return {min, max};\n}\n\n// ---------- Parser Utilities ----------\n\n// Add peekAt helper if not in Parser class\nParser.prototype.peekAt = function(offset, kind) {\n  const idx = this.i + offset;\n  if (idx >= this.toks.length) return false;\n  return this.toks[idx].k === kind;\n};\n\n// ---------- Exports ----------\n\nexport const AST = {\n  // Atoms\n  Any, Lit, Re, Bool, Null, RootKey,\n  // Bindings\n  SBind, GroupBind,\n  // Containers\n  Arr, Obj,\n  // Operators\n  Alt, Look, Quant,\n  // Object\n  OTerm, Spread, Breadcrumb,\n};\n", "// tendril-engine.js \u2014 evaluator for Tendril v5-A AST\n// Requires AST produced by tendril-parser.js and helpers from microparser.js\n\nimport {\n  bindScalar, bindGroup, cloneEnv, isBound,\n} from './microparser.js';\nimport {Group} from './tendril-api.js';\n\n// ------------- Solution structure: {env, sites} -------------\n// Solution tracks both bindings (env) and where they were bound (sites)\n// Site kinds:\n//  - scalar: {kind: 'scalar', path: [], valueRef: obj}\n//  - group (array): {kind: 'group', path: [], groupStart: n, groupEnd: m, valueRefs: [obj1, ...]}\n//  - group (object): {kind: 'group', path: [], keys: ['a', ...], valueRefs: {a: obj1, ...}}\n\nfunction newSolution() {\n  return {env: new Map(), sites: new Map()};\n}\n\nfunction cloneSolution(sol) {\n  const sites = new Map();\n  for (const [k, v] of sol.sites) {\n    sites.set(k, [...v]); // shallow copy of site array\n  }\n  return {env: cloneEnv(sol.env), sites};\n}\n\nfunction recordScalarSite(sol, varName, path, valueRef) {\n  if (!sol.sites.has(varName)) {\n    sol.sites.set(varName, []);\n  }\n  sol.sites.get(varName).push({kind: 'scalar', path: [...path], valueRef});\n}\n\nfunction recordGroupSite(sol, varName, path, groupStart, groupEnd, valueRefs) {\n  if (!sol.sites.has(varName)) {\n    sol.sites.set(varName, []);\n  }\n  sol.sites.get(varName).push({\n    kind: 'group',\n    path: [...path],\n    groupStart,\n    groupEnd,\n    valueRefs: [...valueRefs],\n  });\n}\n\n// Public entry: evaluate a parsed ITEM AST on input, return list of solutions.\n// Each solution: {bindings: Object, sites: Map<varName, Site[]>}\nexport function match(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  const solutions = [];\n\n  matchItem(ast, input, [], newSolution(), (sol) => solutions.push(sol), ctx);\n\n  // Convert to public API format\n  return solutions.map(sol => {\n    const bindings = Object.fromEntries(\n      Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n    );\n    return {bindings, sites: sol.sites};\n  });\n}\n\n// Scan mode: find all occurrences at any depth\nexport function scan(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  const solutions = [];\n\n  // Helper: recursively scan value at path\n  function scanValue(value, path) {\n    guard(ctx);\n\n    // Try matching pattern at this position\n    matchItem(ast, value, path, newSolution(), (sol) => solutions.push(sol), ctx);\n\n    // Recursively descend into structure\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        scanValue(value[i], [...path, i]);\n      }\n    } else if (value && typeof value === 'object') {\n      for (const key of Object.keys(value)) {\n        scanValue(value[key], [...path, key]);\n      }\n    }\n  }\n\n  scanValue(input, []);\n\n  // Convert to public API format\n  return solutions.map(sol => {\n    const bindings = Object.fromEntries(\n      Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n    );\n    return {bindings, sites: sol.sites};\n  });\n}\n\n// Backward compatibility: matchProgram for old tests\nexport function matchProgram(ast, input, opts = {}) {\n  // Old AST had {type: 'Program', rules: [...]}\n  // Convert to new format or handle directly\n  if (ast.type === 'Program') {\n    throw new Error('Old Program AST not supported - use new v5-A parser');\n  }\n  return match(ast, input, opts);\n}\n\n// ------------- Core ITEM matching -------------\n\nfunction matchItem(item, node, path, sol, emit, ctx) {\n  guard(ctx);\n\n  // Debug hook: entering item match\n  if (ctx.debug?.onEnter) {\n    ctx.debug.onEnter(item.type, node, path);\n  }\n\n  let matched = false;\n  const originalEmit = emit;\n  const trackingEmit = (s) => {\n    matched = true;\n    originalEmit(s);\n  };\n\n  try {\n    // Temporarily replace emit to track if we matched\n    emit = trackingEmit;\n\n    doMatch();\n  } finally {\n    // Debug hook: exiting item match\n    if (ctx.debug?.onExit) {\n      ctx.debug.onExit(item.type, node, path, matched);\n    }\n  }\n\n  function doMatch() {\n    switch (item.type) {\n      case 'Any':\n        emit(cloneSolution(sol));\n        return;\n\n      case 'Lit':\n        if (Object.is(node, item.value)) emit(cloneSolution(sol));\n        return;\n\n      case 'Re':\n        if (item.re.test(String(node))) emit(cloneSolution(sol));\n        return;\n\n      case 'Bool':\n        if (Object.is(node, item.value)) emit(cloneSolution(sol));\n        return;\n\n      case 'Null':\n        if (node === null) emit(cloneSolution(sol));\n        return;\n\n      case 'Alt': {\n        for (const sub of item.alts) {\n          matchItem(sub, node, path, sol, emit, ctx);\n          guard(ctx);\n        }\n        return;\n      }\n\n      case 'Look': {\n        // Zero-width assertion; bindings from successful positive lookahead persist.\n        let matchedSol = null;\n        matchItem(item.pat, node, path, cloneSolution(sol), (s2) => {\n          if (!matchedSol) matchedSol = s2;  // capture first successful match\n        }, ctx);\n\n        const matched = (matchedSol !== null);\n        if ((matched && !item.neg) || (!matched && item.neg)) {\n          emit(matched ? matchedSol : cloneSolution(sol));\n        }\n        return;\n      }\n\n      case 'SBind': {\n        // Scalar binding: $x or $x:(pattern)\n        // Scalar bindings cannot match sequences - if pattern is Seq, no match\n        if (item.pat.type === 'Seq') {\n          // TODO: emit warning that $x:(seq) is invalid, should use @x:(seq)\n          return; // No match\n        }\n\n        // Match inner pattern, then bind variable to node if successful\n        matchItem(item.pat, node, path, sol, (s2) => {\n          const s3 = cloneSolution(s2);\n          if (bindScalar(s3.env, item.name, node)) {\n            recordScalarSite(s3, item.name, path, node);\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('scalar', item.name, node);\n            }\n            emit(s3);\n          }\n        }, ctx);\n        return;\n      }\n\n      case 'GroupBind': {\n        // Group binding can only appear in array/object contexts\n        // If appearing at top level, treat as error\n        throw new Error('Group binding @x cannot appear at top level');\n      }\n\n      case 'Arr': {\n        if (!Array.isArray(node)) return;\n        matchArray(item.items, node, path, sol, emit, ctx);\n        return;\n      }\n\n      case 'Obj': {\n        if (!isObject(node)) return;\n        matchObject(item.terms, item.spread, node, path, sol, emit, ctx);\n        return;\n      }\n\n      case 'Paren': {\n        matchItem(item.item, node, path, sol, emit, ctx);\n        return;\n      }\n\n      default:\n        throw new Error(`Unknown item type: ${item.type}`);\n    }\n  }\n}\n\n// ------------- Array matching -------------\n\nfunction matchArray(items, arr, path, sol, emit, ctx) {\n  // Optimize away trailing '..' (bare spread with no quantifier)\n  // This is redundant since it means \"consume any remaining elements\"\n  // Note: This only affects Spread nodes, not GroupBind nodes like @x\n  const last = items[items.length - 1];\n  const hadTrailingSpread = last && last.type === 'Spread' && last.quant == null;\n  if (hadTrailingSpread) {\n    items = items.slice(0, -1);\n  }\n\n  // Match array items anchored at start (and end if no trailing ..)\n  stepItems(0, 0, sol);\n\n  function stepItems(ixItem, ixArr, sIn) {\n    guard(ctx);\n    if (ixItem === items.length) {\n      // If we had trailing spread, allow leftover elements; otherwise require exact match\n      if (hadTrailingSpread || ixArr === arr.length) {\n        emit(cloneSolution(sIn));\n      }\n      return;\n    }\n    const it = items[ixItem];\n\n    // Spread '..' \u2014 try consuming k elements, k from 0..(remaining)\n    if (it.type === 'Spread') {\n      const {min, max} = parseQuantRange(it.quant);\n      const maxK = Math.min(max, arr.length - ixArr);\n\n      for (let k = min; k <= maxK; k++) {\n        stepItems(ixItem + 1, ixArr + k, sIn);\n        if (ctx.steps > ctx.maxSteps) break;\n      }\n      return;\n    }\n\n    // Group binding @x or @x:(pattern)\n    if (it.type === 'GroupBind') {\n      return matchArrayGroupBind(it, ixItem, ixArr, sIn);\n    }\n\n    // Quantified item (from parser: Quant node)\n    if (it.type === 'Quant') {\n      const min = it.min !== null ? it.min : 0;\n      const max = it.max !== null ? it.max : Infinity;\n      const op = it.op || '?';\n      return quantOnArray(it.sub, min, max, op, ixItem, ixArr, sIn);\n    }\n\n    // Lookahead \u2014 zero-width assertion at current position (unanchored)\n    if (it.type === 'Look') {\n      let matchedSol = null;\n      const remainingGroup = arr.slice(ixArr);\n\n      // Match the lookahead pattern against remaining array (unanchored at end)\n      // For negative lookahead, clone to discard bindings\n      // For positive lookahead, don't clone so bindings escape\n      const testSol = it.neg ? cloneSolution(sIn) : sIn;\n\n      // Make pattern unanchored by appending '..' if not already present\n      const patternItems = [it.pat];\n      const lastItem = patternItems[patternItems.length - 1];\n      const alreadyUnanchored = lastItem && lastItem.type === 'Spread';\n      if (!alreadyUnanchored) {\n        patternItems.push({type: 'Spread', quant: null}); // '..' with no quant\n      }\n\n      matchArray(patternItems, remainingGroup, [...path, ixArr], testSol, (s2) => {\n        if (!matchedSol) matchedSol = s2;\n      }, ctx);\n\n      const matched = (matchedSol !== null);\n      if ((matched && !it.neg) || (!matched && it.neg)) {\n        // For positive lookahead: use matchedSol (bindings escape)\n        // For negative lookahead: use sIn (bindings don't escape)\n        const continueSol = (matched && !it.neg) ? matchedSol : sIn;\n        stepItems(ixItem + 1, ixArr, continueSol);\n      }\n      return;\n    }\n\n    // Regular pattern item \u2014 match one element at current index\n    if (ixArr >= arr.length) return;\n    matchItem(it, arr[ixArr], [...path, ixArr], sIn, (s2) => {\n      stepItems(ixItem + 1, ixArr + 1, s2);\n    }, ctx);\n  }\n\n  function matchArrayGroupBind(groupBind, ixItem, ixArr, sIn) {\n    // @x matches 0+ consecutive items\n    // @x:(pat) matches 0+ items where each matches pat\n    const maxK = arr.length - ixArr;\n\n    // For @x:(item1 item2? ...), match a sequence of items\n    if (groupBind.pat.type === 'Seq') {\n      // Try each possible group length and see if the Seq pattern matches\n      // GREEDY: try longer groups first\n      for (let k = maxK; k >= 0; k--) {\n        const testGroup = arr.slice(ixArr, ixArr + k);\n\n        matchArray(groupBind.pat.items, testGroup, [...path, ixArr], sIn, (s2) => {\n          const group = testGroup;\n          const s3 = cloneSolution(s2);\n          const groupValue = Group.array(...group);\n          if (bindGroup(s3.env, groupBind.name, groupValue)) {\n            recordGroupSite(s3, groupBind.name, path, ixArr, ixArr + k, group);\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('group', groupBind.name, groupValue);\n            }\n            stepItems(ixItem + 1, ixArr + k, s3);\n          }\n        }, ctx);\n      }\n      return;\n    }\n\n    // For @x:(pat*), use quantifier logic with solution threading\n    if (groupBind.pat.type === 'Quant') {\n      const {sub, min, max, op} = groupBind.pat;\n      const m = min !== null ? min : 0;\n      const n = max !== null ? max : Infinity;\n      const quantOp = op || '?';\n\n      return quantOnArray(sub, m, n, quantOp, ixItem, ixArr, sIn, (st) => {\n        const start = ixArr;\n        const end = st.idx;\n        const group = arr.slice(start, end);\n        const s2 = cloneSolution(st.sol);\n        const groupValue = Group.array(...group);\n        if (bindGroup(s2.env, groupBind.name, groupValue)) {\n          recordGroupSite(s2, groupBind.name, path, start, end, group);\n          if (ctx.debug?.onBind) {\n            ctx.debug.onBind('group', groupBind.name, groupValue);\n          }\n          stepItems(ixItem + 1, end, s2);\n        }\n      });\n    } else {\n      // Non-quantified pattern: @x:(pattern) means exactly one item matching pattern\n      if (ixArr < arr.length) {\n        matchItem(groupBind.pat, arr[ixArr], [...path, ixArr], sIn, (s2) => {\n          const group = [arr[ixArr]];\n          const s3 = cloneSolution(s2);\n          const groupValue = Group.array(...group);\n          if (bindGroup(s3.env, groupBind.name, groupValue)) {\n            recordGroupSite(s3, groupBind.name, path, ixArr, ixArr + 1, group);\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('group', groupBind.name, groupValue);\n            }\n            stepItems(ixItem + 1, ixArr + 1, s3);\n          }\n        }, ctx);\n      }\n    }\n  }\n\n  function quantOnArray(sub, m, n, op, ixItem, ixArr, sIn, cont) {\n    // Consume exactly k repetitions for some k \u2208 [m..n]\n    const maxRep = Math.min(n, arr.length - ixArr);\n\n    // Determine if this is possessive (commit to first match, no backtracking)\n    const isPossessive = op && (op.startsWith('*{') || op.endsWith('+'));\n\n    const continueWith = cont\n      ? (st) => cont(st)\n      : (st) => stepItems(ixItem + 1, st.idx, st.sol);\n\n    // DP-like iterative expansion to avoid deep recursion explosion\n    let frontier = [{idx: ixArr, sol: cloneSolution(sIn), reps: 0}];\n\n    // First, ensure we can reach at least m reps\n    for (let r = 0; r < m; r++) {\n      const next = [];\n      for (const st of frontier) {\n        const {idx, sol} = st;\n        if (idx >= arr.length) continue;\n        matchItem(sub, arr[idx], [...path, idx], sol, (s2) => {\n          next.push({idx: idx + 1, sol: s2, reps: st.reps + 1});\n        }, ctx);\n      }\n      frontier = next;\n      if (!frontier.length) return; // cannot satisfy minimum\n    }\n\n    if (isPossessive) {\n      // Possessive: greedily consume as many as possible, then commit\n      // Continue expanding to maximum\n      for (let r = m; r < maxRep; r++) {\n        const grown = [];\n        for (const st of frontier) {\n          const {idx, sol} = st;\n          if (idx >= arr.length) continue;\n          matchItem(sub, arr[idx], [...path, idx], sol, (s2) => {\n            grown.push({idx: idx + 1, sol: s2, reps: st.reps + 1});\n          }, ctx);\n        }\n        if (!grown.length) break; // Can't match more\n        frontier = grown;\n      }\n      // Emit only the longest match (possessive - no backtracking)\n      for (const st of frontier) {\n        continueWith(st);\n      }\n    } else {\n      // Non-possessive: try all lengths from m to n (backtracking allowed)\n      // GREEDY: emit longer matches before shorter ones\n\n      // Collect all frontiers from m to maxRep\n      const allFrontiers = [frontier]; // frontier at m reps\n\n      for (let r = m; r < maxRep; r++) {\n        const grown = [];\n        for (const st of frontier) {\n          const {idx, sol} = st;\n          if (idx >= arr.length) continue;\n          matchItem(sub, arr[idx], [...path, idx], sol, (s2) => {\n            grown.push({idx: idx + 1, sol: s2, reps: st.reps + 1});\n          }, ctx);\n        }\n        if (!grown.length) break;\n        frontier = grown;\n        allFrontiers.push(frontier);\n      }\n\n      // Emit in reverse order: longest matches first (greedy)\n      for (let i = allFrontiers.length - 1; i >= 0; i--) {\n        for (const st of allFrontiers[i]) {\n          continueWith(st);\n        }\n      }\n    }\n  }\n}\n\n// ------------- Object matching -------------\n\nfunction matchObject(terms, spread, obj, path, sol, emit, ctx, outMatchedKeys = null) {\n  guard(ctx);\n\n  const DEBUG = false; // Set to true for debugging\n\n  // Process each OTerm sequentially, threading solutions through\n  // Each solution tracks its own tested keys for correct residual computation\n  let solutions = [{sol: cloneSolution(sol), testedKeys: new Set()}];\n\n  if (DEBUG) console.log(`[matchObject] obj keys:`, Object.keys(obj), `terms:`, terms.length);\n\n  for (const term of terms) {\n    // Handle group bindings: @var=(pattern) or @var=(remainder)\n    if (term.type === 'GroupBind') {\n      const isSpread = term.pat.type === 'Spread';\n      const next = [];\n\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n        if (isSpread) {\n          // @var=(remainder) - capture residual keys\n          const residualKeys = Object.keys(obj).filter(k => !testedKeys.has(k));\n          const residualObj = {};\n          for (const k of residualKeys) {\n            residualObj[k] = obj[k];\n          }\n\n          const s2 = cloneSolution(s0);\n          const groupValue = Group.object(residualObj);\n          if (bindGroup(s2.env, term.name, groupValue)) {\n            if (!s2.sites.has(term.name)) {\n              s2.sites.set(term.name, []);\n            }\n            s2.sites.get(term.name).push({\n              kind: 'group',\n              path: [...path],\n              keys: residualKeys,\n              valueRefs: residualObj\n            });\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('group', term.name, groupValue);\n            }\n            // Preserve tested keys for this branch\n            next.push({sol: s2, testedKeys: new Set(testedKeys)});\n          }\n        } else {\n          // @var=(pattern) - recursively match pattern, collect matched keys\n          if (term.pat.type !== 'OGroup') {\n            throw new Error(`GroupBind in object context expects OGroup or Spread pattern, got ${term.pat.type}`);\n          }\n\n          const matchedKeys = new Set();\n          matchObject(\n            term.pat.groups,\n            null,\n            obj,\n            path,\n            s0,\n            (s2) => {\n              // Bind the matched keys as a group\n              const capturedObj = {};\n              for (const k of matchedKeys) {\n                capturedObj[k] = obj[k];\n              }\n\n              const s3 = cloneSolution(s2);\n              const groupValue = Group.object(capturedObj);\n              if (bindGroup(s3.env, term.name, groupValue)) {\n                if (!s3.sites.has(term.name)) {\n                  s3.sites.set(term.name, []);\n                }\n                s3.sites.get(term.name).push({\n                  kind: 'group',\n                  path: [...path],\n                  keys: Array.from(matchedKeys),\n                  valueRefs: capturedObj\n                });\n                if (ctx.debug?.onBind) {\n                  ctx.debug.onBind('group', term.name, groupValue);\n                }\n                // Mark matched keys as tested in this branch\n                const newTestedKeys = new Set(testedKeys);\n                for (const k of matchedKeys) {\n                  newTestedKeys.add(k);\n                }\n                next.push({sol: s3, testedKeys: newTestedKeys});\n              }\n            },\n            ctx,\n            matchedKeys  // Collect matched keys\n          );\n        }\n      }\n      solutions = next;\n      continue;\n    }\n\n    // Handle OGroup (parenthesized O_BODY)\n    if (term.type === 'OGroup') {\n      // Process grouped terms - just flatten them into the main sequence\n      const next = [];\n      for (const state of solutions) {\n        matchObject(term.groups, null, obj, path, state.sol, (s2) => {\n          next.push({sol: s2, testedKeys: new Set(state.testedKeys)});\n        }, ctx);\n      }\n      solutions = next;\n      continue;\n    }\n\n    // Handle object lookaheads\n    if (term.type === 'OLook') {\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n\n        // Special case: (?!..) means \"no residual keys\" (closed object assertion)\n        // This is an optimization of the desugaring (?!((?!OT1)(?!OT2)...(?!OTn)_=_))\n        if (term.neg && term.pat.type === 'Spread') {\n          const residualKeys = Object.keys(obj).filter(k => !testedKeys.has(k));\n          const noResiduals = residualKeys.length === 0;\n          if (noResiduals) {\n            // No residual keys - negative lookahead succeeds\n            next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys)});\n          }\n          // If there are residuals, negative lookahead fails (don't push to next)\n        } else {\n          // General lookahead: try matching pattern\n          // Pass parent's testedKeys so .. inside lookahead knows which keys are residual\n          let matchedSol = null;\n          const lookaheadTestedKeys = new Set(testedKeys);\n          matchObjectGroup(term.pat, obj, path, cloneSolution(s0), (s2) => {\n            if (!matchedSol) matchedSol = s2;  // capture first successful match\n          }, ctx, lookaheadTestedKeys);\n\n          const matched = (matchedSol !== null);\n          if ((matched && !term.neg) || (!matched && term.neg)) {\n            // Positive lookahead: bindings escape (Prolog-style)\n            // Negative lookahead: no bindings escape\n            // In both cases, preserve tested keys from parent branch\n            // (lookahead tested keys don't affect parent)\n            next.push({\n              sol: matched ? matchedSol : cloneSolution(s0),\n              testedKeys: new Set(testedKeys)\n            });\n          }\n        }\n      }\n      solutions = next;\n      continue;\n    }\n\n    if (term.type !== 'OTerm') {\n      throw new Error(`Expected OTerm, GroupBind, OLook, or OGroup, got ${term.type}`);\n    }\n\n    // Handle K?:V desugaring: K?:V \u2192 (K:V | (?!K:_))\n    if (term.op === '?:') {\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n\n        // Special handling for RootKey with ?:\n        if (term.key.type === 'RootKey') {\n          // ..key?:val always matches (breadcrumb navigation handles existence)\n          const s1 = cloneSolution(s0);\n          navigateBreadcrumbs(\n            term.breadcrumbs,\n            obj,\n            path,\n            s1,\n            (finalNode, finalPath, s2) => {\n              matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n                next.push({sol: s3, testedKeys: new Set(testedKeys)});\n              }, ctx);\n            },\n            ctx\n          );\n          continue;\n        }\n\n        const keys = objectKeysMatching(obj, term.key, s0.env);\n\n        if (keys.length > 0) {\n          // First alternative: K=V (key exists, must match value)\n          for (const k of keys) {\n            const s1 = cloneSolution(s0);\n            const newTestedKeys = new Set(testedKeys);\n            newTestedKeys.add(k);\n\n            // Bind key variables (handle direct bindings and alternations)\n            if (!bindKeyVariables(term.key, k, s1, path)) {\n              continue;\n            }\n\n            navigateBreadcrumbs(\n              term.breadcrumbs,\n              obj[k],\n              [...path, k],\n              s1,\n              (finalNode, finalPath, s2) => {\n                matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n                  next.push({sol: s3, testedKeys: newTestedKeys});\n                }, ctx);\n              },\n              ctx\n            );\n          }\n        } else {\n          // Second alternative: (?!K=_) (key doesn't exist)\n          // This succeeds because no keys matched the pattern\n          next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys)});\n        }\n      }\n      solutions = next;\n      continue;\n    }\n\n    // For each solution, process all matching keys\n    let next = [];\n    for (const state of solutions) {\n      const {sol: s0, testedKeys} = state;\n\n      // Special handling for RootKey (leading .. in path like {..password:$x})\n      if (term.key.type === 'RootKey') {\n        // Start breadcrumb navigation from the object itself, not from a matched key\n        const s1 = cloneSolution(s0);\n        navigateBreadcrumbs(\n          term.breadcrumbs,\n          obj,\n          path,\n          s1,\n          (finalNode, finalPath, s2) => {\n            matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n              next.push({sol: s3, testedKeys: new Set(testedKeys)});\n            }, ctx);\n          },\n          ctx\n        );\n        continue;\n      }\n\n      // OPTIMIZATION: Compute keys for THIS solution's bindings\n      const keys = objectKeysMatching(obj, term.key, s0.env);\n      if (DEBUG) console.log(`[matchObject] term.key:`, term.key, `matched keys:`, keys);\n\n      // For ':' operator, require at least one key to match\n      if (term.op === ':' && keys.length === 0) {\n        continue; // Skip this solution\n      }\n\n      // Existential semantics: each matching key creates an independent solution branch\n      // (consistent with array semantics where [.. 5 ..] means \"exists a 5\")\n      for (const k of keys) {\n        if (DEBUG) console.log(`[matchObject] processing key '${k}', breadcrumbs:`, term.breadcrumbs?.length || 0);\n\n        const s1 = cloneSolution(s0);\n        // Track that this key was tested in this branch\n        const newTestedKeys = new Set(testedKeys);\n        newTestedKeys.add(k);\n\n        // Bind key variables (handle direct bindings and alternations)\n        if (!bindKeyVariables(term.key, k, s1, path)) {\n          continue; // Binding failed\n        }\n\n        // Navigate breadcrumbs from obj[k], then match value pattern\n        if (DEBUG) console.log(`[matchObject] obj[${k}]:`, obj[k]);\n        navigateBreadcrumbs(\n          term.breadcrumbs,\n          obj[k],\n          [...path, k],\n          s1,\n          (finalNode, finalPath, s2) => {\n            if (DEBUG) console.log(`[matchObject] reached final node:`, finalNode, `matching against:`, term.val);\n            matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n              if (DEBUG) console.log(`[matchObject] value matched!`);\n              next.push({sol: s3, testedKeys: newTestedKeys});\n            }, ctx);\n          },\n          ctx\n        );\n      }\n    }\n\n    solutions = next;\n    if (!solutions.length) break;\n  }\n\n  // Handle spread: bare 'remainder' or '@var=(remainder)' or '(?!remainder)'\n  if (spread && solutions.length > 0) {\n    if (spread.type === 'OLook') {\n      // (?!remainder) - assert no residual keys\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n\n        // Special case: (?!remainder) means \"no residual keys\" (closed object assertion)\n        if (spread.neg && spread.pat.type === 'Spread') {\n          const residualKeys = Object.keys(obj).filter(k => !testedKeys.has(k));\n          const noResiduals = residualKeys.length === 0;\n          if (noResiduals) {\n            // No residual keys - negative lookahead succeeds\n            next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys)});\n          }\n          // If there are residuals, negative lookahead fails (don't push to next)\n        } else {\n          // General lookahead on remainder (not yet fully implemented)\n          throw new Error('General lookahead on remainder not yet implemented');\n        }\n      }\n      solutions = next;\n    } else if (spread.type === 'GroupBind') {\n      // @var=(remainder) or @var=(remainder?) - bind residual keys to group variable\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n        const residualKeys = Object.keys(obj).filter(k => !testedKeys.has(k));\n\n        // Check quantifier constraints: bare remainder requires nonempty; remainder? allows empty and no upper bound\n        let {min, max} = parseQuantRange(spread.pat?.quant);\n        if (!spread.pat?.quant) {\n          // @var=(remainder) requires at least one key\n          min = 1;\n          max = Infinity;\n        } else if (spread.pat.quant === '?') {\n          // @var=(remainder?) allows empty remainder and unlimited keys\n          min = 0;\n          max = Infinity;\n        }\n        if (residualKeys.length < min || residualKeys.length > max) {\n          continue;\n        }\n\n        const residualObj = {};\n        for (const k of residualKeys) {\n          residualObj[k] = obj[k];\n        }\n\n        const s2 = cloneSolution(s0);\n        const groupValue = Group.object(residualObj);\n        if (bindGroup(s2.env, spread.name, groupValue)) {\n          if (!s2.sites.has(spread.name)) {\n            s2.sites.set(spread.name, []);\n          }\n          s2.sites.get(spread.name).push({\n            kind: 'group',\n            path: [...path],\n            keys: residualKeys,\n            valueRefs: residualObj\n          });\n          if (ctx.debug?.onBind) {\n            ctx.debug.onBind('group', spread.name, groupValue);\n          }\n          next.push({sol: s2, testedKeys});\n        }\n      }\n      solutions = next;\n    } else {\n      // Bare 'remainder' - just check count per branch\n      // Default for remainder is min:1 (requires nonempty), unlike array spread which defaults to min:0\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys} = state;\n        let {min, max} = parseQuantRange(spread.quant);\n        if (!spread.quant) min = 1;  // Bare 'remainder' requires nonempty\n        const untestedCount = Object.keys(obj).filter(k => !testedKeys.has(k)).length;\n        if (untestedCount >= min && (max === null || untestedCount <= max)) {\n          next.push(state);\n        }\n      }\n      solutions = next;\n    }\n  }\n\n  // Report matched keys to caller if requested (collect from all branches)\n  if (outMatchedKeys) {\n    for (const state of solutions) {\n      for (const k of state.testedKeys) {\n        outMatchedKeys.add(k);\n      }\n    }\n  }\n\n  for (const state of solutions) emit(state.sol);\n}\n\n/**\n * matchObjectGroup - Match a single O_GROUP pattern against an object\n * Used by lookaheads and other contexts where we need to match one group in isolation\n */\nfunction matchObjectGroup(group, obj, path, sol, emit, ctx, testedKeys = new Set()) {\n  guard(ctx);\n\n  // Handle different group types\n  if (group.type === 'OTerm') {\n    // Single object term K:V or K?:V\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'OGroup') {\n    // Group of groups (K1:V1 K2:V2 ...)\n    matchObject(group.groups, null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'GroupBind') {\n    // @var=(pattern)\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'OLook') {\n    // Nested lookahead\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'Spread') {\n    // Bare .. - match if there are residual keys\n    matchObject([], group, obj, path, sol, emit, ctx, testedKeys);\n  } else {\n    throw new Error(`Unexpected group type in matchObjectGroup: ${group.type}`);\n  }\n}\n\nfunction navigateBreadcrumbs(breadcrumbs, startNode, basePath, sol, emit, ctx) {\n  guard(ctx);\n\n  if (!breadcrumbs || breadcrumbs.length === 0) {\n    emit(startNode, basePath, sol);\n    return;\n  }\n\n  const bc = breadcrumbs[0];\n  const rest = breadcrumbs.slice(1);\n\n  // Navigate the breadcrumb (no quantifiers in v5)\n  navigateSingleBreadcrumb(bc, rest, startNode, basePath, sol, emit, ctx);\n}\n\nfunction navigateSingleBreadcrumb(bc, restBreadcrumbs, node, path, sol, emit, ctx) {\n  if (bc.kind === 'skip') {\n    // ..key navigation - skip any number of levels to find key\n    if (!isObject(node)) return;\n\n    navigateSkipLevels(bc.key, restBreadcrumbs, node, path, sol, emit, ctx);\n  } else if (bc.kind === 'dot') {\n    // .key navigation on objects\n    if (!isObject(node)) return;\n\n    // Special handling for $name binding in key position\n    if (bc.key.type === 'SBind') {\n      const keyPattern = bc.key.pat;\n      const fast = fastBoundKey(bc.key, sol.env, keyMatches, k => node.hasOwnProperty(k));\n\n      if (fast !== undefined) {\n        // Fast path: variable already bound, use its value\n        if (fast.length === 0) return; // Failed validation\n        const boundKey = fast[0];\n        navigateBreadcrumbs(restBreadcrumbs, node[boundKey], [...path, boundKey], sol, emit, ctx);\n        return;\n      }\n\n      // Not bound yet - enumerate all matching keys and try to bind\n      for (const k of Object.keys(node)) {\n        if (!keyMatches(keyPattern, k)) continue;\n        const s2 = cloneSolution(sol);\n        if (bindScalar(s2.env, bc.key.name, k)) {\n          recordScalarSite(s2, bc.key.name, path, k);\n          navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], s2, emit, ctx);\n        }\n      }\n    } else {\n      // Regular key pattern\n      const keys = objectKeysMatching(node, bc.key, sol.env);\n      for (const k of keys) {\n        navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], sol, emit, ctx);\n      }\n    }\n  } else if (bc.kind === 'bracket') {\n    // [key] navigation on arrays\n    if (!Array.isArray(node)) return;\n\n    // bc.key could be:\n    // - Lit (number): specific index\n    // - Any (_): any index\n    // - SBind ($x): bind index variable\n    // - Pattern: match index as string/number\n\n    if (bc.key.type === 'Lit') {\n      const idx = bc.key.value;\n      if (Number.isInteger(idx) && idx in node) {\n        navigateBreadcrumbs(restBreadcrumbs, node[idx], [...path, idx], sol, emit, ctx);\n      }\n    } else if (bc.key.type === 'Any') {\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], sol, emit, ctx);\n        }\n      }\n    } else if (bc.key.type === 'SBind') {\n      const idxPattern = bc.key.pat;\n      const fast = fastBoundKey(bc.key, sol.env, keyMatches, i => Number.isInteger(i) && i in node);\n\n      if (fast !== undefined) {\n        // Fast path: variable already bound, use its value\n        if (fast.length === 0) return; // Failed validation\n        const idx = fast[0];\n        navigateBreadcrumbs(restBreadcrumbs, node[idx], [...path, idx], sol, emit, ctx);\n        return;\n      }\n\n      // Not bound yet - enumerate indices and try to bind\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          const s2 = cloneSolution(sol);\n          if (bindScalar(s2.env, bc.key.name, i)) {\n            recordScalarSite(s2, bc.key.name, path, i);\n            navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], s2, emit, ctx);\n          }\n        }\n      }\n    } else {\n      // General pattern on index\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          matchItem(bc.key, i, path, sol, (s2) => {\n            navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], s2, emit, ctx);\n          }, ctx);\n        }\n      }\n    }\n  }\n}\n\nfunction navigateSkipLevels(keyPattern, restBreadcrumbs, node, path, sol, emit, ctx) {\n  // ..key navigation: recursively search through object tree to find matching keys at any depth\n  guard(ctx);\n\n  if (!isObject(node)) return;\n\n  // Try to match key at current level\n  // Handle $name binding in key position\n  if (keyPattern.type === 'SBind') {\n    const fast = fastBoundKey(keyPattern, sol.env, keyMatches, k => node.hasOwnProperty(k));\n\n    if (fast !== undefined) {\n      // Fast path: variable already bound, use its value\n      if (fast.length > 0) {\n        const boundKey = fast[0];\n        if (node.hasOwnProperty(boundKey)) {\n          navigateBreadcrumbs(restBreadcrumbs, node[boundKey], [...path, boundKey], sol, emit, ctx);\n        }\n      }\n    } else {\n      // Not bound yet - enumerate all matching keys and try to bind\n      const pattern = keyPattern.pat;\n      for (const k of Object.keys(node)) {\n        if (!keyMatches(pattern, k)) continue;\n        const s2 = cloneSolution(sol);\n        if (bindScalar(s2.env, keyPattern.name, k)) {\n          recordScalarSite(s2, keyPattern.name, path, k);\n          navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], s2, emit, ctx);\n        }\n      }\n    }\n  } else {\n    // Regular key pattern (no variable binding)\n    const keys = objectKeysMatching(node, keyPattern, sol.env);\n    for (const k of keys) {\n      navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], sol, emit, ctx);\n    }\n  }\n\n  // Recurse into nested objects to find key at deeper levels\n  for (const k of Object.keys(node)) {\n    const child = node[k];\n    if (isObject(child)) {\n      navigateSkipLevels(keyPattern, restBreadcrumbs, child, [...path, k], sol, emit, ctx);\n    }\n  }\n}\n\n// ------------- Helpers -------------\n\n/**\n * fastBoundKey(pat, env, validate, exists) -> undefined | [] | [key]\n *\n * If pat is SBind($name, inner) AND $name is already bound (scalar) AND\n * inner is not itself a binding, then:\n *   - if validate(inner, boundValue) fails, return [] (fast failure)\n *   - else if exists(boundValue) is true, return [boundValue] (fast success)\n *   - else return [] (not present)\n *\n * If no fast path applies, returns undefined to signal caller to fall back.\n *\n * This encodes the \"{ a=$x, $x=$y } \u21D2 second term O(1)\" idea once,\n * reused by object keys and array indices.\n */\nfunction fastBoundKey(pat, env, validate, exists) {\n  if (!pat || pat.type !== 'SBind') return undefined;\n  const binding = env.get(pat.name);\n  if (!binding || binding.kind !== 'scalar') return undefined;\n\n  // If inner pattern is itself a binding, we need normal binding logic\n  if (pat.pat && (pat.pat.type === 'SBind' || pat.pat.type === 'GroupBind')) {\n    return undefined;\n  }\n\n  const key = binding.value;\n  if (!validate(pat.pat, key)) return [];\n  return exists(key) ? [key] : [];\n}\n\nfunction objectKeysMatching(obj, keyPat, env) {\n  const fast = fastBoundKey(keyPat, env, keyMatches, k => obj.hasOwnProperty(k));\n  if (fast !== undefined) return fast;\n\n  // Fall back: enumerate all matching keys\n  const out = [];\n  for (const k of Object.keys(obj)) {\n    if (keyMatches(keyPat, k)) out.push(k);\n  }\n  return out;\n}\n\nfunction keyMatches(pat, key) {\n  switch (pat.type) {\n    case 'Any':\n      return true;\n    case 'Lit':\n      return Object.is(String(key), String(pat.value));\n    case 'Re':\n      return pat.re.test(String(key));\n    case 'SBind':\n      // Key pattern with binding: check inner pattern constraint\n      if (pat.pat) {\n        return keyMatches(pat.pat, key);\n      }\n      return true;  // $x with no constraint matches any key\n    case 'Alt':\n      // Alternation: key matches if any alternative matches\n      return pat.alts.some(alt => keyMatches(alt, key));\n    default:\n      return false;\n  }\n}\n\n// Bind variables from a key pattern (handles SBind and alternations)\n// Returns true if binding succeeded, false if it failed\nfunction bindKeyVariables(keyPat, key, sol, path) {\n  switch (keyPat.type) {\n    case 'SBind':\n      // Direct binding: $x or $x:(pattern)\n      if (!bindScalar(sol.env, keyPat.name, key)) {\n        return false;\n      }\n      recordScalarSite(sol, keyPat.name, path, key);\n      return true;\n\n    case 'Alt':\n      // Alternation: try each alternative, bind variables from the one that matches\n      for (const alt of keyPat.alts) {\n        if (keyMatches(alt, key)) {\n          // This alternative matches - bind any variables it contains\n          return bindKeyVariables(alt, key, sol, path);\n        }\n      }\n      return false; // No alternative matched\n\n    default:\n      // No variables to bind (Lit, Re, Any, etc.)\n      return true;\n  }\n}\n\nfunction isObject(x) {\n  return x !== null && typeof x === 'object' && !Array.isArray(x);\n}\n\nfunction parseQuantRange(quant) {\n  if (!quant) return {min: 0, max: Infinity};\n\n  // If quant is already an object with min/max (from parser), use it directly\n  if (typeof quant === 'object' && 'min' in quant && 'max' in quant) {\n    return {min: quant.min, max: quant.max === null ? Infinity : quant.max};\n  }\n\n  // quant could be: '?', '+', '*', '{m}', '{m,}', '{m,n}'\n  if (quant === '?') return {min: 0, max: 1};\n  if (quant === '+') return {min: 1, max: Infinity};\n  if (quant === '*') return {min: 0, max: Infinity};\n\n  // Lazy/possessive variants\n  if (quant === '??') return {min: 0, max: 1};\n  if (quant === '+?') return {min: 1, max: Infinity};\n  if (quant === '*?') return {min: 0, max: Infinity};\n  if (quant === '++') return {min: 1, max: Infinity};\n  if (quant === '*+') return {min: 0, max: Infinity};\n\n  // Range quantifiers: {m}, {m,}, {m,n}\n  const rangeMatch = quant.match(/^\\{(\\d+)(?:,(\\d+)?)?\\}$/);\n  if (rangeMatch) {\n    const m = parseInt(rangeMatch[1], 10);\n    const n = rangeMatch[2] !== undefined ? parseInt(rangeMatch[2], 10) : m;\n    return {min: m, max: n};\n  }\n\n  return {min: 0, max: Infinity};\n}\n\nfunction guard(ctx) {\n  ctx.steps++;\n  if (ctx.steps > ctx.maxSteps) throw new Error('pattern too ambiguous (step budget exceeded)');\n}\n", "// tendril-api.js \u2014 public API vNext (engine-compatible)\n//\n// NOTE:\n// - Group is kept for internal use and for tendril-engine.js.\n//   Users see plain arrays/objects for @-bindings.\n// - $0 (the automatic whole-match binding) is used internally for\n//   locating/replacing, but hidden from user-visible bindings.\n\nimport {parsePattern} from './tendril-parser.js';\nimport {match as engineMatch, scan as engineScan} from './tendril-engine.js';\nimport {deepEqual} from './tendril-util.js';\n\n// ------------------- Compile & cache -------------------\n\nconst CACHE_MAX = 64;\nconst _cache = new Map(); // pattern -> ast (LRU-ish)\n\nfunction compile(pattern) {\n  if (pattern && pattern.type) return pattern; // already compiled AST\n  if (_cache.has(pattern)) {\n    const hit = _cache.get(pattern);\n    _cache.delete(pattern);\n    _cache.set(pattern, hit);\n    return hit;\n  }\n  let ast = parsePattern(String(pattern));\n\n  // Wrap AST with $0 binding to capture entire match region\n  ast = {type: 'SBind', name: '0', pat: ast};\n\n  _cache.set(pattern, ast);\n  if (_cache.size > CACHE_MAX) {\n    const k = _cache.keys().next().value;\n    _cache.delete(k);\n  }\n  return ast;\n}\n\n// ------------------- Group class (internal representation) -------------------\n\n/**\n * Group \u2014 wrapper for group bindings and replacements\n * Represents a contiguous subsequence of an array or subset of object properties.\n *\n * This is used internally by the engine and replacement logic.\n * User-facing APIs never expose Group instances; they see plain arrays/objects.\n */\nexport class Group {\n  constructor(type, value) {\n    Object.defineProperty(this, '_type', {\n      value: type,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.defineProperty(this, '_value', {\n      value: value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n\n    if (type === 'array') {\n      value.forEach((v, i) => {\n        this[i] = v;\n      });\n      this.length = value.length;\n    } else if (type === 'object') {\n      Object.assign(this, value);\n    }\n  }\n\n  static array(...items) {\n    return new Group('array', items);\n  }\n\n  static object(obj) {\n    return new Group('object', obj);\n  }\n\n  [Symbol.iterator]() {\n    if (this._type !== 'array') {\n      throw new TypeError('Object-type Group is not iterable');\n    }\n    let i = 0;\n    const arr = this._value;\n    return {\n      next() {\n        return i < arr.length ? {value: arr[i++], done: false} : {done: true};\n      }\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return `Group(${this._type})`;\n  }\n\n  at(i) {\n    if (this._type === 'array') return this._value[i];\n    throw new TypeError('Not an array group');\n  }\n}\n\n// ------------------- Helper utilities -------------------\n\n// Deep clone JSON-like values (arrays/objects/primitives)\nfunction cloneDeep(v) {\n  if (Array.isArray(v)) {\n    return v.map(cloneDeep);\n  }\n  if (v && typeof v === 'object') {\n    const out = {};\n    for (const k of Object.keys(v)) {\n      out[k] = cloneDeep(v[k]);\n    }\n    return out;\n  }\n  return v;\n}\n\n// Convert internal Group values into plain arrays/objects for bindings\nfunction groupToPublicValue(v) {\n  // Duck-type check for Group (works across different Group class instances)\n  if (!v || typeof v !== 'object' || !v._type || !v._value) return v;\n  if (v._type === 'array') {\n    // New array to avoid aliasing; underlying _value is already an array\n    return v._value.slice ? v._value.slice() : [...v._value];\n  }\n  if (v._type === 'object') {\n    return {...v._value};\n  }\n  return v;\n}\n\n// Normalize bindings for user:\n// - Strip $0 (key \"0\")\n// - Convert Group values to plain arrays/objects\nfunction normalizeBindings(rawBindings, {includeWhole = false} = {}) {\n  const out = {};\n  for (const [k, v] of Object.entries(rawBindings)) {\n    if (k === '0' && !includeWhole) continue;\n    out[k] = groupToPublicValue(v);\n  }\n  return out;\n}\n\n// Helper: navigate path to get value\nfunction getAt(root, path) {\n  let current = root;\n  for (const key of path) {\n    current = current[key];\n  }\n  return current;\n}\n\n// Helper: navigate path and set value (mutates in-place)\nfunction setAtMutate(root, path, value) {\n  let current = root;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  current[path[path.length - 1]] = value;\n}\n\n// Helper: project bindings by selected vars ($-prefix supported)\nfunction projectBindings(b, vars) {\n  const out = {};\n  for (const v of vars) {\n    const key = v.startsWith('$') ? v.slice(1) : v;\n    if (Object.prototype.hasOwnProperty.call(b, key)) out[key] = b[key];\n  }\n  return out;\n}\n\n// Helper: stable key for deduplication across arbitrary JS structures\nfunction stableKey(v) {\n  const seen = new WeakMap();\n  let id = 0;\n  const enc = (x) => {\n    if (x === null) return ['null'];\n    const t = typeof x;\n    if (t === 'undefined') return ['u'];\n    if (t === 'number') return ['n', Number.isNaN(x) ? 'NaN' : String(x)];\n    if (t === 'boolean') return ['b', x ? '1' : '0'];\n    if (t === 'string') return ['s', x];\n    if (t === 'function') return ['f'];\n    if (t !== 'object') return ['o', String(x)];\n    if (seen.has(x)) return ['r', seen.get(x)];\n    seen.set(x, ++id);\n    if (Array.isArray(x)) return ['A', x.map(enc)];\n    const keys = Object.keys(x).sort();\n    return ['O', keys.map(k => [k, enc(x[k])])];\n  };\n  return JSON.stringify(enc(v));\n}\n\n// ------------------- Replacement implementation (mutating) -------------------\n\n/**\n * applyEdits mutates the given root in-place.\n * For pure operations, call it on a deep clone.\n */\nfunction applyEdits(root, edits) {\n  if (edits.length === 0) return root;\n\n  let result = root;\n\n  // Group edits by path\n  const editsByPath = new Map();\n  for (const edit of edits) {\n    const pathKey = JSON.stringify(edit.site.path);\n    if (!editsByPath.has(pathKey)) {\n      editsByPath.set(pathKey, []);\n    }\n    editsByPath.get(pathKey).push(edit);\n  }\n\n  // Apply edits per path\n  for (const [, pathEdits] of editsByPath) {\n    const sets = pathEdits.filter(e => e.site.kind === 'scalar');\n    const splices = pathEdits.filter(e => e.site.kind === 'group');\n\n    // Scalar replacements\n    for (const edit of sets) {\n      const current = getAt(result, edit.site.path);\n      if (deepEqual(current, edit.site.valueRef)) {\n        if (edit.site.path.length === 0) {\n          result = edit.to;\n        } else {\n          setAtMutate(result, edit.site.path, edit.to);\n        }\n      }\n    }\n\n    // Group (array/object) replacements\n    if (splices.length > 0) {\n      const arraySplices = splices.filter(e => e.site.groupStart !== undefined);\n      const objectSplices = splices.filter(e => e.site.keys !== undefined);\n\n      // Array group splices\n      if (arraySplices.length > 0) {\n        arraySplices.sort((a, b) => a.site.groupStart - b.site.groupStart);\n\n        let offset = 0;\n        for (const edit of arraySplices) {\n          const arr = getAt(result, edit.site.path);\n          if (!Array.isArray(arr)) continue;\n\n          const start = edit.site.groupStart + offset;\n          const end = edit.site.groupEnd + offset;\n\n          let allMatch = true;\n          for (let i = 0; i < edit.site.valueRefs.length; i++) {\n            if (!deepEqual(arr[start + i], edit.site.valueRefs[i])) {\n              allMatch = false;\n              break;\n            }\n          }\n\n          if (allMatch) {\n            if (!edit.to || !(edit.to instanceof Group) || edit.to._type !== 'array') {\n              throw new Error(\n                'Array group variable replacement must use Group.array() internally.'\n              );\n            }\n\n            const elements = edit.to._value;\n            const oldLength = end - start;\n            const newLength = elements.length;\n            arr.splice(start, oldLength, ...elements);\n            offset += (newLength - oldLength);\n          }\n        }\n      }\n\n      // Object group \"splices\"\n      for (const edit of objectSplices) {\n        const obj = getAt(result, edit.site.path);\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) continue;\n\n        let allMatch = true;\n        for (const key of edit.site.keys) {\n          if (!deepEqual(obj[key], edit.site.valueRefs[key])) {\n            allMatch = false;\n            break;\n          }\n        }\n\n        if (allMatch) {\n          if (!edit.to || !(edit.to instanceof Group) || edit.to._type !== 'object') {\n            throw new Error(\n              'Object group variable replacement must use Group.object() internally.'\n            );\n          }\n\n          const newProps = edit.to._value;\n          for (const key of edit.site.keys) {\n            delete obj[key];\n          }\n          Object.assign(obj, newProps);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// ------------------- Core data structures: Match, Solution, MatchSet -------------------\n\nclass Match {\n  constructor(root, path, rawSolutions, matchSet) {\n    this._root = root;\n    this._path = path;\n    this._rawSolutions = rawSolutions;\n    this._matchSet = matchSet;\n\n    // Precompute solutions for this match\n    this._solutions = rawSolutions.map(raw => new Solution(raw, this, matchSet));\n    // $0 site (first one) for replacements/editing\n    const zeroSites = rawSolutions[0]?.sites.get('0') || [];\n    this._zeroSite = zeroSites[0] || null;\n  }\n\n  path() {\n    return [...this._path];\n  }\n\n  value() {\n    if (!this._zeroSite) return undefined;\n    return getAt(this._root, this._zeroSite.path);\n  }\n\n  /**\n   * Iterator of Solution objects for this match.\n   */\n  solutions() {\n    const sols = this._solutions;\n    return {\n      [Symbol.iterator]() {\n        let i = 0;\n        return {\n          next() {\n            if (i >= sols.length) return {done: true};\n            return {value: sols[i++], done: false};\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * Pure replace: returns a NEW root with this match replaced.\n   * Uses first solution of this match.\n   */\n  replace(replOrFn) {\n    if (!this._zeroSite) return this._root;\n\n    const firstSol = this._solutions[0] || null;\n    const to = (typeof replOrFn === 'function')\n      ? replOrFn(firstSol)\n      : replOrFn;\n\n    const edits = [{site: this._zeroSite, to}];\n    const cloned = cloneDeep(this._root);\n    return applyEdits(cloned, edits);\n  }\n\n  /**\n   * Mutating edit: modifies variables in-place for this match.\n   *\n   * Forms:\n   *   edit(\"x\", $ => $.x * 2)\n   *   edit($ => ({ x: $.y, y: $.x }))\n   *   edit({ x: $ => $.y, y: $ => $.x })\n   */\n  edit(arg1, arg2) {\n    const {planFactory} = normalizeEditArgs(arg1, arg2);\n    const edits = [];\n\n    for (const sol of this._solutions) {\n      const plan = planFactory(sol) || {};\n      const sitesMap = sol._sites;\n\n      for (const [varNameRaw, valueSpec] of Object.entries(plan)) {\n        const varName = varNameRaw.startsWith('$')\n          ? varNameRaw.slice(1)\n          : varNameRaw;\n        const sites = sitesMap.get(varName) || [];\n\n        for (const site of sites) {\n          const to = convertValueForSite(site, valueSpec);\n          edits.push({site, to});\n        }\n      }\n    }\n\n    return applyEdits(this._root, edits);\n  }\n}\n\n/**\n * Solution: an object representing bindings, with a .matches() method.\n * - Binding names become properties on the instance (e.g. sol.x, sol.y).\n * - $0 is NOT exposed; use Match.value() for whole-match.\n */\nclass Solution {\n  constructor(rawSolution, match, matchSet) {\n    this._match = match;\n    this._matchSet = matchSet;\n    this._rawSolution = rawSolution;\n    this._sites = rawSolution.sites;\n\n    const publicBindings = normalizeBindings(rawSolution.bindings, {includeWhole: false});\n    this._bindings = publicBindings;\n\n    // Copy bindings as enumerable properties\n    for (const [k, v] of Object.entries(publicBindings)) {\n      this[k] = v;\n    }\n\n    // Non-enumerable helper to get plain object\n    Object.defineProperty(this, 'toObject', {\n      value: () => ({...this._bindings}),\n      enumerable: false\n    });\n  }\n\n  /**\n   * Iterator of Match objects with these bindings.\n   * Searches across all matches in the MatchSet for equivalent bindings.\n   */\n  matches() {\n    const myKey = stableKey(this._bindings);\n    const matchSet = this._matchSet;\n\n    return {\n      [Symbol.iterator]() {\n        const allMatches = [];\n\n        // Search all matches in matchSet for equivalent bindings\n        for (const m of matchSet) {\n          for (const s of m._solutions) {\n            if (stableKey(s._bindings) === myKey) {\n              allMatches.push(m);\n              break; // One solution per match is enough\n            }\n          }\n        }\n\n        let i = 0;\n        return {\n          next() {\n            if (i >= allMatches.length) return {done: true};\n            return {value: allMatches[i++], done: false};\n          }\n        };\n      }\n    };\n  }\n}\n\n/**\n * SolutionSet: iterable of unique Solution objects with combinators.\n */\nclass SolutionSet {\n  constructor(matchSet) {\n    this._matchSet = matchSet;\n  }\n\n  [Symbol.iterator]() {\n    const matches = this._matchSet._matches;\n    const seen = new Set();\n    let mi = 0;\n    let si = 0;\n    let currentMatch = matches[0] || null;\n\n    return {\n      next() {\n        while (true) {\n          if (!currentMatch) return {done: true};\n\n          if (si >= currentMatch._solutions.length) {\n            mi++;\n            if (mi >= matches.length) return {done: true};\n            currentMatch = matches[mi];\n            si = 0;\n            continue;\n          }\n\n          const sol = currentMatch._solutions[si++];\n          const key = stableKey(sol._bindings);\n          if (seen.has(key)) continue;\n          seen.add(key);\n          return {value: sol, done: false};\n        }\n      }\n    };\n  }\n\n  filter(pred) {\n    const filtered = [];\n    for (const sol of this) {\n      if (pred(sol)) filtered.push(sol);\n    }\n    return new FilteredSolutionSet(filtered);\n  }\n\n  take(n) {\n    const limited = [];\n    let count = 0;\n    for (const sol of this) {\n      if (count >= n) break;\n      limited.push(sol);\n      count++;\n    }\n    return new FilteredSolutionSet(limited);\n  }\n\n  first() {\n    const it = this[Symbol.iterator]();\n    const n = it.next();\n    return n.done ? null : n.value;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  count() {\n    let c = 0;\n    for (const _ of this) c++;\n    return c;\n  }\n}\n\n/**\n * FilteredSolutionSet: wrapper around pre-computed solutions array.\n */\nclass FilteredSolutionSet {\n  constructor(solutions) {\n    this._solutions = solutions;\n  }\n\n  [Symbol.iterator]() {\n    return this._solutions[Symbol.iterator]();\n  }\n\n  filter(pred) {\n    const filtered = this._solutions.filter(pred);\n    return new FilteredSolutionSet(filtered);\n  }\n\n  take(n) {\n    const limited = this._solutions.slice(0, n);\n    return new FilteredSolutionSet(limited);\n  }\n\n  first() {\n    return this._solutions[0] || null;\n  }\n\n  toArray() {\n    return [...this._solutions];\n  }\n\n  count() {\n    return this._solutions.length;\n  }\n}\n\n/**\n * MatchSet: iterable of Match objects, with transformation APIs.\n */\nclass MatchSet {\n  constructor(root, matchGroups) {\n    this._root = root;\n    // Each group: {path, rawSolutions}\n    this._matches = matchGroups.map(\n      g => new Match(root, g.path, g.rawSolutions, this)\n    );\n  }\n\n  // Iterable of Match\n  [Symbol.iterator]() {\n    return this._matches[Symbol.iterator]();\n  }\n\n  matches() {\n    return this;\n  }\n\n  hasMatch() {\n    return this._matches.length > 0;\n  }\n\n  /**\n   * Returns a SolutionSet of unique Solution objects across all matches.\n   * \"Uniqueness\" is based on structural equality of bindings.\n   */\n  solutions() {\n    return new SolutionSet(this);\n  }\n\n  /**\n   * Filter matches by predicate.\n   * Returns a new MatchSet containing only matches that satisfy the predicate.\n   */\n  filter(pred) {\n    const filtered = this._matches.filter(pred);\n    return new MatchSet(this._root,\n      filtered.map(m => ({path: m._path, rawSolutions: m._rawSolutions}))\n    );\n  }\n\n  /**\n   * Take first n matches.\n   * Returns a new MatchSet containing at most n matches.\n   */\n  take(n) {\n    const limited = this._matches.slice(0, n);\n    return new MatchSet(this._root,\n      limited.map(m => ({path: m._path, rawSolutions: m._rawSolutions}))\n    );\n  }\n\n  /**\n   * Get the first match, or null if none.\n   */\n  first() {\n    return this._matches[0] || null;\n  }\n\n  /**\n   * Count the number of matches.\n   */\n  count() {\n    return this._matches.length;\n  }\n\n  /**\n   * Convert matches to array.\n   */\n  toArray() {\n    return [...this._matches];\n  }\n\n  /**\n   * Pure replaceAll: returns a NEW root with replacements applied.\n   *\n   * Overloads:\n   *   replaceAll(value)               // replace each $0 with value\n   *   replaceAll(solution => value)   // value derived from first solution of each match\n   */\n  replaceAll(replOrFn) {\n    if (!this._matches.length) return this._root;\n\n    const edits = [];\n    for (const match of this._matches) {\n      if (!match._zeroSite) continue;\n      const firstSol = match._solutions[0] || null;\n      const to = (typeof replOrFn === 'function')\n        ? replOrFn(firstSol)\n        : replOrFn;\n      edits.push({site: match._zeroSite, to});\n    }\n\n    const cloned = cloneDeep(this._root);\n    return applyEdits(cloned, edits);\n  }\n\n  /**\n   * Mutating editAll.\n   *\n   * Forms:\n   *   editAll(\"x\", $ => $.x * 2)\n   *   editAll($ => ({ x: $.y, y: $.x }))\n   *   editAll({ x: $ => $.y, y: $ => $.x })\n   *\n   * Replacements apply to variable sites ($ and @),\n   * with @-bindings exposed as plain arrays/objects.\n   */\n  editAll(arg1, arg2) {\n    const {planFactory} = normalizeEditArgs(arg1, arg2);\n    const edits = [];\n\n    for (const match of this._matches) {\n      for (const sol of match._solutions) {\n        const plan = planFactory(sol) || {};\n        const sitesMap = sol._sites; // Map<varName, Site[]>\n\n        for (const [varNameRaw, valueSpec] of Object.entries(plan)) {\n          const varName = varNameRaw.startsWith('$')\n            ? varNameRaw.slice(1)\n            : varNameRaw;\n          const sites = sitesMap.get(varName) || [];\n          if (!sites.length) continue;\n\n          for (const site of sites) {\n            const to = convertValueForSite(site, valueSpec);\n            edits.push({site, to});\n          }\n        }\n      }\n    }\n\n    return applyEdits(this._root, edits);\n  }\n}\n\n// Normalize arguments for editAll\nfunction normalizeEditArgs(arg1, arg2) {\n  // editAll(\"x\", fn)\n  if (typeof arg1 === 'string' && typeof arg2 === 'function') {\n    const name = arg1;\n    const fn = arg2;\n    return {\n      planFactory: (sol) => ({[name]: fn(sol)})\n    };\n  }\n\n  // editAll(fn)  where fn: Solution => {varName: value}\n  if (typeof arg1 === 'function' && arg2 === undefined) {\n    const fn = arg1;\n    return {\n      planFactory: (sol) => fn(sol) || {}\n    };\n  }\n\n  // editAll(planObj) where planObj: {varName: valueOrFn}\n  if (arg1 && typeof arg1 === 'object' && arg2 === undefined) {\n    const template = arg1;\n    return {\n      planFactory: (sol) => {\n        const out = {};\n        for (const [k, v] of Object.entries(template)) {\n          out[k] = (typeof v === 'function') ? v(sol) : v;\n        }\n        return out;\n      }\n    };\n  }\n\n  throw new TypeError('editAll expects (\"var\", fn) | (fn) | (planObject)');\n}\n\n// Convert user-facing value to internal representation for a Site\nfunction convertValueForSite(site, value) {\n  // Scalar replacement: anything goes\n  if (site.kind === 'scalar') {\n    return value;\n  }\n\n  // Group replacement: need Group wrappers internally\n  const isArrayGroup = site.groupStart !== undefined;\n  const isObjectGroup = site.keys !== undefined;\n\n  if (isArrayGroup) {\n    if (value instanceof Group && value._type === 'array') {\n      return value;\n    }\n    if (Array.isArray(value)) {\n      return Group.array(...value);\n    }\n    // Single value -> single-element slice\n    return Group.array(value);\n  }\n\n  if (isObjectGroup) {\n    if (value instanceof Group && value._type === 'object') {\n      return value;\n    }\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      return Group.object(value);\n    }\n    throw new TypeError('Object group replacement expects a plain object or internal Group.object()');\n  }\n\n  // Fallback\n  return value;\n}\n\n// Group raw engine solutions by $0 path => match groups\nfunction groupByZeroPath(rawSolutions) {\n  const map = new Map(); // key -> {path, rawSolutions}\n  for (const sol of rawSolutions) {\n    const zeroSites = sol.sites.get('0') || [];\n    if (!zeroSites.length) continue;\n    const path = zeroSites[0].path || [];\n    const key = JSON.stringify(path);\n    let group = map.get(key);\n    if (!group) {\n      group = {path, rawSolutions: []};\n      map.set(key, group);\n    }\n    group.rawSolutions.push(sol);\n  }\n  return Array.from(map.values());\n}\n\n// ------------------- Pattern class (Tendril(pattern)) -------------------\n\nclass PatternImpl {\n  constructor(pattern) {\n    this._pattern = String(pattern);\n    this._ast = null;\n    this._opts = {};\n    this._debug = null;\n  }\n\n  withOptions(opts) {\n    const p = new PatternImpl(this._pattern);\n    p._ast = this._ast;\n    p._opts = {...this._opts, ...opts};\n    p._debug = this._debug;\n    return p;\n  }\n\n  debug(listener) {\n    const p = new PatternImpl(this._pattern);\n    p._ast = this._ast;\n    p._opts = this._opts;\n    p._debug = listener;\n    return p;\n  }\n\n  _getAst() {\n    if (!this._ast) {\n      this._ast = compile(this._pattern);\n    }\n    return this._ast;\n  }\n\n  _buildOpts() {\n    const opts = {...this._opts};\n    if (this._debug) opts.debug = this._debug;\n    return opts;\n  }\n\n  /**\n   * match(data): anchored match at the root.\n   * Returns a MatchSet (possibly empty; at most one distinct path: []).\n   */\n  match(input) {\n    const ast = this._getAst();\n    const rawSolutions = engineMatch(ast, input, this._buildOpts());\n    const groups = groupByZeroPath(rawSolutions);\n    return new MatchSet(input, groups);\n  }\n\n  /**\n   * find(data): scan for matches at any depth.\n   * Returns a MatchSet over all occurrences.\n   */\n  find(input) {\n    const ast = this._getAst();\n    const rawSolutions = engineScan(ast, input, this._buildOpts());\n    const groups = groupByZeroPath(rawSolutions);\n    return new MatchSet(input, groups);\n  }\n\n  /**\n   * first(data): convenience \u2014 MatchSet restricted to the first found match (if any).\n   */\n  first(input) {\n    const all = this.find(input);\n    if (!all._matches.length) return new MatchSet(input, []);\n    const firstGroup = [{\n      path: all._matches[0]._path,\n      rawSolutions: all._matches[0]._rawSolutions\n    }];\n    return new MatchSet(input, firstGroup);\n  }\n}\n\n// ------------------- Fluent factory -------------------\n\nexport function Tendril(pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError(\n      `Tendril(): pattern must be a string, got ${typeof pattern}`\n    );\n  }\n  return new PatternImpl(pattern);\n}\n\n// ------------------- Convenience functions -------------------\n\n// Helper: get first solution object (plain bindings) from an iterable of Solution\nfunction firstSolutionObject(solutionsIterable) {\n  const it = solutionsIterable[Symbol.iterator]();\n  const n = it.next();\n  if (n.done) return null;\n  return n.value.toObject();\n}\n\n// Filter out $0 from raw bindings (legacy helper)\nfunction filterBindings(bindings) {\n  const {0: _ignored, ...rest} = bindings;\n  return rest;\n}\n\n/**\n * Boolean \"does this match the whole data?\" helper (anchored).\n */\nexport function matches(pattern, input) {\n  const mset = Tendril(pattern).match(input);\n  return mset.hasMatch();\n}\n\n/**\n * Extract first solution (anchored), as a plain bindings object.\n */\nexport function extract(pattern, input) {\n  const mset = Tendril(pattern).match(input);\n  const solObj = firstSolutionObject(mset.solutions());\n  return solObj;\n}\n\n/**\n * Extract all unique solutions (anchored), as an array of bindings objects.\n */\nexport function extractAll(pattern, input) {\n  const mset = Tendril(pattern).match(input);\n  const out = [];\n  for (const sol of mset.solutions()) {\n    out.push(sol.toObject());\n  }\n  return out;\n}\n\n/**\n * Convenience replace: find first match and replace it.\n * Pure: returns a NEW root with replacement.\n *\n * builder:\n *   - value -> replaces the match with that value\n *   - function (Solution => value) -> replacement based on first solution\n */\nexport function replace(pattern, input, builder) {\n  return Tendril(pattern).first(input).replaceAll(builder);\n}\n\n/**\n * Convenience replaceAll: scan for occurrences and replace each $0.\n * Pure: returns a NEW root with replacements.\n *\n * builder:\n *   - value -> replaces each match with that value\n *   - function (Solution => value) -> per-match replacement based on first solution\n */\nexport function replaceAll(pattern, input, builder) {\n  return Tendril(pattern).find(input).replaceAll(builder);\n}\n\n/**\n * Unique matches by variable set, anchored.\n * Returns array of plain bindings objects.\n */\nexport function uniqueMatches(pattern, input, ...vars) {\n  const mset = Tendril(pattern).match(input);\n  const out = [];\n  const seen = new Set();\n\n  for (const sol of mset.solutions()) {\n    const projected = projectBindings(sol._bindings, vars);\n    const key = stableKey(projected);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(projected);\n  }\n\n  return out;\n}\n"],
  "mappings": "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",
  "names": ["q", "matched", "sol", "next", "match", "matches"]
}
