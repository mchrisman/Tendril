{
  "version": 3,
  "sources": ["../src/tendril-util.js", "../src/microparser.js", "../src/tendril-el.js", "../src/tendril-parser.js", "../src/tendril-engine.js", "../src/tendril-api.js"],
  "sourcesContent": ["// tendril-util.js \u2014 shared utility functions\n\n/**\n * SameValueZero equality (same semantics as Map/Set keys)\n * - NaN equals NaN (unlike ===)\n * - 0 equals -0 (like ===, unlike Object.is)\n */\nexport function sameValueZero(a, b) {\n  if (a === b) return true;\n  // Only remaining case where we want true: NaN === NaN\n  return Number.isNaN(a) && Number.isNaN(b);\n}\n\n/**\n * Deep equality check for structural comparison\n * Uses SameValueZero for primitive comparison\n */\nexport function deepEqual(a, b) {\n  if (a === b) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== 'object') return sameValueZero(a, b);\n\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  if (Array.isArray(b)) return false;\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n", "// microparser.js \u2014 minimal tokenizer + parser skeleton for Tendril\n// Focus: correctness & brevity; serves as the base for parser/engine.\n\nimport { deepEqual } from './tendril-util.js';\n\n// ---------- Tokenizer ----------\n\n/**\n * Token: { k, v, pos }\n *  - k: kind (e.g., 'id','num','str','re','any', or a symbol literal '.' '[' '..' '|' '{' etc.)\n *  - v: value (e.g., number, string, RegExp parts, symbol literal)\n *  - pos: source index where token starts (used for errors)\n */\nexport function tokenize(src) {\n  const toks = [];\n  let i = 0;\n\n  const push = (k, v, len) => { toks.push({ k, v, pos: i, len }); i += len; };\n  const reWS = /\\s+/y;\n  const reNum = /-?\\d+(\\.\\d+)?/y;\n  const reId  = /[A-Za-z_][A-Za-z0-9_]*/y;\n\n  while (i < src.length) {\n    // whitespace (incl. newlines)\n    reWS.lastIndex = i;\n    if (reWS.test(src)) { i = reWS.lastIndex; continue; }\n\n    const c = src[i], c2 = src.slice(i, i + 2), c3 = src.slice(i, i + 3);\n\n    // comments //... to end-of-line (optional but handy)\n    if (c2 === '//') {\n      let j = i + 2;\n      while (j < src.length && src[j] !== '\\n') j++;\n      i = j; continue;\n    }\n\n    // strings: \"...\" or '...' (with optional /i suffix for case-insensitive)\n    if (c === '\"' || c === \"'\") {\n      const q = c;\n      let j = i + 1, out = '';\n      while (j < src.length && src[j] !== q) {\n        if (src[j] === '\\\\') {\n          const { chr, adv } = readEsc(src, j + 1);\n          out += chr; j += adv + 1;\n        } else {\n          out += src[j++];\n        }\n      }\n      if (src[j] !== q) throw syntax(`unterminated string`, src, i);\n      const strEnd = j + 1;\n      // Check for /i suffix (case-insensitive string literal)\n      if (src.slice(strEnd, strEnd + 2) === '/i') {\n        push('ci', { lower: out.toLowerCase(), desc: src.slice(i, strEnd + 2) }, (strEnd + 2) - i);\n      } else {\n        push('str', out, strEnd - i);\n      }\n      continue;\n    }\n\n    // regex literal: /.../flags\n    // Division was removed from the expression language (see commit 41de539),\n    // so `/` is always a regex start (except `//` which is a comment)\n    if (c === '/' && src[i + 1] !== '/') {\n      // Single-pass scan: handle escapes and character classes\n      let j = i + 1, inClass = false;\n      while (j < src.length) {\n        const ch = src[j];\n        if (ch === '\\\\') {\n          j += 2; // skip escaped char\n        } else if (ch === '[') {\n          inClass = true;\n          j++;\n        } else if (ch === ']' && inClass) {\n          inClass = false;\n          j++;\n        } else if (ch === '/' && !inClass) {\n          break; // found terminator\n        } else {\n          j++;\n        }\n      }\n      if (j >= src.length) throw syntax(`unterminated regex literal`, src, i);\n\n      const pattern = src.slice(i + 1, j);\n      j++; // skip closing /\n\n      // Consume flags\n      const flagStart = j;\n      while (j < src.length && /[a-z]/i.test(src[j])) j++;\n      const flags = src.slice(flagStart, j);\n\n      // Validate the regex\n      try {\n        new RegExp(pattern, flags);\n      } catch (e) {\n        throw syntax(`invalid regex: /${pattern}/${flags}`, src, i);\n      }\n\n      // Disallow 'g' and 'y' flags - they cause stateful matching bugs\n      if (flags.includes('g') || flags.includes('y')) {\n        throw syntax(`Regex flags 'g' and 'y' are not allowed (found /${pattern}/${flags})`, src, i);\n      }\n\n      push('re', { source: pattern, flags: flags }, j - i);\n      continue;\n    }\n\n    // number\n    reNum.lastIndex = i;\n    if (reNum.test(src)) {\n      const j = reNum.lastIndex;\n      push('num', Number(src.slice(i, j)), j - i);\n      continue;\n    }\n\n    // identifier / keyword / ANY (with optional /i suffix for case-insensitive)\n    reId.lastIndex = i;\n    if (reId.test(src)) {\n      const j = reId.lastIndex;\n      const w = src.slice(i, j);\n      // Check for /i suffix FIRST - case-insensitive bareword takes precedence over keywords\n      if (src.slice(j, j + 2) === '/i') {\n        push('ci', { lower: w.toLowerCase(), desc: src.slice(i, j + 2) }, (j + 2) - i);\n        continue;\n      }\n      // Wildcards and typed wildcards (start with _, not valid identifiers)\n      if (w === '_')        { push('any', '_', j - i); continue; }\n      if (w === '_string')  { push('any_string', '_string', j - i); continue; }\n      if (w === '_number')  { push('any_number', '_number', j - i); continue; }\n      if (w === '_boolean') { push('any_boolean', '_boolean', j - i); continue; }\n      // Literals (not keywords \u2014 these are values)\n      if (w === 'true')     { push('bool', true, j - i); continue; }\n      if (w === 'false')    { push('bool', false, j - i); continue; }\n      if (w === 'null')     { push('null', null, j - i); continue; }\n      // Reject other underscore-prefixed identifiers\n      if (w[0] === '_') {\n        throw syntax(`identifiers cannot start with underscore: ${w}`, src, i);\n      }\n      // All other words are identifiers (keywords like 'else', 'as', 'where'\n      // are recognized by the parser in context, not by the tokenizer)\n      push('id', w, j - i);\n      continue;\n    }\n\n    // multi-character punctuation/operators (order matters - check longer tokens first!)\n    if (c2 === '(?') { push('(?', '(?', 2); continue; }   // positive lookahead\n    if (c2 === '(!') { push('(!', '(!', 2); continue; }   // negative lookahead\n    if (c3 === '...') { push('...', '...', 3); continue; }  // ellipsis (three dots)\n    if (c === '\u2026')    { push('...', '...', 1); continue; }  // ellipsis (Unicode U+2026)\n    if (c2 === '**')  { push('**', '**', 2); continue; }    // path skip (glob-style)\n    if (c2 === '->')  { push('->', '->', 2); continue; }   // flow operator (collect into bucket)\n    if (c2 === '??')  { push('??', '??', 2); continue; }   // lazy optional\n    if (c2 === '?+')  { push('?+', '?+', 2); continue; }   // possessive optional\n    if (c2 === '++')  { push('++', '++', 2); continue; }   // possessive plus\n    if (c2 === '*+')  { push('*+', '*+', 2); continue; }   // possessive star\n    if (c2 === '+?')  { push('+?', '+?', 2); continue; }   // lazy plus\n    if (c2 === '*?')  { push('*?', '*?', 2); continue; }   // lazy star\n    // Expression language operators (must check before single-char versions)\n    if (c2 === '<=')  { push('<=', '<=', 2); continue; }\n    if (c2 === '>=')  { push('>=', '>=', 2); continue; }\n    if (c2 === '==')  { push('==', '==', 2); continue; }\n    if (c2 === '!=')  { push('!=', '!=', 2); continue; }\n    if (c2 === '&&')  { push('&&', '&&', 2); continue; }\n    if (c2 === '||')  { push('||', '||', 2); continue; }\n\n    // one-character punctuation/operators\n    // \u00A7 (U+00A7) is for label declarations, ^ is for label references\n    // Note: / is NOT here - it's always a regex start (division was removed from EL)\n    const single = '()[]{}<>:,.$@=|*+?!-#%&\u00A7^'.includes(c) ? c : null;\n    if (single) { push(single, single, 1); continue; }\n\n    throw syntax(`unexpected character '${c}'`, src, i);\n  }\n  return toks;\n}\n\n// Escapes inside strings: \\n \\r \\t \\\" \\' \\\\ \\uXXXX \\u{...}\nfunction readEsc(s, i) {\n  const ch = s[i];\n  if (ch === 'n')  return { chr: '\\n', adv: 1 };\n  if (ch === 'r')  return { chr: '\\r', adv: 1 };\n  if (ch === 't')  return { chr: '\\t', adv: 1 };\n  if (ch === '\"' || ch === \"'\" || ch === '\\\\') return { chr: ch, adv: 1 };\n  if (ch === 'u') {\n    if (s[i + 1] === '{') {\n      let j = i + 2, hex = '';\n      while (j < s.length && s[j] !== '}') hex += s[j++];\n      if (s[j] !== '}') return { chr: 'u', adv: 1 }; // fallback\n      return { chr: String.fromCodePoint(parseInt(hex, 16) || 0), adv: (j + 1) - i };\n    } else {\n      const hex = s.slice(i + 1, i + 5);\n      return { chr: String.fromCharCode(parseInt(hex, 16) || 0), adv: 5 };\n    }\n  }\n  // default: identity (e.g., \\x => 'x')\n  return { chr: ch, adv: 1 };\n}\n\nfunction syntax(msg, src, pos) {\n  const caret = `${src}\\n${' '.repeat(pos)}^`;\n  const err = new Error(`${msg}\\n${caret}`);\n  err.pos = pos;\n  return err;\n}\n\n// ---------- Parser skeleton ----------\n\nexport class Parser {\n  constructor(src, tokens = tokenize(src), opts = {}) {\n    this.src = src;\n    this.toks = tokens;\n    this.i = 0;\n    this._cut = null;\n    // Debug hook object (mirrors tendril-engine's ctx.debug pattern)\n    // Methods: onEnter(label, idx), onExit(label, idx, success), onEat(tok, idx),\n    //          onBacktrack(label, startIdx, success), onFail(msg, idx, contextStack)\n    this.debug = opts.debug || null;\n    // Context stack for rule tracing\n    this.ctxStack = [];\n    // Enhanced farthest tracking\n    this.farthest = { i: 0, exp: new Set(), ctx: null, attempts: [] };\n  }\n\n  // --- cursor\n  atEnd() { return this.i >= this.toks.length; }\n  cur()   { return this.toks[this.i]; }\n\n  /**\n   * peek(...alts): if no args, returns current token or null.\n   * If args given, returns truthy if current token matches any by kind or value.\n   */\n  peek(...alts) {\n    const t = this.toks[this.i];\n    if (!t) return null;\n    if (!alts.length) return t;\n    for (const a of alts) if (t.k === a || t.v === a) return t;\n    return null;\n  }\n\n  // eat specific kind/value; when kind omitted, consumes current\n  eat(kind, msg) {\n    const t = this.toks[this.i];\n    if (!t) return this.fail(msg || `unexpected end of input`);\n    if (kind && !(t.k === kind || t.v === kind))\n      return this.fail(msg || `expected ${kind}`);\n    this.debug?.onEat?.(t, this.i);\n    this.i++;\n    return t;\n  }\n\n  maybe(kindOrVal) {\n    const t = this.toks[this.i];\n    if (t && (t.k === kindOrVal || t.v === kindOrVal)) { this.i++; return t; }\n    return null;\n  }\n\n  expect(...alts) {\n    const t = this.peek(...alts);\n    if (!t) this.fail(`expected ${alts.join('|')}`);\n    // prefer consuming by exact match for better messages\n    return this.eat(t.k);\n  }\n\n  // --- error control\n  cut() { this._cut = this.i; }              // commit to branch to localize errors\n  mark() { return { i: this.i, cut: this._cut }; }\n  restore(m) { this.i = m.i; this._cut = m.cut; }\n\n  fail(msg = 'syntax error') {\n    // record farthest error (for tooling, if desired)\n    if (this.i >= this.farthest.i) {\n      if (this.i > this.farthest.i) {\n        // New farthest position - reset tracking\n        this.farthest = { i: this.i, exp: new Set(), ctx: null, attempts: [] };\n      }\n      this.farthest.exp.add(msg);\n      this.farthest.ctx = [...this.ctxStack]; // snapshot context stack\n    }\n    this.debug?.onFail?.(msg, this.i, [...this.ctxStack]);\n    const pos = this.toks[this.i]?.pos ?? this.src.length;\n    throw syntax(msg, this.src, pos);\n  }\n\n  // ifPeek('{', parseobject)\n  // Peek first then try fn,\n  // return the output or null if it failed\n  ifPeek(next, fn) {\n     return this.peek(next)\n    ? this.backtrack(fn) : null\n  }\n  \n  // --- backtracking\n  // Restores parser state if fn() throws OR returns null/undefined.\n  // This makes \"soft failure\" (return null) safe by construction.\n  backtrack(fn) {\n    const save = this.mark();\n    try {\n      const result = fn();\n      if (result == null) {\n        this.restore(save);\n        return null;\n      }\n      return result;\n    }\n    catch (e) {\n      if (this._cut != null && save.i >= this._cut) throw e; // committed\n      this.restore(save);\n      return null;\n    }\n  }\n\n  // --- context tracking for debugging\n  // Wraps fn in a named context, tracking entry/exit for debug purposes\n  ctx(label, fn) {\n    this.ctxStack.push(label);\n    this.debug?.onEnter?.(label, this.i);\n    let success = false;\n    try {\n      const result = fn();\n      success = result != null;\n      return result;\n    } finally {\n      this.debug?.onExit?.(label, this.i, success);\n      this.ctxStack.pop();\n    }\n  }\n\n  // Labeled backtrack: like backtrack() but records the attempt for debugging\n  bt(label, fn) {\n    const startIdx = this.i;\n    this.ctxStack.push(label);\n    this.debug?.onEnter?.(label, startIdx);\n    const save = this.mark();\n    let success = false;\n    try {\n      const result = fn();\n      if (result == null) {\n        this.recordAttempt(label, startIdx, false);\n        this.restore(save);\n        return null;\n      }\n      success = true;\n      this.recordAttempt(label, startIdx, true);\n      return result;\n    } catch (e) {\n      if (this._cut != null && save.i >= this._cut) throw e;\n      this.recordAttempt(label, startIdx, false);\n      this.restore(save);\n      return null;\n    } finally {\n      this.debug?.onExit?.(label, this.i, success);\n      this.ctxStack.pop();\n    }\n  }\n\n  // Record a backtrack attempt at farthest position\n  // Uses startIdx (where attempt began) to attribute attempts correctly\n  recordAttempt(label, startIdx, success) {\n    this.debug?.onBacktrack?.(label, startIdx, success);\n    // Only record failed attempts that reached the farthest position\n    if (!success && startIdx >= this.farthest.i) {\n      if (startIdx > this.farthest.i) {\n        this.farthest.attempts = [];\n        this.farthest.i = startIdx;\n      }\n      // Avoid duplicates\n      if (!this.farthest.attempts.includes(label)) {\n        this.farthest.attempts.push(label);\n      }\n    }\n  }\n\n  // Wrap a parse function to capture source span on the returned AST node\n  span(fn) {\n    const startTok = this.toks[this.i];\n    const startIdx = this.i;\n    const result = fn();\n    if (result && typeof result === 'object') {\n      const endTok = this.toks[this.i - 1] || startTok;\n      result.loc = {\n        start: startTok?.pos ?? this.src.length,\n        end: (endTok?.pos ?? this.src.length) + (endTok?.len ?? 0),\n        startTok: startIdx,\n        endTok: this.i - 1\n      };\n    }\n    return result;\n  }\n\n  // Format a debug report from farthest failure info\n  formatReport() {\n    const f = this.farthest;\n    const pos = this.toks[f.i]?.pos ?? this.src.length;\n\n    // Line/column calculation\n    let line = 1, col = 1;\n    for (let i = 0; i < pos; i++) {\n      if (this.src[i] === '\\n') { line++; col = 1; }\n      else col++;\n    }\n\n    // Token window around failure (\u00B13 tokens)\n    const windowStart = Math.max(0, f.i - 3);\n    const windowEnd = Math.min(this.toks.length, f.i + 4);\n    const tokenWindow = this.toks.slice(windowStart, windowEnd).map((t, j) => {\n      const idx = windowStart + j;\n      const marker = idx === f.i ? '>>>' : '   ';\n      const val = typeof t.v === 'string' ? `\"${t.v}\"` : t.v;\n      return `${marker} [${idx}] ${t.k}: ${val}`;\n    }).join('\\n');\n\n    // Source snippet with caret\n    const lineStart = this.src.lastIndexOf('\\n', pos - 1) + 1;\n    const lineEnd = this.src.indexOf('\\n', pos);\n    const sourceLine = this.src.slice(lineStart, lineEnd === -1 ? undefined : lineEnd);\n    const caret = ' '.repeat(pos - lineStart) + '^';\n\n    const parts = [\n      `Parse error at line ${line}, column ${col}:`,\n      `  ${sourceLine}`,\n      `  ${caret}`,\n      '',\n      `Expected: ${[...f.exp].join(' | ')}`,\n    ];\n\n    if (f.ctx && f.ctx.length > 0) {\n      parts.push(`Context: ${f.ctx.join(' > ')}`);\n    }\n\n    if (f.attempts && f.attempts.length > 0) {\n      parts.push(`Tried: ${f.attempts.join(', ')}`);\n    }\n\n    parts.push('', 'Token window:', tokenWindow);\n\n    return parts.join('\\n');\n  }\n\n  many(parseOne) {\n    const out = [];\n    for (;;) {\n      const save = this.mark();\n      const node = this.backtrack(parseOne);\n      if (node == null) { this.restore(save); break; }\n      out.push(node);\n    }\n    return out;\n  }\n\n  until(parseOne, stopPred) {\n    const out = [];\n    while (!this.atEnd() && !stopPred()) out.push(parseOne());\n    return out;\n  }\n\n  // --- Pratt machinery (used for low-precedence '|')\n  parseExpr(spec, minPrec = 0) {\n    let lhs = spec.primary(this);\n    for (;;) {\n      const op = spec.peekOp(this);\n      if (!op) break;\n      const { prec, assoc, kind } = spec.info(op);\n      if (prec < minPrec) break;\n\n      if (kind === 'postfix') {\n        this.eat(op);\n        lhs = spec.buildPostfix(op, lhs);\n        continue;\n      }\n      // infix\n      this.eat(op);\n      const rhs = this.parseExpr(spec, assoc === 'right' ? prec : prec + 1);\n      lhs = spec.buildInfix(op, lhs, rhs);\n    }\n    return lhs;\n  }\n}\n\n// ---------- Debugger Implementations ----------\n\n/**\n * Creates a trace debugger that logs parsing activity to console.\n * Usage: parsePattern(src, { debug: createTraceDebugger() })\n *\n * Options:\n *   showTokens: boolean - log each token consumed (default: false)\n *   showFailures: boolean - log internal parse failures (default: false, very verbose)\n *   filter: (label) => boolean - only trace matching labels (default: all)\n */\nexport function createTraceDebugger(opts = {}) {\n  const { showTokens = false, showFailures = false, filter = null } = opts;\n  let depth = 0;\n\n  const indent = () => '  '.repeat(depth);\n  const shouldTrace = (label) => !filter || filter(label);\n\n  return {\n    onEnter(label, idx) {\n      if (shouldTrace(label)) {\n        console.log(`${indent()}\u2192 ${label} @${idx}`);\n        depth++;\n      }\n    },\n    onExit(label, idx, success) {\n      if (shouldTrace(label)) {\n        depth = Math.max(0, depth - 1);\n        console.log(`${indent()}${success ? '\u2713' : '\u2717'} ${label} @${idx}`);\n      }\n    },\n    onEat(tok, idx) {\n      if (showTokens) {\n        const val = typeof tok.v === 'string' ? `\"${tok.v}\"` : tok.v;\n        console.log(`${indent()}  \u2190 ${tok.k}: ${val}`);\n      }\n    },\n    onBacktrack(label, startIdx, success) {\n      // Covered by onExit\n    },\n    onFail(msg, idx, contextStack) {\n      if (showFailures) {\n        console.log(`${indent()}  \u2717 ${msg} @${idx}`);\n      }\n    }\n  };\n}\n\n/**\n * Creates a report debugger that silently collects parsing data.\n * Call getReport() after parsing to get a summary.\n * Usage:\n *   const dbg = createReportDebugger();\n *   try { parsePattern(src, { debug: dbg }); } catch(e) {}\n *   console.log(dbg.getReport());\n */\nexport function createReportDebugger() {\n  const attempts = new Map();  // idx -> {label -> count}\n  const failures = [];         // [{msg, idx, context}]\n  let maxDepth = 0;\n  let currentDepth = 0;\n  let tokenCount = 0;\n  let farthestIdx = 0;\n  let farthestContext = [];\n\n  return {\n    onEnter(label, idx) {\n      currentDepth++;\n      maxDepth = Math.max(maxDepth, currentDepth);\n    },\n    onExit(label, idx, success) {\n      currentDepth = Math.max(0, currentDepth - 1);\n      if (!success) {\n        if (!attempts.has(idx)) attempts.set(idx, new Map());\n        const atIdx = attempts.get(idx);\n        atIdx.set(label, (atIdx.get(label) || 0) + 1);\n      }\n    },\n    onEat(tok, idx) {\n      tokenCount++;\n    },\n    onBacktrack(label, startIdx, success) {\n      // Tracked via onExit\n    },\n    onFail(msg, idx, contextStack) {\n      failures.push({ msg, idx, context: [...contextStack] });\n      if (idx >= farthestIdx) {\n        farthestIdx = idx;\n        farthestContext = [...contextStack];\n      }\n    },\n\n    // Analysis methods\n    getReport() {\n      const lines = [\n        `Tokens consumed: ${tokenCount}`,\n        `Max parse depth: ${maxDepth}`,\n        `Farthest position: ${farthestIdx}`,\n      ];\n\n      if (farthestContext.length) {\n        lines.push(`Farthest context: ${farthestContext.join(' > ')}`);\n      }\n\n      // Most-tried positions (backtracking hotspots)\n      const hotspots = [...attempts.entries()]\n        .map(([idx, labels]) => ({\n          idx,\n          total: [...labels.values()].reduce((a, b) => a + b, 0),\n          labels: [...labels.entries()].sort((a, b) => b[1] - a[1])\n        }))\n        .sort((a, b) => b.total - a.total)\n        .slice(0, 5);\n\n      if (hotspots.length) {\n        lines.push('', 'Backtracking hotspots:');\n        for (const h of hotspots) {\n          const top3 = h.labels.slice(0, 3).map(([l, c]) => `${l}:${c}`).join(', ');\n          lines.push(`  @${h.idx}: ${h.total} attempts (${top3})`);\n        }\n      }\n\n      if (failures.length) {\n        lines.push('', `Total failures: ${failures.length}`);\n        const lastFew = failures.slice(-3);\n        for (const f of lastFew) {\n          lines.push(`  @${f.idx}: ${f.msg}`);\n        }\n      }\n\n      return lines.join('\\n');\n    },\n\n    // Raw data access\n    getData() {\n      return { attempts, failures, maxDepth, tokenCount, farthestIdx, farthestContext };\n    }\n  };\n}\n\n// ---------- Binding helpers (shared across engine/parser) ----------\n\n/**\n * env: Map<string, {kind:'scalar'|'group', value:any}>\n * We keep it simple and explicit; engine will ensure no accidental mutation.\n */\nexport function cloneEnv(env) {\n  const e = new Map();\n  for (const [k, v] of env) e.set(k, v);\n  return e;\n}\n\nexport function isBound(env, name) {\n  return env.has(name);\n}\n\nexport function bindScalar(env, name, val) {\n  const cur = env.get(name);\n  if (!cur) { env.set(name, { kind: 'scalar', value: val }); return true; }\n  return cur.kind === 'scalar' && deepEqual(cur.value, val);\n}\n\nexport function bindGroup(env, name, group) {\n  const cur = env.get(name);\n  if (!cur) { env.set(name, { kind: 'group', value: group }); return true; }\n  if (cur.kind !== 'group') return false; // Never group<->scalar\n  // Unify groups using structural equality\n  return deepEqual(cur.value, group);\n}\n\n// Utilities to build real RegExp at parse-time when convenient\nexport function makeRegExp(spec) {\n  // spec: { source, flags }\n  try { return new RegExp(spec.source, spec.flags || ''); }\n  catch (e) { throw new Error(`invalid regex: /${spec.source}/${spec.flags||''}`); }\n}\n\n// Pretty location (optional; parse errors already caret-print)\nexport function where(p) {\n  const t = p.cur();\n  const pos = t ? t.pos : p.src.length;\n  return { pos };\n}\n", "// tendril-el.js \u2014 Expression Language for guard expressions\n//\n// Syntax: (PATTERN where $x > 100)\n//\n// Operators: < > <= >= == != && || ! + - * %\n// Note: Division (/) excluded due to regex ambiguity; will be revisited (td-0012).\n// Functions: number($x), string($x), boolean($x), size($x)\n//\n// Uses SameValueZero for equality comparisons.\n\nimport { sameValueZero } from './tendril-util.js';\n\n// ==================== Expression AST ====================\n\nconst ELit = (value) => ({type: 'ELit', value});\nconst EVar = (name) => ({type: 'EVar', name});\nconst EUnary = (op, arg) => ({type: 'EUnary', op, arg});\nconst EBinary = (op, left, right) => ({type: 'EBinary', op, left, right});\nconst ECall = (fn, args) => ({type: 'ECall', fn, args});\n\n// ==================== Expression Parser ====================\n\n// Built-in function names recognized in expressions\nconst EL_FUNCTIONS = ['number', 'string', 'boolean', 'size'];\n\n// Operator precedence (higher = binds tighter)\nconst PRECEDENCE = {\n  '||': 1,\n  '&&': 2,\n  '==': 3, '!=': 3,\n  '<': 4, '>': 4, '<=': 4, '>=': 4,\n  '+': 5, '-': 5,\n  '*': 6, '%': 6,\n};\n\n/**\n * Parse an expression from the shared token stream.\n * @param {Parser} p - Parser instance (from microparser.js)\n * @returns {Object} Expression AST\n */\nexport function parseExpr(p) {\n  // Primary: literals, variables, function calls, parenthesized expressions\n  function parsePrimary() {\n    const tok = p.peek();\n    if (!tok) p.fail('unexpected end of expression');\n\n    // Unary not\n    if (tok.k === '!') {\n      p.eat('!');\n      return EUnary('!', parsePrimary());\n    }\n\n    // Unary minus (at start of primary, so it's unary not binary)\n    if (tok.k === '-') {\n      p.eat('-');\n      return EUnary('-', parsePrimary());\n    }\n\n    // Parenthesized expression\n    if (p.maybe('(')) {\n      const expr = parseExpression(0);\n      p.eat(')');\n      return expr;\n    }\n\n    // Number literal\n    if (p.peek('num')) {\n      return ELit(p.eat('num').v);\n    }\n\n    // Boolean literal\n    if (p.peek('bool')) {\n      return ELit(p.eat('bool').v);\n    }\n\n    // Null literal\n    if (p.peek('null')) {\n      p.eat('null');\n      return ELit(null);\n    }\n\n    // String literal\n    if (p.peek('str')) {\n      return ELit(p.eat('str').v);\n    }\n\n    // Anonymous variable _ (tokenized as 'any')\n    if (p.peek('any')) {\n      p.eat('any');\n      return EVar('_');\n    }\n\n    // Variable reference ($name)\n    if (p.maybe('$')) {\n      const t = p.peek('id');\n      if (!t) p.fail('expected variable name after $');\n      p.eat('id');\n      return EVar(t.v);\n    }\n\n    // Function call or bareword - check for identifier\n    if (p.peek('id')) {\n      const name = p.cur().v;\n\n      // Check if it's a known function followed by '('\n      if (EL_FUNCTIONS.includes(name)) {\n        p.eat('id');\n        p.eat('(');\n        const args = [];\n        if (!p.peek(')')) {\n          args.push(parseExpression(0));\n          while (p.maybe(',')) {\n            args.push(parseExpression(0));\n          }\n        }\n        p.eat(')');\n        return ECall(name, args);\n      }\n\n      // Unknown identifier in expression context - error\n      p.fail(`unexpected identifier '${name}' in expression (variables must be prefixed with $)`);\n    }\n\n    p.fail(`unexpected token in expression: '${tok.v || tok.k}'`);\n  }\n\n  // Pratt parser for binary operators\n  function parseExpression(minPrec) {\n    let left = parsePrimary();\n\n    while (true) {\n      const t = p.peek();\n      if (!t) break;\n\n      const prec = PRECEDENCE[t.k];\n      if (prec === undefined || prec < minPrec) break;\n\n      const op = p.eat().k;\n      const right = parseExpression(prec + 1); // left-associative\n      left = EBinary(op, left, right);\n    }\n\n    return left;\n  }\n\n  return parseExpression(0);\n}\n\n// ==================== Expression Evaluator ====================\n\nexport function evaluateExpr(ast, bindings) {\n  // bindings: Map<string, value> or object with variable values\n\n  function getVar(name) {\n    if (bindings instanceof Map) {\n      if (!bindings.has(name)) {\n        throw new Error(`Unbound variable in guard: $${name}`);\n      }\n      const entry = bindings.get(name);\n      return entry.kind === 'scalar' ? entry.value : entry.value;\n    }\n    if (!(name in bindings)) {\n      throw new Error(`Unbound variable in guard: $${name}`);\n    }\n    return bindings[name];\n  }\n\n  function evaluate(node) {\n    switch (node.type) {\n      case 'ELit':\n        return node.value;\n\n      case 'EVar':\n        return getVar(node.name);\n\n      case 'EUnary':\n        const arg = evaluate(node.arg);\n        switch (node.op) {\n          case '!': return !arg;\n          case '-': return -arg;\n          default: throw new Error(`Unknown unary operator: ${node.op}`);\n        }\n\n      case 'EBinary': {\n        // Short-circuit evaluation for && and ||\n        if (node.op === '&&') {\n          const left = evaluate(node.left);\n          if (!left) return false;\n          return !!evaluate(node.right);\n        }\n        if (node.op === '||') {\n          const left = evaluate(node.left);\n          if (left) return true;\n          return !!evaluate(node.right);\n        }\n\n        const left = evaluate(node.left);\n        const right = evaluate(node.right);\n\n        switch (node.op) {\n          case '+':\n            // String concatenation or numeric addition\n            if (typeof left === 'string' && typeof right === 'string') {\n              return left + right;\n            }\n            if (typeof left !== 'number' || typeof right !== 'number') {\n              throw new Error(`Cannot add ${typeof left} and ${typeof right}`);\n            }\n            return left + right;\n          case '-':\n            if (typeof left !== 'number' || typeof right !== 'number') {\n              throw new Error(`Cannot subtract ${typeof left} and ${typeof right}`);\n            }\n            return left - right;\n          case '*':\n            if (typeof left !== 'number' || typeof right !== 'number') {\n              throw new Error(`Cannot multiply ${typeof left} and ${typeof right}`);\n            }\n            return left * right;\n          case '%':\n            if (typeof left !== 'number' || typeof right !== 'number') {\n              throw new Error(`Cannot modulo ${typeof left} and ${typeof right}`);\n            }\n            if (right === 0) {\n              throw new Error(`Modulo by zero`);\n            }\n            return left % right;\n          case '<': return left < right;\n          case '>': return left > right;\n          case '<=': return left <= right;\n          case '>=': return left >= right;\n          case '==': return sameValueZero(left, right);\n          case '!=': return !sameValueZero(left, right);\n          default: throw new Error(`Unknown binary operator: ${node.op}`);\n        }\n      }\n\n      case 'ECall': {\n        const args = node.args.map(evaluate);\n        switch (node.fn) {\n          case 'number':\n            if (args.length !== 1) throw new Error(`number() takes 1 argument`);\n            const n = Number(args[0]);\n            if (Number.isNaN(n) && typeof args[0] !== 'number') {\n              throw new Error(`Cannot convert ${typeof args[0]} to number`);\n            }\n            return n;\n          case 'string':\n            if (args.length !== 1) throw new Error(`string() takes 1 argument`);\n            return String(args[0]);\n          case 'boolean':\n            if (args.length !== 1) throw new Error(`boolean() takes 1 argument`);\n            return Boolean(args[0]);\n          case 'size':\n            if (args.length !== 1) throw new Error(`size() takes 1 argument`);\n            const val = args[0];\n            if (typeof val === 'string') return val.length;\n            if (Array.isArray(val)) return val.length;\n            if (val && typeof val === 'object') return Object.keys(val).length;\n            throw new Error(`size() requires string, array, or object`);\n          default:\n            throw new Error(`Unknown function: ${node.fn}`);\n        }\n      }\n\n      default:\n        throw new Error(`Unknown expression node type: ${node.type}`);\n    }\n  }\n\n  return evaluate(ast);\n}\n\n// ==================== Guard Helpers ====================\n\n// Extract all variable names referenced in an expression\nexport function getExprVariables(ast) {\n  const vars = new Set();\n\n  function walk(node) {\n    switch (node.type) {\n      case 'EVar':\n        vars.add(node.name);\n        break;\n      case 'EUnary':\n        walk(node.arg);\n        break;\n      case 'EBinary':\n        walk(node.left);\n        walk(node.right);\n        break;\n      case 'ECall':\n        node.args.forEach(walk);\n        break;\n    }\n  }\n\n  walk(ast);\n  return vars;\n}\n\n// Check if all required variables are bound\nexport function isGuardClosed(ast, boundVars) {\n  const required = getExprVariables(ast);\n  for (const v of required) {\n    if (!boundVars.has(v)) return false;\n  }\n  return true;\n}\n", "// tendril-parser.js \u2014 v5-A compliant parser\n// Implements the v5-A grammar from README-v5-A.md exactly.\n//\n// Grammar structure:\n//   ROOT_PATTERN := ITEM\n//   ITEM := atoms, bindings, objects, arrays, alternations\n//   A_GROUP := array group patterns (with quantifiers, @x, $x)\n//   O_GROUP := object group patterns (with breadcrumbs, @x)\n//\n// AST Node Types:\n//   Atoms: Any, Lit, Re, Bool, Null\n//   Containers: Arr, Obj\n//   Bindings: SBind (scalar $x), GroupBind (group @x)\n//   Operators: Alt, Look, Quant\n//   Object: OTerm (with breadcrumbs), Spread (...)\n//   Breadcrumbs: Breadcrumb (no quantifiers in v5)\n\nimport {Parser, makeRegExp} from './microparser.js';\nimport {parseExpr} from './tendril-el.js';\n\n// ---------- Public API ----------\n\nexport function parsePattern(src, opts = {}) {\n  const p = new Parser(src, undefined, opts);\n  try {\n    const ast = parseRootPattern(p);\n    if (!p.atEnd()) p.fail('trailing input after pattern');\n    validateAST(ast, src);\n    return ast;\n  } catch (e) {\n    // Attach debug report to error for better diagnostics\n    if (p.farthest) {\n      e.parseReport = p.formatReport();\n    }\n    throw e;\n  }\n}\n\n// ---------- AST Node Constructors ----------\n\n// Atoms\nconst Any = () => ({type: 'Any'});\nconst TypedAny = (kind) => ({type: 'TypedAny', kind}); // _string, _number, _boolean\nconst Lit = (v) => ({type: 'Lit', value: v});\nconst StringPattern = (kind, desc, matchFn) => ({type: 'StringPattern', kind, desc, matchFn});\nconst Bool = (v) => ({type: 'Bool', value: v});\nconst Null = () => ({type: 'Null'});\nconst Fail = () => ({type: 'Fail'}); // Always fails - used for 'else !' strong semantics\nconst RootKey = () => ({type: 'RootKey'}); // Special marker for leading ** in paths\nconst Guarded = (pat, guard) => ({type: 'Guarded', pat, guard}); // (PATTERN where EXPR) without binding\n\n// Bindings\nconst SBind = (name, pat, guard = null) => ({type: 'SBind', name, pat, guard});  // (pat as $x) or (pat as $x where expr)\nconst GroupBind = (name, pat, sliceKind = 'array') => ({type: 'GroupBind', name, pat, sliceKind});  // (pat as @x) for array, (pat as %x) for object\nconst Flow = (pat, bucket, labelRef = null, sliceKind = 'object') => ({type: 'Flow', pat, bucket, labelRef, sliceKind});  // ->%bucket (k:v pairs) or ->@bucket (values only)\n// <collecting $k:$v in %bucket across ^L> or <collecting $v in @bucket across ^L>\nconst Collecting = (pat, collectExpr, bucket, sliceKind, labelRef) => ({\n  type: 'Collecting',\n  pat,           // the pattern this directive is attached to\n  collectExpr,   // {key: varName, value: varName} for k:v or {value: varName} for value-only\n  bucket,        // bucket name\n  sliceKind,     // 'object' or 'array'\n  labelRef       // required label reference\n});\n\n// Containers\nconst Arr = (items, label = null) => ({type: 'Arr', items, label});\nconst Obj = (terms, spread = null, label = null) => ({type: 'Obj', terms, spread, label});\n\n// Operators\n// Alt: alternation. prioritized=false means enumerate all (|), prioritized=true means first-match-wins (else)\nconst Alt = (alts, prioritized = false) => ({type: 'Alt', alts, prioritized});\nconst Look = (neg, pat) => ({type: 'Look', neg, pat});\nconst Quant = (sub, op, min = null, max = null) => ({\n  type: 'Quant',\n  sub,\n  op,  // '?', '??', '+', '++', '+?', '*', '*+', '*?', '*{...}'\n  min,\n  max\n});\n\n// Object terms\nconst OTerm = (key, breadcrumbs, val, quant, optional = false, strong = false) => ({\n  type: 'OTerm',\n  key,           // ITEM\n  breadcrumbs,   // Breadcrumb[]\n  val,           // ITEM\n  quant,         // null or {min, max}\n  optional,      // true if '?' suffix (K:V?)\n  strong         // true if 'else !' suffix - triggers strong semantics (no bad entries)\n});\n\nconst Spread = (quant) => ({type: 'Spread', quant});  // ... with optional #{...}\n\n// Slice patterns at root level: %{ O_GROUP } (object) or @[ A_BODY ] (array)\nconst SlicePattern = (kind, content) => ({type: 'SlicePattern', kind, content});\n\nconst Breadcrumb = (kind, key, quant) => ({\n  type: 'Breadcrumb',\n  kind,   // 'dot' or 'bracket'\n  key,    // ITEM\n  quant   // null or {op: '?'|'+'|'*', min, max}\n});\n\n// Helper: eat a variable name (any identifier, including keywords like 'else')\n// This allows $else, @else, $where, $as etc. as valid variable names\nfunction eatVarName(p) {\n  const t = p.peek('id');\n  if (t) {\n    p.eat('id');\n    return t.v;\n  }\n  p.fail('expected variable name');\n}\n\n// ---------- Suffix Combinators ----------\n// These factor out the repeated (INNER as $x where EXPR) pattern\n\n/**\n * Parse a parenthesized expression with optional binding and guard.\n * Handles: (INNER), (INNER as $x), (INNER as $x where EXPR), (INNER as @x), (INNER where EXPR)\n * @param {Parser} p - Parser instance\n * @param {Function} parseInner - Function to parse the inner content (returns AST node)\n * @param {Array<string>} stopTokens - Tokens that signal end of inner (besides 'as', 'where', ')')\n * @returns {Object|null} - AST node (SBind, GroupBind, Guarded, or plain inner), or null if no '('\n */\nfunction parseParenWithBindingAndGuard(p, parseInner, stopTokens = []) {\n  if (!p.maybe('(')) return null;\n\n  const inner = parseInner(p, [')', 'as', 'where', ...stopTokens]);\n\n  // Check for 'as $x' or 'as @x' binding suffix\n  if (p.maybe('as')) {\n    if (p.peek('$')) {\n      p.eat('$');\n      const name = eatVarName(p);\n      let guard = null;\n      if (p.maybe('where')) {\n        guard = parseExpr(p);\n      }\n      p.eat(')');\n      return SBind(name, inner, guard);\n    }\n    if (p.peek('@')) {\n      p.eat('@');\n      const name = eatVarName(p);\n      if (p.peek('where')) {\n        p.fail('guard expressions are not supported on group bindings (@var)');\n      }\n      p.eat(')');\n      return GroupBind(name, inner);\n    }\n    p.fail('expected $var or @var after \"as\"');\n  }\n\n  // Check for 'where EXPR' guard without binding (creates Guarded node)\n  if (p.maybe('where')) {\n    const guard = parseExpr(p);\n    p.eat(')');\n    return Guarded(inner, guard);\n  }\n\n  p.eat(')');\n  return inner;\n}\n\n/**\n * Parse optional flow suffix: '->' ('@'|'%') IDENT ('<^' IDENT '>')?\n * - ->%bucket collects key:value pairs (object slice)\n * - ->@bucket collects values only (array slice)\n * @param {Parser} p - Parser instance\n * @param {Object} node - The node to potentially wrap in a Flow\n * @returns {Object} - Original node or Flow-wrapped node\n */\nfunction withOptionalFlow(p, node) {\n  if (!p.peek('->')) return node;\n\n  // Wrap in span to capture source location for validation error messages\n  return p.span(() => {\n    p.eat('->');\n\n    // Determine slice kind: % for object (k:v pairs), @ for array (values only)\n    let sliceKind;\n    if (p.peek('%')) {\n      p.eat('%');\n      sliceKind = 'object';\n    } else {\n      p.eat('@');\n      sliceKind = 'array';\n    }\n\n    const bucket = eatVarName(p);\n\n    // Check for optional <^label> suffix\n    let labelRef = null;\n    if (p.peek('<')) {\n      p.eat('<');\n      p.eat('^');\n      labelRef = eatVarName(p);\n      p.eat('>');\n    }\n\n    return Flow(node, bucket, labelRef, sliceKind);\n  });\n}\n\n/**\n * Parse optional <collecting> directive suffix:\n * <collecting COLLECT_EXPR in ('%'|'@') IDENT across '^' IDENT>\n *\n * COLLECT_EXPR := '$' IDENT ':' '$' IDENT   (for k:v pairs -> %bucket)\n *               | '$' IDENT                  (for values only -> @bucket)\n *\n * The 'across ^label' clause is required - there is no default scope.\n *\n * @param {Parser} p - Parser instance\n * @param {Object} node - The node to potentially wrap in a Collecting\n * @returns {Object} - Original node or Collecting-wrapped node\n */\nfunction withOptionalCollecting(p, node) {\n  if (!p.peek('<')) return node;\n\n  // Check if it's <collecting (not just any <)\n  const next = p.toks[p.i + 1];\n  if (!next || next.k !== 'id' || next.v !== 'collecting') return node;\n\n  return p.span(() => {\n    p.eat('<');\n    p.eat('id'); // 'collecting'\n\n    // Parse COLLECT_EXPR: either '$key:$val' or just '$val'\n    p.eat('$');\n    const firstVar = eatVarName(p);\n\n    let collectExpr;\n    if (p.peek(':')) {\n      // Key:value form\n      p.eat(':');\n      p.eat('$');\n      const valueVar = eatVarName(p);\n      collectExpr = {key: firstVar, value: valueVar};\n    } else {\n      // Value-only form\n      collectExpr = {value: firstVar};\n    }\n\n    // Parse 'in' ('%'|'@') IDENT\n    if (!p.peek('id') || p.toks[p.i].v !== 'in') {\n      p.fail(\"expected 'in' after collecting expression\");\n    }\n    p.eat('id'); // 'in'\n\n    let sliceKind;\n    if (p.peek('%')) {\n      p.eat('%');\n      sliceKind = 'object';\n    } else if (p.peek('@')) {\n      p.eat('@');\n      sliceKind = 'array';\n    } else {\n      p.fail(\"expected '%' or '@' after 'in'\");\n    }\n    const bucket = eatVarName(p);\n\n    // Parse 'across' '^' IDENT (required)\n    if (!p.peek('id') || p.toks[p.i].v !== 'across') {\n      p.fail(\"expected 'across ^label' - the across clause is required\");\n    }\n    p.eat('id'); // 'across'\n    p.eat('^');\n    const labelRef = eatVarName(p);\n\n    p.eat('>');\n\n    // Type enforcement validation is done in the AST validation phase\n    // (after parsing completes, outside of backtracking context)\n\n    return Collecting(node, collectExpr, bucket, sliceKind, labelRef);\n  });\n}\n\n// ---------- ROOT_PATTERN ----------\n\nfunction parseRootPattern(p) {\n  // Check for slice patterns: %{ O_GROUP } (object) or @[ A_BODY ] (array)\n  if (p.peek('%')) {\n    const next = p.toks[p.i + 1];\n    if (next && next.k === '{') {\n      return parseObjectSlicePattern(p);\n    }\n  }\n  if (p.peek('@')) {\n    const next = p.toks[p.i + 1];\n    if (next && next.k === '[') {\n      return parseArraySlicePattern(p);\n    }\n  }\n  return parseItem(p);\n}\n\nfunction parseObjectSlicePattern(p) {\n  // %{ O_GROUP+ }\n  p.eat('%');\n  p.eat('{');\n  const groups = [];\n  while (!p.peek('}')) {\n    groups.push(parseOGroup(p));\n    p.maybe(',');\n  }\n  if (groups.length === 0) {\n    p.fail('empty object slice pattern %{ } is not allowed');\n  }\n  p.eat('}');\n  return SlicePattern('object', {type: 'OGroup', groups});\n}\n\nfunction parseArraySlicePattern(p) {\n  // @[ A_BODY ]\n  p.eat('@');\n  p.eat('[');\n  const items = parseABody(p, ']');\n  if (items.length === 0) {\n    p.fail('empty array slice pattern @[ ] is not allowed');\n  }\n  p.eat(']');\n  // Wrap in Seq if multiple items, otherwise just the single item\n  const content = items.length === 1 ? items[0] : {type: 'Seq', items};\n  return SlicePattern('array', content);\n}\n\n// ---------- ITEM ----------\n\nfunction parseItem(p) {\n  // ITEM := ITEM_TERM ('|' ITEM_TERM)* | ITEM_TERM ('else' ITEM_TERM)*\n  // Both produce Alt nodes; else sets prioritized=true; cannot mix.\n  return p.span(() => parseItemInner(p));\n}\n\nfunction parseItemInner(p) {\n  const first = parseItemTerm(p);\n\n  // Try alternation: A | B | C  (entire chain must succeed or we abandon it)\n  const altChain = p.backtrack(() => {\n    p.eat('|');\n    const alts = [first, parseItemTerm(p)];\n    while (p.backtrack(() => { p.eat('|'); return true; })) {\n      alts.push(parseItemTerm(p));\n    }\n    return Alt(alts, false);\n  });\n  if (altChain) {\n    if (p.backtrack(() => { p.eat('else'); return true; })) {\n      p.fail(\"cannot mix '|' and 'else' without parentheses\");\n    }\n    return altChain;\n  }\n\n  // Try else chain: A else B else C  (entire chain must succeed or we abandon it)\n  // But 'else !' and 'else !?' are reserved for object strong semantics, don't consume\n  const elseChain = p.backtrack(() => {\n    p.eat('else');\n    if (p.peek('!')) return null;  // 'else !' is for object strong semantics\n    const alts = [first, parseItemTerm(p)];\n    // Continue eating 'else' unless followed by '!' (object strong semantics)\n    while (p.backtrack(() => { p.eat('else'); if (p.peek('!')) return null; return true; })) {\n      alts.push(parseItemTerm(p));\n    }\n    return Alt(alts, true);\n  });\n  if (elseChain) {\n    if (p.backtrack(() => { p.eat('|'); return true; })) {\n      p.fail(\"cannot mix '|' and 'else' without parentheses\");\n    }\n    return elseChain;\n  }\n\n  return first;\n}\n\nfunction parseItemTerm(p) {\n  // ITEM_TERM := ITEM_TERM_CORE ('->' S_GROUP FLOW_MOD?)? DIRECTIVE*\n  // DIRECTIVE := '<collecting' COLLECT_EXPR 'in' ('%'|'@') IDENT 'across' '^' IDENT '>'\n  const core = parseItemTermCore(p);\n  // First check for flow operator (will be deprecated outside 'each' clauses)\n  const withFlow = withOptionalFlow(p, core);\n  // Then check for <collecting> directive\n  return withOptionalCollecting(p, withFlow);\n}\n\nfunction parseItemTermCore(p) {\n  // ITEM_TERM_CORE := LOOK_AHEAD\n  //                 | '(' ITEM ')' | '(' ITEM 'as' ... ')' | '(' ITEM 'where' ... ')'\n  //                 | S_ITEM | S_GROUP | TYPED_WILD | '_' | LITERAL | OBJ | ARR\n  //\n  // Uses ordered backtracking: try each alternative, return first success.\n\n  return p.bt('lookahead', () => parseLookahead(p))\n      || parseParenWithBindingAndGuard(p, () => parseItem(p))\n      || p.bt('$bind', () => { p.eat('$'); return SBind(eatVarName(p), Any()); })\n      || p.bt('@bind', () => { p.eat('@'); return GroupBind(eatVarName(p), Quant(Any(), '*', 0, Infinity)); })\n      || p.bt('any', () => { p.eat('any'); return Any(); })\n      || p.bt('any_string', () => { p.eat('any_string'); return TypedAny('string'); })\n      || p.bt('any_number', () => { p.eat('any_number'); return TypedAny('number'); })\n      || p.bt('any_boolean', () => { p.eat('any_boolean'); return TypedAny('boolean'); })\n      || p.bt('number', () => Lit(p.eat('num').v))\n      || p.bt('boolean', () => Bool(p.eat('bool').v))\n      || p.bt('null', () => { p.eat('null'); return Null(); })\n      || p.bt('string', () => Lit(p.eat('str').v))\n      || p.bt('identifier', () => Lit(p.eat('id').v))\n      || p.bt('regex', () => {\n           const {source, flags} = p.eat('re').v;\n           const re = makeRegExp({source, flags});\n           return StringPattern('regex', `/${source}/${flags}`, s => typeof s === 'string' && re.test(s));\n         })\n      || p.bt('case-insensitive', () => {\n           const {lower, desc} = p.eat('ci').v;\n           return StringPattern('ci', desc, s => typeof s === 'string' && s.toLowerCase() === lower);\n         })\n      || p.bt('labeled-obj', () => { p.eat('\u00A7'); const label = eatVarName(p); return parseObj(p, label); })\n      || p.bt('labeled-arr', () => { p.eat('\u00A7'); const label = eatVarName(p); return parseArr(p, label); })\n      || p.bt('object', () => parseObj(p))\n      || p.bt('array', () => parseArr(p))\n      || p.fail('expected item');\n}\n\nfunction parseLookahead(p) {\n  // (? A_GROUP) or (! A_GROUP)\n  return p.backtrack(() => { p.eat('(?'); const pat = parseAGroup(p); p.eat(')'); return Look(false, pat); })\n      || p.backtrack(() => { p.eat('(!'); const pat = parseAGroup(p); p.eat(')'); return Look(true, pat); });\n}\n\nfunction parseObjectLookahead(p) {\n  // (? O_GROUP) or (! O_GROUP)\n  return p.backtrack(() => { p.eat('(?'); const pat = parseOGroup(p); p.eat(')'); return {type: 'OLook', neg: false, pat}; })\n      || p.backtrack(() => { p.eat('(!'); const pat = parseOGroup(p); p.eat(')'); return {type: 'OLook', neg: true, pat}; });\n}\n\n// ---------- ARRAYS ----------\n\n// A_BODY := (A_GROUP (','? A_GROUP)*)?\nfunction parseABody(p, ...stopTokens) {\n  const items = [];\n  while (!stopTokens.some(t => p.peek(t))) {\n    items.push(parseAGroup(p));\n    p.maybe(',');  // Optional comma\n  }\n  return items;\n}\n\nfunction parseArr(p, label = null) {\n  // ARR := '[' A_BODY ']'\n  return p.span(() => {\n    p.eat('[');\n    const items = parseABody(p, ']');\n    p.eat(']');\n    return Arr(items, label);\n  });\n}\n\nfunction parseAGroup(p) {\n  // A_GROUP := '...' | A_GROUP_BASE A_QUANT? ('|' A_GROUP_BASE A_QUANT?)* | A_GROUP_BASE A_QUANT? ('else' A_GROUP_BASE A_QUANT?)*\n\n  // Spread (quantifiers disallowed)\n  const spread = p.backtrack(() => {\n    p.eat('...');\n    const q = parseAQuant(p);\n    if (q) p.fail(`Quantifiers on '...' are not allowed (found '...${q.op}')`);\n    return Spread(null);\n  });\n  if (spread) return spread;\n\n  // Parse base with optional quantifier\n  const parseBaseWithQuant = () => {\n    const base = parseAGroupBase(p);\n    const q = parseAQuant(p);\n    return q ? Quant(base, q.op, q.min, q.max) : base;\n  };\n\n  const first = parseBaseWithQuant();\n\n  // Try alternation: A | B | C\n  if (p.backtrack(() => { p.eat('|'); return true; })) {\n    const alts = [first, parseBaseWithQuant()];\n    while (p.backtrack(() => { p.eat('|'); return true; })) {\n      alts.push(parseBaseWithQuant());\n    }\n    if (p.backtrack(() => { p.eat('else'); return true; })) {\n      p.fail(\"cannot mix '|' and 'else' without parentheses\");\n    }\n    return Alt(alts, false);\n  }\n\n  // Try else chain: A else B else C\n  if (p.backtrack(() => { p.eat('else'); return true; })) {\n    const alts = [first, parseBaseWithQuant()];\n    while (p.backtrack(() => { p.eat('else'); return true; })) {\n      alts.push(parseBaseWithQuant());\n    }\n    if (p.backtrack(() => { p.eat('|'); return true; })) {\n      p.fail(\"cannot mix '|' and 'else' without parentheses\");\n    }\n    return Alt(alts, true);\n  }\n\n  return first;\n}\n\nfunction parseAGroupBase(p) {\n  // Base A_GROUP without quantifiers or alternation\n  // Uses ordered backtracking: try each alternative, return first success.\n  // Note: $x and @x bindings are handled by parseItemTermCore (via parseItemTerm),\n  // which also handles <collecting> suffixes. Don't duplicate those cases here.\n  return p.bt('arr-lookahead', () => parseLookahead(p))\n      || parseParenWithBindingAndGuard(p, (p, stopTokens) => {\n           const items = parseABody(p, ...stopTokens);\n           return items.length === 1 ? items[0] : {type: 'Seq', items};\n         })\n      || parseItemTerm(p);\n}\n\n// isAQuant removed - use backtracking with parseAQuant instead\n\nfunction parseAQuant(p) {\n  // A_QUANT := '?' | '??' | '?+' | '+' | '+?' | '++' | '*' | '*?' | '*+'\n  //          | '{' INTEGER '}' | '{' INTEGER ',' INTEGER? '}' | '{' ',' INTEGER '}'\n  return p.backtrack(() => { p.eat('?+'); return {op: '?+', min: 0, max: 1}; })\n      || p.backtrack(() => { p.eat('??'); return {op: '??', min: 0, max: 1}; })\n      || p.backtrack(() => { p.eat('?');  return {op: '?',  min: 0, max: 1}; })\n      || p.backtrack(() => { p.eat('++'); return {op: '++', min: 1, max: Infinity}; })\n      || p.backtrack(() => { p.eat('+?'); return {op: '+?', min: 1, max: Infinity}; })\n      || p.backtrack(() => { p.eat('+');  return {op: '+',  min: 1, max: Infinity}; })\n      || p.backtrack(() => { p.eat('*+'); return {op: '*+', min: 0, max: Infinity}; })\n      || p.backtrack(() => { p.eat('*?'); return {op: '*?', min: 0, max: Infinity}; })\n      || p.backtrack(() => { p.eat('*');  return {op: '*',  min: 0, max: Infinity}; })\n      || p.backtrack(() => { p.eat('{'); p.eat(','); const max = eatNonNegInt(p, 'quantifier'); p.eat('}'); return {op: `{0,${max}}`, min: 0, max}; })\n      || p.backtrack(() => { p.eat('{'); const min = eatNonNegInt(p, 'quantifier'); p.eat(','); const max = eatNonNegInt(p, 'quantifier'); p.eat('}'); return {op: `{${min},${max}}`, min, max}; })\n      || p.backtrack(() => { p.eat('{'); const min = eatNonNegInt(p, 'quantifier'); p.eat(','); p.eat('}'); return {op: `{${min},}`, min, max: Infinity}; })\n      || p.backtrack(() => { p.eat('{'); const n = eatNonNegInt(p, 'quantifier'); p.eat('}'); return {op: `{${n}}`, min: n, max: n}; });\n}\n\n// ---------- OBJECTS ----------\n\nfunction parseObj(p, label = null) {\n  // OBJ := '{' O_BODY O_REMNANT? '}'\n  // O_REMNANT := S_GROUP ':' '(' 'remainder' ')'\n  //            | '(!' 'remainder' ')'\n  //            | 'remainder'\n  return p.span(() => {\n    p.eat('{');\n    const terms = [];\n\n    // Parse O_BODY: greedily parse O_GROUPs until we can't\n    while (true) {\n      const group = p.backtrack(() => {\n        if (p.peek('}')) return null;\n        const s = parseOGroup(p);\n        p.maybe(',');\n        return s;\n      });\n      if (!group) break;\n      terms.push(group);\n    }\n\n    // Now try to parse optional O_REMNANT\n    const remnant = parseORemnant(p);\n\n    p.eat('}');\n    return Obj(terms, remnant, label);\n  });\n}\n\nfunction parseORemnant(p) {\n  // O_REMNANT := '(' '%' QUANT? 'as' '%' IDENT ')' | '%' QUANT? | '(!' '%' ')'\n  // Uses ordered backtracking.\n  return p.bt('remainder-bind', () => {\n           p.eat('('); p.eat('%');\n           const q = p.backtrack(() => { p.eat('?'); return {min: 0, max: Infinity}; }) || parseRemainderQuant(p);\n           p.eat('as'); p.eat('%');\n           const name = eatVarName(p);\n           p.eat(')'); p.maybe(',');\n           return GroupBind(name, Spread(q), 'object');\n         })\n      || p.bt('remainder', () => {\n           p.eat('%');\n           const q = p.backtrack(() => { p.eat('?'); return {min: 0, max: Infinity}; }) || parseRemainderQuant(p);\n           p.maybe(',');\n           return Spread(q);\n         })\n      || p.bt('no-remainder', () => { p.eat('(!'); p.eat('%'); p.eat(')'); p.maybe(','); return {type: 'OLook', neg: true, pat: Spread(null)}; });\n}\n\nfunction parseRemainderQuant(p) {\n  // QUANT := '#?' | '#{' ',' INTEGER '}' | '#{' INTEGER '}' | '#{' INTEGER ',' INTEGER? '}'\n  return p.backtrack(() => { p.eat('#'); p.eat('?'); return {min: 0, max: Infinity}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); p.eat(','); const max = eatNonNegInt(p, '%'); p.eat('}'); return {min: 0, max}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const min = eatNonNegInt(p, '%'); p.eat(','); const max = eatNonNegInt(p, '%'); p.eat('}'); if (max < min) p.fail('% quantifier upper < lower'); return {min, max}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const min = eatNonNegInt(p, '%'); p.eat(','); p.eat('}'); return {min, max: Infinity}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const n = eatNonNegInt(p, '%'); p.eat('}'); return {min: n, max: n}; });\n}\n\nfunction parseOGroup(p) {\n  // O_GROUP := '(?' O_GROUP ')' | '(!' O_GROUP ')' | '(' O_GROUP* ')' | '(' O_GROUP* 'as' '%' IDENT ')'\n  //          | 'each' O_TERM '?'?\n  //          | O_TERM '?'?\n  // Uses ordered backtracking.\n\n  // Lookahead\n  const look = p.bt('obj-lookahead', () => parseObjectLookahead(p));\n  if (look) return look;\n\n  // Parenthesized grouping with optional 'as %x' binding (object slice)\n  const groupWithBind = p.bt('obj-group-bind', () => {\n    p.eat('(');\n    const groups = parseOBodyUntil(p, ')', 'as');\n    p.eat('as');\n    p.eat('%');\n    const name = eatVarName(p);\n    p.eat(')');\n    return GroupBind(name, {type: 'OGroup', groups}, 'object');\n  });\n  if (groupWithBind) return groupWithBind;\n\n  const groupPlain = p.bt('obj-group', () => {\n    p.eat('(');\n    const groups = parseOBodyUntil(p, ')');\n    p.eat(')');\n    return {type: 'OGroup', groups};\n  });\n  if (groupPlain) return groupPlain;\n\n  // 'each K:V' syntax - strong field clause (for all k~K, value must match V)\n  const eachTerm = p.bt('obj-each-term', () => {\n    p.eat('each');\n    const term = parseOTerm(p);\n    // Optional via K?:V (from parseOTerm) or trailing K:V ?\n    const optional = term.optional || !!p.backtrack(() => { p.eat('?'); return true; });\n    const result = OTerm(term.key, term.breadcrumbs, term.val, term.quant, optional, true);\n    if (term.loc) result.loc = term.loc;\n    return result;\n  });\n  if (eachTerm) return eachTerm;\n\n  const term = parseOTerm(p);\n  // Optional via K?:V (from parseOTerm) or trailing K:V ?\n  const optional = term.optional || !!p.backtrack(() => { p.eat('?'); return true; });\n  const result = OTerm(term.key, term.breadcrumbs, term.val, term.quant, optional, false);\n  if (term.loc) result.loc = term.loc;  // preserve source location\n  return result;\n}\n\n// Helper: parse O_GROUP* until one of stopTokens\nfunction parseOBodyUntil(p, ...stopTokens) {\n  const groups = [];\n  while (!stopTokens.some(t => p.peek(t))) {\n    groups.push(parseOGroup(p));\n    p.maybe(',');\n  }\n  return groups;\n}\n\nfunction parseOTerm(p) {\n  // O_TERM := KEY BREADCRUMB* '?'? ':' VALUE O_KV_QUANT?\n  // Note: 'else !' suffix and trailing '?' suffix are handled by parseOGroup\n  // The '?' before ':' (K?:V) is the preferred optional syntax\n  return p.span(() => {\n    // Leading ** means \"start from root, match at any depth within the object\".\n    // Design: We peek (not eat) the ** here to set RootKey, then let parseBreadcrumb\n    // consume it as a 'skip' breadcrumb. This is intentional - RootKey signals \"don't\n    // match an initial key\", while the breadcrumb does the actual depth navigation.\n    // Example: { **:1 } \u2192 key=RootKey, breadcrumbs=[skip:Any], matches {x:{y:1}}.\n    // Note: This does NOT match root-as-leaf (e.g., { **:1 } doesn't match bare 1).\n    const key = p.peek('**') ? RootKey() : parseItem(p);\n\n    // Parse breadcrumbs\n    const breadcrumbs = [];\n    for (let bc; (bc = parseBreadcrumb(p)); ) breadcrumbs.push(bc);\n\n    // Check for K?:V syntax (preferred optional field syntax)\n    const optional = !!p.maybe('?');\n\n    p.eat(':');\n    const val = parseItem(p);\n    const quant = parseOQuant(p);\n\n    return OTerm(key, breadcrumbs, val, quant, optional, false);\n  });\n}\n\nfunction parseBreadcrumb(p) {\n  // BREADCRUMB := '**' ':'? | '**' '.'? KEY | '.' '**' ':'? | '.' '**' '.'? KEY | '.' KEY | '[' KEY ']'\n  return p.bt('bc-skip', () => { p.eat('**'); if (p.peek(':')) return Breadcrumb('skip', Any(), null); p.maybe('.'); return Breadcrumb('skip', parseItem(p), null); })\n      || p.bt('bc-dot-skip', () => { p.eat('.'); p.eat('**'); if (p.peek(':')) return Breadcrumb('skip', Any(), null); p.maybe('.'); return Breadcrumb('skip', parseItem(p), null); })\n      || p.bt('bc-dot', () => { p.eat('.'); return Breadcrumb('dot', parseItem(p), null); })\n      || p.bt('bc-bracket', () => { p.eat('['); const key = parseItem(p); p.eat(']'); return Breadcrumb('bracket', key, null); });\n}\n\n// parseBQuant removed - breadcrumbs no longer support quantifiers in v5\n\nfunction parseOQuant(p) {\n  // O_QUANT := '#?' | '#{' ',' INTEGER '}' | '#{' INTEGER '}' | '#{' INTEGER ',' INTEGER? '}'\n  return p.backtrack(() => { p.eat('#'); p.eat('?'); return {min: 0, max: Infinity}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); p.eat(','); const max = eatNonNegInt(p, 'O_QUANT'); p.eat('}'); return {min: 0, max}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const min = eatNonNegInt(p, 'O_QUANT'); p.eat(','); const max = eatNonNegInt(p, 'O_QUANT'); p.eat('}'); if (max < min) p.fail('O_QUANT upper < lower'); return {min, max}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const min = eatNonNegInt(p, 'O_QUANT'); p.eat(','); p.eat('}'); return {min, max: Infinity}; })\n      || p.backtrack(() => { p.eat('#'); p.eat('{'); const n = eatNonNegInt(p, 'O_QUANT'); p.eat('}'); return {min: n, max: n}; });\n}\n\n// ---------- Parser Utilities ----------\n\n// Eat a non-negative integer (for quantifier counts)\nfunction eatNonNegInt(p, context = 'quantifier') {\n  const tok = p.eat('num', `expected non-negative integer in ${context}`);\n  const v = tok.v;\n  if (!Number.isInteger(v) || v < 0) {\n    p.fail(`${context} requires non-negative integer, got ${v}`);\n  }\n  return v;\n}\n\n// ---------- AST Validation ----------\n\n// Validate AST: Flow/Collecting placement, scope requirements, and bucket conflicts\nfunction validateAST(ast, src = null) {\n  // Track slice names and their kinds to detect type conflicts (@x vs %x)\n  // Map: name -> {kind: 'array'|'object', loc}\n  const sliceBindings = new Map();\n\n  // Track bucket scopes to detect duplicate bucket names in different scopes\n  // Map: bucketName -> {scope: string, loc}\n  // scope is either a label name or a generated ID for implicit each scopes\n  const bucketScopes = new Map();\n\n  // Track all labels defined in the AST for forward reference checking\n  const definedLabels = new Set();\n\n  // First pass: collect all defined labels\n  function collectLabels(node) {\n    if (!node || typeof node !== 'object') return;\n    if ((node.type === 'Obj' || node.type === 'Arr') && node.label) {\n      definedLabels.add(node.label);\n    }\n    // Recurse\n    for (const key of Object.keys(node)) {\n      const val = node[key];\n      if (Array.isArray(val)) {\n        for (const item of val) collectLabels(item);\n      } else if (val && typeof val === 'object') {\n        collectLabels(val);\n      }\n    }\n  }\n  collectLabels(ast);\n\n  // Counter for generating unique implicit scope IDs for each clauses\n  let implicitScopeCounter = 0;\n\n  // Check for slice type conflicts (same name with different kinds)\n  function checkSliceConflict(name, kind, loc) {\n    const existing = sliceBindings.get(name);\n    if (existing) {\n      if (existing.kind !== kind) {\n        const existingSigil = existing.kind === 'object' ? '%' : '@';\n        const newSigil = kind === 'object' ? '%' : '@';\n        let msg = `Slice name conflict: '${name}' used as both ${existingSigil}${name} and ${newSigil}${name}`;\n        if (src && loc) {\n          msg += `\\n  at: ${src.slice(loc.start, loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n    } else {\n      sliceBindings.set(name, {kind, loc});\n    }\n  }\n\n  // Check for bucket scope conflicts (same bucket name in different scopes)\n  function checkBucketScope(bucketName, scope, loc, sigil) {\n    const existing = bucketScopes.get(bucketName);\n    if (existing) {\n      if (existing.scope !== scope) {\n        let msg = `Bucket name conflict: '${sigil}${bucketName}' used in different scopes`;\n        if (src && loc) {\n          msg += `\\n  at: ${src.slice(loc.start, loc.end)}`;\n        }\n        if (src && existing.loc) {\n          msg += `\\n  previously at: ${src.slice(existing.loc.start, existing.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n    } else {\n      bucketScopes.set(bucketName, {scope, loc});\n    }\n  }\n\n  // Main validation traversal\n  // ctx contains: {inContainer, implicitScope (ID of enclosing each clause, or null)}\n  function check(node, ctx) {\n    if (!node || typeof node !== 'object') return;\n\n    const {inContainer, implicitScope} = ctx;\n\n    // Check Flow nodes\n    if (node.type === 'Flow') {\n      if (!inContainer) {\n        const sigil = node.sliceKind === 'object' ? '%' : '@';\n        let msg = `Flow operator ->${sigil}${node.bucket} can only be used inside an object or array pattern`;\n        if (src && node.loc) {\n          msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n\n      // Determine scope for this bucket\n      let scope;\n      const sigil = node.sliceKind === 'object' ? '%' : '@';\n      if (node.labelRef) {\n        // Explicit label reference\n        if (!definedLabels.has(node.labelRef)) {\n          let msg = `Flow operator ->${sigil}${node.bucket}<^${node.labelRef}> references unknown label '${node.labelRef}'`;\n          if (src && node.loc) {\n            msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n          }\n          throw new Error(msg);\n        }\n        scope = `label:${node.labelRef}`;\n      } else {\n        // Implicit scope: must be inside an each clause\n        if (implicitScope === null) {\n          let msg = `Flow operator ->${sigil}${node.bucket} requires enclosing 'each' clause (or explicit <^label>)`;\n          if (src && node.loc) {\n            msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n          }\n          throw new Error(msg);\n        }\n        scope = `implicit:${implicitScope}`;\n      }\n\n      checkSliceConflict(node.bucket, node.sliceKind || 'object', node.loc);\n      checkBucketScope(node.bucket, scope, node.loc, sigil);\n    }\n\n    // Check Collecting directive nodes\n    if (node.type === 'Collecting') {\n      if (!inContainer) {\n        const sigil = node.sliceKind === 'object' ? '%' : '@';\n        let msg = `<collecting> directive can only be used inside an object or array pattern`;\n        if (src && node.loc) {\n          msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n\n      // Type enforcement: k:v form requires %bucket, value-only form requires @bucket\n      if (node.collectExpr.key !== undefined && node.sliceKind !== 'object') {\n        let msg = `key:value collection requires %bucket (object slice), not @bucket`;\n        if (src && node.loc) {\n          msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n      if (node.collectExpr.key === undefined && node.sliceKind !== 'array') {\n        let msg = `value-only collection requires @bucket (array slice), not %bucket`;\n        if (src && node.loc) {\n          msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n\n      // Check label exists\n      if (!definedLabels.has(node.labelRef)) {\n        let msg = `<collecting> references unknown label '${node.labelRef}'`;\n        if (src && node.loc) {\n          msg += `\\n  at: ${src.slice(node.loc.start, node.loc.end)}`;\n        }\n        throw new Error(msg);\n      }\n\n      const sigil = node.sliceKind === 'object' ? '%' : '@';\n      const scope = `label:${node.labelRef}`;\n      checkSliceConflict(node.bucket, node.sliceKind, node.loc);\n      checkBucketScope(node.bucket, scope, node.loc, sigil);\n    }\n\n    // Check GroupBind slice kinds\n    if (node.type === 'GroupBind') {\n      checkSliceConflict(node.name, node.sliceKind || 'array', node.loc);\n    }\n\n    // Determine child context\n    const inChild = inContainer || node.type === 'Obj' || node.type === 'Arr';\n\n    // Recurse into children based on node type\n    switch (node.type) {\n      case 'Obj':\n        for (const term of node.terms || []) check(term, {inContainer: inChild, implicitScope});\n        if (node.spread) check(node.spread, {inContainer: inChild, implicitScope});\n        break;\n      case 'Arr':\n        for (const item of node.items || []) check(item, {inContainer: inChild, implicitScope});\n        break;\n      case 'OTerm':\n        check(node.key, {inContainer: inChild, implicitScope});\n        // For each clauses (strong=true), create a new implicit scope for the value\n        if (node.strong) {\n          const newScope = `each_${implicitScopeCounter++}`;\n          check(node.val, {inContainer: inChild, implicitScope: newScope});\n        } else {\n          check(node.val, {inContainer: inChild, implicitScope});\n        }\n        for (const bc of node.breadcrumbs || []) check(bc.key, {inContainer: inChild, implicitScope});\n        break;\n      case 'Alt':\n        for (const alt of node.alts || []) check(alt, {inContainer: inChild, implicitScope});\n        break;\n      case 'Quant':\n      case 'Look':\n      case 'SBind':\n      case 'GroupBind':\n      case 'Flow':\n      case 'Collecting':\n      case 'Guarded':\n        check(node.pat || node.sub, {inContainer: inChild, implicitScope});\n        break;\n      case 'Seq':\n        for (const item of node.items || []) check(item, {inContainer: inChild, implicitScope});\n        break;\n      case 'OGroup':\n        for (const g of node.groups || []) check(g, {inContainer: inChild, implicitScope});\n        break;\n      case 'SlicePattern':\n        check(node.content, {inContainer: true, implicitScope}); // Slice patterns are container-like\n        break;\n    }\n  }\n\n  check(ast, {inContainer: false, implicitScope: null});\n}\n\n// ---------- Exports ----------\n\nexport const AST = {\n  // Atoms\n  Any, Lit, StringPattern, Bool, Null, Fail, RootKey,\n  // Bindings\n  SBind, GroupBind, Guarded,\n  // Containers\n  Arr, Obj,\n  // Operators\n  Alt, Look, Quant,\n  // Object\n  OTerm, Spread, Breadcrumb,\n};\n", "// tendril-engine.js \u2014 evaluator for Tendril v5-A AST\n// Requires AST produced by tendril-parser.js and helpers from microparser.js\n\nimport {\n  bindScalar, bindGroup, cloneEnv, isBound,\n} from './microparser.js';\nimport {Group} from './tendril-api.js';\nimport {sameValueZero} from './tendril-util.js';\nimport {evaluateExpr, getExprVariables} from './tendril-el.js';\n\n// ------------- StopSearch sentinel for early termination -------------\n// Used by short-circuit helpers (matchExists, scanFirst, etc.) to stop\n// enumeration after the first solution is found.\nclass StopSearch extends Error {\n  constructor(payload) {\n    super('StopSearch');\n    this.payload = payload;\n  }\n}\n\n// ------------- Solution structure: {env, sites} -------------\n// Solution tracks both bindings (env) and where they were bound (sites)\n// Site kinds:\n//  - scalar: {kind: 'scalar', path: [], valueRef: obj}\n//  - group (array): {kind: 'group', path: [], groupStart: n, groupEnd: m, valueRefs: [obj1, ...]}\n//  - group (object): {kind: 'group', path: [], keys: ['a', ...], valueRefs: {a: obj1, ...}}\n\nfunction newSolution() {\n  // labels: Map<labelName, {key: flowKey, bucketLevel: number}>\n  // bucketLevel is the index in bucketStack where entries for this label should go\n  return {env: new Map(), sites: new Map(), guards: [], bucketStack: [], labels: new Map()};\n}\n\nfunction cloneSolution(sol) {\n  const sites = new Map();\n  for (const [k, v] of sol.sites) {\n    sites.set(k, [...v]); // shallow copy of site array\n  }\n  // Deep clone bucketStack: array of Maps, each Map has bucket entries\n  const bucketStack = sol.bucketStack.map(level => {\n    const clonedLevel = new Map();\n    for (const [name, entries] of level) {\n      clonedLevel.set(name, {...entries}); // shallow clone of entries object\n    }\n    return clonedLevel;\n  });\n  return {\n    env: cloneEnv(sol.env),\n    sites,\n    guards: sol.guards ? [...sol.guards] : [],\n    bucketStack,\n    labels: new Map([...sol.labels].map(([name, info]) => [name, {...info}]))\n  };\n}\n\n// ---------- Bucket helpers for Flow operator ----------\n\n// Push a new bucket level onto a solution's stack\nfunction pushBucketLevel(sol) {\n  sol.bucketStack.push(new Map());\n}\n\n// Add an entry to a bucket level\n// If bucketLevel is provided, add to that level; otherwise add to current (top) level\n// sliceKind: 'object' collects {key: value}, 'array' collects [value, ...]\n// Returns true on success, false on collision (same key already exists for object buckets)\nfunction addToBucket(sol, bucketName, key, value, bucketLevel = null, sliceKind = 'object') {\n  if (sol.bucketStack.length === 0) {\n    throw new Error(`Flow ->${sliceKind === 'object' ? '%' : '@'}${bucketName} used outside of K:V context`);\n  }\n\n  const levelIndex = bucketLevel !== null ? bucketLevel : sol.bucketStack.length - 1;\n  if (levelIndex < 0 || levelIndex >= sol.bucketStack.length) {\n    throw new Error(`Invalid bucket level ${levelIndex} (stack size: ${sol.bucketStack.length})`);\n  }\n\n  const level = sol.bucketStack[levelIndex];\n  if (!level.has(bucketName)) {\n    // Initialize bucket with kind tracking\n    level.set(bucketName, {kind: sliceKind, entries: sliceKind === 'object' ? {} : []});\n  }\n  const bucket = level.get(bucketName);\n\n  // Check for kind mismatch (same bucket used with both % and @)\n  if (bucket.kind !== sliceKind) {\n    throw new Error(`Bucket '${bucketName}' used with both % and @ sigils - pick one`);\n  }\n\n  if (sliceKind === 'object') {\n    // Object bucket: {key: value, ...}\n    if (Object.prototype.hasOwnProperty.call(bucket.entries, key)) {\n      // Collision: same key already in bucket - fail this branch\n      return false;\n    }\n    bucket.entries[key] = value;\n  } else {\n    // Array bucket: [value, ...]\n    bucket.entries.push(value);\n  }\n  return true;\n}\n\n// Collect and merge bucket entries from top level of all solutions,\n// then pop that level and bind merged buckets to all solutions.\n// Returns the filtered list of solutions (those where binding succeeded).\nfunction finalizeBucketLevel(solutions) {\n  if (solutions.length === 0) return solutions;\n\n  // Collect and merge from top level of all solutions\n  // Also detect collisions: same key appearing in multiple solutions with different values (object buckets only)\n  const merged = new Map(); // bucketName -> {kind: 'object'|'array', entries: {...}|[...]}\n  let hasCollision = false;\n\n  for (const state of solutions) {\n    const sol = state.sol || state;\n    if (sol.bucketStack.length === 0) continue;\n    const top = sol.bucketStack[sol.bucketStack.length - 1];\n    for (const [name, bucket] of top) {\n      if (!merged.has(name)) {\n        merged.set(name, {kind: bucket.kind, entries: bucket.kind === 'object' ? {} : []});\n      }\n      const mergedBucket = merged.get(name);\n\n      if (bucket.kind === 'object') {\n        // Object bucket: merge k:v pairs, detect collisions\n        for (const [key, value] of Object.entries(bucket.entries)) {\n          if (Object.prototype.hasOwnProperty.call(mergedBucket.entries, key)) {\n            // Same key already exists - only a collision if values differ\n            const existing = mergedBucket.entries[key];\n            if (!sameValueZero(existing, value) && JSON.stringify(existing) !== JSON.stringify(value)) {\n              // Collision: same key with different values\n              hasCollision = true;\n            }\n            // If same value, just keep the existing (they're duplicates)\n          } else {\n            mergedBucket.entries[key] = value;\n          }\n        }\n      } else {\n        // Array bucket: concatenate values (no collision detection)\n        mergedBucket.entries.push(...bucket.entries);\n      }\n    }\n  }\n\n  // If there was a collision during merge, fail all solutions\n  if (hasCollision) {\n    // Pop bucket levels but don't bind\n    for (const state of solutions) {\n      const sol = state.sol || state;\n      if (sol.bucketStack.length > 0) {\n        sol.bucketStack.pop();\n      }\n    }\n    return [];\n  }\n\n  // Pop and bind to all solutions, filtering out those where binding fails\n  const surviving = [];\n  for (const state of solutions) {\n    const sol = state.sol || state;\n    if (sol.bucketStack.length > 0) {\n      sol.bucketStack.pop();\n    }\n    // Bind each merged bucket as a group variable\n    let bindOk = true;\n    for (const [name, bucket] of merged) {\n      const groupValue = bucket.kind === 'object'\n        ? Group.object(bucket.entries)\n        : Group.array(...bucket.entries);\n      if (!bindGroup(sol.env, name, groupValue)) {\n        bindOk = false;\n        break;\n      }\n    }\n    if (bindOk) {\n      surviving.push(state);\n    }\n  }\n  return surviving;\n}\n\n// Add a guard to the solution's pending guards list\nfunction addGuard(sol, guard, varName) {\n  if (!guard) return;\n  const requiredVars = getExprVariables(guard);\n  sol.guards.push({guard, varName, requiredVars});\n}\n\n// Check if all pending guards evaluate to true\n// Returns true if all guards pass, false if any guard fails\nfunction checkGuards(sol) {\n  for (const {guard, varName, requiredVars} of sol.guards) {\n    // Check if all required variables are bound\n    let allBound = true;\n    for (const v of requiredVars) {\n      if (!isBound(sol.env, v)) {\n        allBound = false;\n        break;\n      }\n    }\n\n    if (!allBound) {\n      // Guard not yet closed - this is an error at the end of matching\n      // For now, we'll check this at emit time\n      continue;\n    }\n\n    // Evaluate the guard\n    try {\n      const result = evaluateExpr(guard, sol.env);\n      if (!result) {\n        return false; // Guard failed\n      }\n    } catch (e) {\n      return false; // Guard errored - treat as failure\n    }\n  }\n  return true;\n}\n\n// Check if all guards are closed (all required variables are bound)\nfunction allGuardsClosed(sol) {\n  for (const {requiredVars} of sol.guards) {\n    for (const v of requiredVars) {\n      if (!isBound(sol.env, v)) return false;\n    }\n  }\n  return true;\n}\n\nfunction recordScalarSite(sol, varName, path, valueRef) {\n  if (!sol.sites.has(varName)) {\n    sol.sites.set(varName, []);\n  }\n  sol.sites.get(varName).push({kind: 'scalar', path: [...path], valueRef});\n}\n\nfunction recordGroupSite(sol, varName, path, groupStart, groupEnd, valueRefs) {\n  if (!sol.sites.has(varName)) {\n    sol.sites.set(varName, []);\n  }\n  sol.sites.get(varName).push({\n    kind: 'group',\n    path: [...path],\n    groupStart,\n    groupEnd,\n    valueRefs: [...valueRefs],\n  });\n}\n\n/**\n * Check if a pattern AST contains any binding nodes (SBind or GroupBind).\n * Used to optimize lookaheads: if no bindings, we can stop at first match.\n * Result is lazily cached on the node as _hasBindings.\n */\nfunction patternHasBindings(ast) {\n  if (!ast || typeof ast !== 'object') return false;\n\n  // Return cached result if available\n  if ('_hasBindings' in ast) return ast._hasBindings;\n\n  let result = false;\n\n  if (ast.type === 'SBind' || ast.type === 'GroupBind') {\n    result = true;\n  } else {\n    // Recurse into known child properties\n    if (ast.pat && patternHasBindings(ast.pat)) result = true;\n    else if (ast.val && patternHasBindings(ast.val)) result = true;\n    else if (ast.items) {\n      for (const item of ast.items) {\n        if (patternHasBindings(item)) { result = true; break; }\n      }\n    }\n    if (!result && ast.alts) {\n      for (const alt of ast.alts) {\n        if (patternHasBindings(alt)) { result = true; break; }\n      }\n    }\n    if (!result && ast.groups) {\n      for (const group of ast.groups) {\n        if (patternHasBindings(group)) { result = true; break; }\n      }\n    }\n    if (!result && ast.terms) {\n      for (const term of ast.terms) {\n        if (patternHasBindings(term)) { result = true; break; }\n        if (term.key && patternHasBindings(term.key)) { result = true; break; }\n        if (term.val && patternHasBindings(term.val)) { result = true; break; }\n      }\n    }\n  }\n\n  ast._hasBindings = result;\n  return result;\n}\n\n// Public entry: evaluate a parsed ITEM AST on input, return list of solutions.\n// Each solution: {bindings: Object, sites: Map<varName, Site[]>}\nexport function match(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  const solutions = [];\n\n  matchItem(ast, input, [], newSolution(), (sol) => solutions.push(sol), ctx);\n\n  // Filter and convert to public API format\n  // Only include solutions where all guards are closed and pass\n  return solutions\n    .filter(sol => allGuardsClosed(sol) && checkGuards(sol))\n    .map(sol => {\n      const bindings = Object.fromEntries(\n        Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n      );\n      return {bindings, sites: sol.sites};\n    });\n}\n\n// Scan mode: find all occurrences at any depth\nexport function scan(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  const solutions = [];\n\n  // Helper: recursively scan value at path\n  function scanValue(value, path) {\n    guard(ctx);\n\n    // Try matching pattern at this position\n    matchItem(ast, value, path, newSolution(), (sol) => solutions.push(sol), ctx);\n\n    // Recursively descend into structure\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        scanValue(value[i], [...path, i]);\n      }\n    } else if (value && typeof value === 'object') {\n      for (const key of Object.keys(value)) {\n        scanValue(value[key], [...path, key]);\n      }\n    }\n  }\n\n  scanValue(input, []);\n\n  // Filter and convert to public API format\n  // Only include solutions where all guards are closed and pass\n  return solutions\n    .filter(sol => allGuardsClosed(sol) && checkGuards(sol))\n    .map(sol => {\n      const bindings = Object.fromEntries(\n        Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n      );\n      return {bindings, sites: sol.sites};\n    });\n}\n\n// ------------- Short-circuit helpers -------------\n// These use StopSearch to terminate early after finding the first solution.\n\n/**\n * Check if pattern matches input (anchored). Returns boolean.\n * Short-circuits on first match - does not enumerate all solutions.\n */\nexport function matchExists(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  try {\n    matchItem(ast, input, [], newSolution(), (sol) => {\n      // Only count as match if all guards are closed and pass\n      if (allGuardsClosed(sol) && checkGuards(sol)) {\n        throw new StopSearch(true);\n      }\n    }, ctx);\n    return false;\n  } catch (e) {\n    if (e instanceof StopSearch) return true;\n    throw e;\n  }\n}\n\n/**\n * Get first match of pattern on input (anchored). Returns raw solution or null.\n * Short-circuits after finding first solution.\n */\nexport function matchFirst(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n  try {\n    matchItem(ast, input, [], newSolution(), (sol) => {\n      // Only accept if all guards are closed and pass\n      if (allGuardsClosed(sol) && checkGuards(sol)) {\n        throw new StopSearch(sol);\n      }\n    }, ctx);\n    return null;\n  } catch (e) {\n    if (e instanceof StopSearch) {\n      // Convert to public API format\n      const sol = e.payload;\n      const bindings = Object.fromEntries(\n        Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n      );\n      return {bindings, sites: sol.sites};\n    }\n    throw e;\n  }\n}\n\n/**\n * Check if pattern matches anywhere in input (scan). Returns boolean.\n * Short-circuits on first match - does not scan entire tree.\n */\nexport function scanExists(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n\n  function scanValue(value, path) {\n    guard(ctx);\n\n    // Try matching pattern at this position - throws StopSearch on success\n    matchItem(ast, value, path, newSolution(), (sol) => {\n      // Only count as match if all guards are closed and pass\n      if (allGuardsClosed(sol) && checkGuards(sol)) {\n        throw new StopSearch(true);\n      }\n    }, ctx);\n\n    // Recursively descend into structure\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        scanValue(value[i], [...path, i]);\n      }\n    } else if (value && typeof value === 'object') {\n      for (const key of Object.keys(value)) {\n        scanValue(value[key], [...path, key]);\n      }\n    }\n  }\n\n  try {\n    scanValue(input, []);\n    return false;\n  } catch (e) {\n    if (e instanceof StopSearch) return true;\n    throw e;\n  }\n}\n\n/**\n * Get first match of pattern anywhere in input (scan). Returns raw solution or null.\n * Short-circuits after finding first match - does not scan entire tree.\n */\nexport function scanFirst(ast, input, opts = {}) {\n  const maxSteps = opts.maxSteps ?? 2000000;\n  const debug = opts.debug;\n  const ctx = {steps: 0, maxSteps, debug};\n\n  function scanValue(value, path) {\n    guard(ctx);\n\n    // Try matching pattern at this position - throws StopSearch on success\n    matchItem(ast, value, path, newSolution(), (sol) => {\n      // Only accept if all guards are closed and pass\n      if (allGuardsClosed(sol) && checkGuards(sol)) {\n        throw new StopSearch(sol);\n      }\n    }, ctx);\n\n    // Recursively descend into structure\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        scanValue(value[i], [...path, i]);\n      }\n    } else if (value && typeof value === 'object') {\n      for (const key of Object.keys(value)) {\n        scanValue(value[key], [...path, key]);\n      }\n    }\n  }\n\n  try {\n    scanValue(input, []);\n    return null;\n  } catch (e) {\n    if (e instanceof StopSearch) {\n      // Convert to public API format\n      const sol = e.payload;\n      const bindings = Object.fromEntries(\n        Array.from(sol.env.entries()).map(([k, v]) => [k, v.value])\n      );\n      return {bindings, sites: sol.sites};\n    }\n    throw e;\n  }\n}\n\n// Backward compatibility: matchProgram for old tests\nexport function matchProgram(ast, input, opts = {}) {\n  // Old AST had {type: 'Program', rules: [...]}\n  // Convert to new format or handle directly\n  if (ast.type === 'Program') {\n    throw new Error('Old Program AST not supported - use new v5-A parser');\n  }\n  return match(ast, input, opts);\n}\n\n// ------------- Core ITEM matching -------------\n\nfunction matchItem(item, node, path, sol, emit, ctx) {\n  guard(ctx);\n\n  // Debug hook: entering item match\n  if (ctx.debug?.onEnter) {\n    ctx.debug.onEnter(item.type, node, path);\n  }\n\n  let matched = false;\n  const originalEmit = emit;\n  const trackingEmit = (s) => {\n    matched = true;\n    originalEmit(s);\n  };\n\n  try {\n    // Temporarily replace emit to track if we matched\n    emit = trackingEmit;\n\n    doMatch();\n  } finally {\n    // Debug hook: exiting item match\n    if (ctx.debug?.onExit) {\n      ctx.debug.onExit(item.type, node, path, matched);\n    }\n  }\n\n  function doMatch() {\n    switch (item.type) {\n      case 'Any':\n        emit(cloneSolution(sol));\n        return;\n\n      case 'TypedAny':\n        // Typed wildcards: _string, _number, _boolean\n        if (typeof node === item.kind) emit(cloneSolution(sol));\n        return;\n\n      case 'Lit':\n        // Use SameValueZero: NaN equals NaN, 0 equals -0\n        if (sameValueZero(node, item.value)) emit(cloneSolution(sol));\n        return;\n\n      case 'StringPattern':\n        // String patterns (regex or case-insensitive) use their matchFn\n        if (item.matchFn(node)) emit(cloneSolution(sol));\n        return;\n\n      case 'Bool':\n        // Use SameValueZero for consistency (though booleans don't have edge cases)\n        if (sameValueZero(node, item.value)) emit(cloneSolution(sol));\n        return;\n\n      case 'Null':\n        if (node === null) emit(cloneSolution(sol));\n        return;\n\n      case 'Fail':\n        // Fail pattern: always fails, never emits solutions\n        // Used for 'else !' strong semantics\n        return;\n\n      case 'Flow': {\n        // Flow operator: P -> %bucket (k:v pairs) or P -> @bucket (values only)\n        // Match the inner pattern; if successful, record entry in bucket\n        // - sliceKind='object' (%bucket): collect {flowKey: matchedValue}\n        // - sliceKind='array' (@bucket): collect [matchedValue, ...]\n        // ctx.flowKey is set by the enclosing K:V iteration\n        // If labelRef is specified, use the key from that labeled scope instead\n\n        // Note: Flow inside arrays under K:V uses the outer flowKey for all elements.\n        // For object buckets: multiple elements flowing DIFFERENT values cause collision.\n        // For array buckets: all values are collected (no collision).\n\n        const sliceKind = item.sliceKind || 'object'; // default to object for backward compat\n        const sigil = sliceKind === 'object' ? '%' : '@';\n\n        matchItem(item.pat, node, path, sol, (s2) => {\n          // Determine which key and bucket level to use\n          let flowKey;\n          let bucketLevel = null; // null means current (top) level\n\n          if (item.labelRef) {\n            // Use key and bucket level from labeled scope\n            if (!s2.labels.has(item.labelRef)) {\n              throw new Error(\n                `Flow operator ->${sigil}${item.bucket}<^${item.labelRef}> references unknown label '${item.labelRef}'`\n              );\n            }\n            const labelInfo = s2.labels.get(item.labelRef);\n            if (labelInfo.key === undefined) {\n              throw new Error(\n                `Flow operator ->${sigil}${item.bucket}<^${item.labelRef}> references label '${item.labelRef}' ` +\n                `which was not in a K:V iteration context`\n              );\n            }\n            flowKey = labelInfo.key;\n            bucketLevel = labelInfo.bucketLevel;\n          } else {\n            flowKey = ctx.flowKey;\n          }\n\n          if (flowKey !== undefined) {\n            // addToBucket returns false on collision (object buckets only) - fail this branch\n            if (!addToBucket(s2, item.bucket, flowKey, node, bucketLevel, sliceKind)) {\n              return; // Collision - don't emit this solution\n            }\n          }\n          emit(s2);\n        }, ctx);\n        return;\n      }\n\n      case 'Collecting': {\n        // <collecting $key:$val in %bucket across ^label> or <collecting $val in @bucket across ^label>\n        // Match the inner pattern; if successful, collect the specified variables into the bucket\n        // The collectExpr specifies WHICH bound variables to collect:\n        // - {key: varName, value: varName} for k:v pairs (%bucket)\n        // - {value: varName} for values only (@bucket)\n        // The labelRef specifies the bucket level (required, no default scope)\n\n        const sliceKind = item.sliceKind;\n        const sigil = sliceKind === 'object' ? '%' : '@';\n\n        matchItem(item.pat, node, path, sol, (s2) => {\n          // The <collecting> directive collects values ONLY when all referenced variables are bound\n          // and the label is available. This allows the test phase (which doesn't have key bindings)\n          // to succeed without collecting anything.\n\n          // Check if label is available\n          if (!s2.labels.has(item.labelRef)) {\n            // Label not set - we're likely in a test phase or not inside a labeled scope\n            // Just emit the solution without collecting\n            emit(s2);\n            return;\n          }\n\n          const labelInfo = s2.labels.get(item.labelRef);\n          const bucketLevel = labelInfo.bucketLevel;\n\n          // Get values from collectExpr by looking up bound variables\n          const collectExpr = item.collectExpr;\n          let collectKey, collectValue;\n\n          // Check if all referenced variables are bound\n          if (collectExpr.key !== undefined && !s2.env.has(collectExpr.key)) {\n            // Key variable not bound - skip collection (likely test phase)\n            emit(s2);\n            return;\n          }\n          if (!s2.env.has(collectExpr.value)) {\n            // Value variable not bound - skip collection (likely test phase)\n            emit(s2);\n            return;\n          }\n\n          if (collectExpr.key !== undefined) {\n            const keyBinding = s2.env.get(collectExpr.key);\n            collectKey = keyBinding.kind === 'scalar' ? keyBinding.value : keyBinding;\n          }\n          const valueBinding = s2.env.get(collectExpr.value);\n          collectValue = valueBinding.kind === 'scalar' ? valueBinding.value : valueBinding;\n\n          if (sliceKind === 'object') {\n            // Object bucket: collect {key: value}\n            if (!addToBucket(s2, item.bucket, collectKey, collectValue, bucketLevel, 'object')) {\n              return; // Collision - don't emit this solution\n            }\n          } else {\n            // Array bucket: collect values only\n            if (!addToBucket(s2, item.bucket, null, collectValue, bucketLevel, 'array')) {\n              return; // Shouldn't happen for array buckets, but be safe\n            }\n          }\n          emit(s2);\n        }, ctx);\n        return;\n      }\n\n      case 'Alt': {\n        if (item.prioritized) {\n          // Prioritized alternation (else semantics): try each alternative in order,\n          // use only the first one that produces any solutions.\n          // Single-pass: track if any solutions emitted, stop on first producing alt.\n          for (const sub of item.alts) {\n            let any = false;\n            matchItem(sub, node, path, sol, (s) => { any = true; emit(s); }, ctx);\n            if (any) return;\n            guard(ctx);\n          }\n          // No alternatives matched\n        } else {\n          // Regular alternation: enumerate all alternatives\n          for (const sub of item.alts) {\n            matchItem(sub, node, path, sol, emit, ctx);\n            guard(ctx);\n          }\n        }\n        return;\n      }\n\n      case 'Look': {\n        // Zero-width assertion.\n        // Positive lookahead: bindings persist; enumerate all solutions if pattern has bindings.\n        // Negative lookahead: bindings never persist.\n        const hasBindings = patternHasBindings(item.pat);\n\n        if (item.neg) {\n          // Negative lookahead: succeed if pattern does NOT match, never commit bindings\n          let matched = false;\n          matchItem(item.pat, node, path, cloneSolution(sol), () => {\n            matched = true;\n          }, ctx);\n          if (!matched) {\n            emit(cloneSolution(sol));\n          }\n        } else if (hasBindings) {\n          // Positive lookahead with bindings: emit all successful solutions\n          matchItem(item.pat, node, path, cloneSolution(sol), (s2) => {\n            emit(s2);\n          }, ctx);\n        } else {\n          // Positive lookahead without bindings: stop at first match (optimization)\n          let matchedSol = null;\n          matchItem(item.pat, node, path, cloneSolution(sol), (s2) => {\n            if (!matchedSol) matchedSol = s2;\n          }, ctx);\n          if (matchedSol) {\n            emit(matchedSol);\n          }\n        }\n        return;\n      }\n\n      case 'SBind': {\n        // Scalar binding: $x or $x:(pattern)\n        // Scalar bindings cannot match sequences - if pattern is Seq, no match\n        if (item.pat.type === 'Seq') {\n          // TODO: emit warning that $x:(seq) is invalid, should use @x:(seq)\n          return; // No match\n        }\n\n        // Match inner pattern, then bind variable to node if successful\n        matchItem(item.pat, node, path, sol, (s2) => {\n          const s3 = cloneSolution(s2);\n          if (bindScalar(s3.env, item.name, node)) {\n            recordScalarSite(s3, item.name, path, node);\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('scalar', item.name, node);\n            }\n            // Add guard expression if present\n            addGuard(s3, item.guard, item.name);\n            // Check guards - prune if any closed guard fails\n            if (!checkGuards(s3)) return;\n            emit(s3);\n          }\n        }, ctx);\n        return;\n      }\n\n      case 'GroupBind': {\n        // Group binding can only appear in array/object contexts\n        // If appearing at top level, treat as error\n        throw new Error('Group binding @x cannot appear at top level');\n      }\n\n      case 'Guarded': {\n        // Guarded pattern: (PATTERN where EXPR)\n        // Match inner pattern, then evaluate guard with _ = matched value\n        matchItem(item.pat, node, path, sol, (s2) => {\n          // Create temp env for guard evaluation: solution bindings + _ = node\n          const guardEnv = new Map(s2.env);\n          guardEnv.set('_', {kind: 'scalar', value: node});\n          try {\n            if (evaluateExpr(item.guard, guardEnv)) {\n              emit(s2);  // emit WITHOUT _ in the env\n            }\n          } catch (e) {\n            // Guard evaluation error - treat as non-match\n          }\n        }, ctx);\n        return;\n      }\n\n      case 'Arr': {\n        if (!Array.isArray(node)) return;\n\n        if (item.label) {\n          // Labeled array: push bucket level for <collecting> directive support\n          const s2 = cloneSolution(sol);\n          pushBucketLevel(s2);\n\n          // Record label with bucket level info\n          if (ctx.flowKey !== undefined) {\n            s2.labels.set(item.label, {key: ctx.flowKey, bucketLevel: s2.bucketStack.length - 1});\n          } else {\n            // No flowKey - record undefined so we can detect it later\n            s2.labels.set(item.label, {key: undefined, bucketLevel: s2.bucketStack.length - 1});\n          }\n\n          // Collect all solutions from matchArray, then finalize and emit\n          const collected = [];\n          matchArray(item.items, node, path, s2, (s3) => {\n            collected.push(s3);\n          }, ctx);\n\n          // Finalize bucket level for all collected solutions\n          if (collected.length > 0) {\n            const finalized = finalizeBucketLevel(collected);\n            for (const s of finalized) emit(s);\n          }\n        } else {\n          // Unlabeled array: no bucket handling needed\n          matchArray(item.items, node, path, sol, emit, ctx);\n        }\n        return;\n      }\n\n      case 'Obj': {\n        if (!isObject(node)) return;\n        // Pass the label to matchObject - it will record the label with the iteration key\n        // when iterating over K:V pairs inside this object\n        matchObject(item.terms, item.spread, node, path, sol, emit, ctx, null, item.label);\n        return;\n      }\n\n      case 'Paren': {\n        matchItem(item.item, node, path, sol, emit, ctx);\n        return;\n      }\n\n      default:\n        throw new Error(`Unknown item type: ${item.type}`);\n    }\n  }\n}\n\n// ------------- Array matching -------------\n\n// Match a single pattern item against array starting at startIdx\n// Calls onMatch(solution, endIndex) for each way it can match\n// This enables proper backtracking for GroupBind and other variable-length patterns\nfunction matchArrayItemWithRange(item, arr, startIdx, path, sol, onMatch, ctx) {\n  guard(ctx);\n\n  switch (item.type) {\n    case 'Spread': {\n      // Spread matches min..max elements (lazy: shortest first for natural ordering)\n      const {min, max} = parseQuantRange(item.quant);\n      const maxK = Math.min(max, arr.length - startIdx);\n      for (let k = min; k <= maxK; k++) {\n        onMatch(cloneSolution(sol), startIdx + k);\n        if (ctx.steps > ctx.maxSteps) break;\n      }\n      return;\n    }\n\n    case 'Seq': {\n      // Sequence: match items in order\n      matchArraySeqWithRange(item.items, arr, startIdx, path, sol, onMatch, ctx);\n      return;\n    }\n\n    case 'Alt': {\n      // Alternation: try each branch\n      let anyEmitted = false;\n      for (const branch of item.alts) {\n        if (item.prioritized && anyEmitted) break;\n        if (ctx.steps > ctx.maxSteps) break;\n        guard(ctx);\n\n        // Unwrap Paren if present\n        let inner = branch;\n        while (inner.type === 'Paren') inner = inner.item;\n\n        matchArrayItemWithRange(inner, arr, startIdx, path, sol, (s, endIdx) => {\n          anyEmitted = true;\n          onMatch(s, endIdx);\n        }, ctx);\n      }\n      return;\n    }\n\n    case 'Quant': {\n      // Quantified: match sub-pattern m..n times\n      const m = item.min !== null ? item.min : 0;\n      const n = item.max !== null ? item.max : Infinity;\n      quantWithRange(item.sub, arr, startIdx, m, n, item.op || '?', path, sol, onMatch, ctx);\n      return;\n    }\n\n    case 'GroupBind': {\n      // Group binding: match inner pattern, capture range\n      matchArrayItemWithRange(item.pat, arr, startIdx, path, sol, (s2, endIdx) => {\n        const slice = arr.slice(startIdx, endIdx);\n        const s3 = cloneSolution(s2);\n        const groupValue = Group.array(...slice);\n        if (bindGroup(s3.env, item.name, groupValue)) {\n          recordGroupSite(s3, item.name, path, startIdx, endIdx, slice);\n          if (ctx.debug?.onBind) {\n            ctx.debug.onBind('group', item.name, groupValue);\n          }\n          onMatch(s3, endIdx);\n        }\n      }, ctx);\n      return;\n    }\n\n    case 'SBind': {\n      // Scalar binding: special handling if inner pattern is Seq\n      if (item.pat.type === 'Seq') {\n        // $x=(seq) matches iff seq matches exactly 1 element\n        matchArraySeqWithRange(item.pat.items, arr, startIdx, path, sol, (s2, endIdx) => {\n          if (endIdx - startIdx === 1) {\n            const s3 = cloneSolution(s2);\n            const element = arr[startIdx];\n            if (bindScalar(s3.env, item.name, element)) {\n              recordScalarSite(s3, item.name, [...path, startIdx], element);\n              if (ctx.debug?.onBind) {\n                ctx.debug.onBind('scalar', item.name, element);\n              }\n              addGuard(s3, item.guard, item.name);\n              if (checkGuards(s3)) {\n                onMatch(s3, endIdx);\n              }\n            }\n          }\n        }, ctx);\n        return;\n      }\n      // Fall through to default single-element handling\n      if (startIdx < arr.length) {\n        matchItem(item, arr[startIdx], [...path, startIdx], sol, (s2) => {\n          onMatch(s2, startIdx + 1);\n        }, ctx);\n      }\n      return;\n    }\n\n    case 'Look': {\n      // Lookahead: zero-width assertion (doesn't consume elements)\n      const remainingGroup = arr.slice(startIdx);\n      const patternItems = [item.pat, {type: 'Spread', quant: null}];\n\n      if (item.neg) {\n        let matched = false;\n        matchArray(patternItems, remainingGroup, [...path, startIdx], cloneSolution(sol), () => {\n          matched = true;\n        }, ctx);\n        if (!matched) {\n          onMatch(sol, startIdx);\n        }\n      } else {\n        const hasBindings = patternHasBindings(item.pat);\n        if (hasBindings) {\n          matchArray(patternItems, remainingGroup, [...path, startIdx], sol, (s2) => {\n            onMatch(s2, startIdx);\n          }, ctx);\n        } else {\n          let matchedSol = null;\n          matchArray(patternItems, remainingGroup, [...path, startIdx], sol, (s2) => {\n            if (!matchedSol) matchedSol = s2;\n          }, ctx);\n          if (matchedSol) {\n            onMatch(matchedSol, startIdx);\n          }\n        }\n      }\n      return;\n    }\n\n    // Single-element patterns: delegate to matchItem\n    default: {\n      if (startIdx < arr.length) {\n        matchItem(item, arr[startIdx], [...path, startIdx], sol, (s2) => {\n          onMatch(s2, startIdx + 1);\n        }, ctx);\n      }\n      return;\n    }\n  }\n}\n\n// Match a sequence of items against array starting at startIdx\n// Calls onMatch(solution, endIndex) for each way the sequence can match\nfunction matchArraySeqWithRange(items, arr, startIdx, path, sol, onMatch, ctx) {\n  function step(ixItem, ixArr, sIn) {\n    guard(ctx);\n    if (ixItem === items.length) {\n      onMatch(sIn, ixArr);\n      return;\n    }\n    matchArrayItemWithRange(items[ixItem], arr, ixArr, path, sIn, (s2, endIdx) => {\n      step(ixItem + 1, endIdx, s2);\n    }, ctx);\n  }\n  step(0, startIdx, sol);\n}\n\n// Quantifier matching with range tracking\n// Matches sub-pattern m..n times, calls onMatch(sol, endIdx) for each match\nfunction quantWithRange(sub, arr, startIdx, m, n, op, path, sol, onMatch, ctx) {\n  const maxRep = Math.min(n, arr.length - startIdx);\n  const isPossessive = op === '++' || op === '*+' || op === '?+';\n\n  // DP-like expansion to avoid deep recursion\n  let frontier = [{idx: startIdx, sol: cloneSolution(sol), reps: 0}];\n\n  // First reach minimum reps\n  for (let r = 0; r < m; r++) {\n    const next = [];\n    for (const st of frontier) {\n      if (st.idx >= arr.length) continue;\n      matchItem(sub, arr[st.idx], [...path, st.idx], st.sol, (s2) => {\n        next.push({idx: st.idx + 1, sol: s2, reps: st.reps + 1});\n      }, ctx);\n    }\n    frontier = next;\n    if (!frontier.length) return; // cannot satisfy minimum\n  }\n\n  if (isPossessive) {\n    // Greedy, no backtracking: consume as many as possible\n    for (let r = m; r < maxRep; r++) {\n      const grown = [];\n      for (const st of frontier) {\n        if (st.idx >= arr.length) continue;\n        matchItem(sub, arr[st.idx], [...path, st.idx], st.sol, (s2) => {\n          grown.push({idx: st.idx + 1, sol: s2, reps: st.reps + 1});\n        }, ctx);\n      }\n      if (!grown.length) break;\n      frontier = grown;\n    }\n    for (const st of frontier) {\n      onMatch(st.sol, st.idx);\n    }\n  } else {\n    // Non-possessive: collect all lengths, emit longest first (greedy)\n    const allFrontiers = [frontier];\n    for (let r = m; r < maxRep; r++) {\n      const grown = [];\n      for (const st of frontier) {\n        if (st.idx >= arr.length) continue;\n        matchItem(sub, arr[st.idx], [...path, st.idx], st.sol, (s2) => {\n          grown.push({idx: st.idx + 1, sol: s2, reps: st.reps + 1});\n        }, ctx);\n      }\n      if (!grown.length) break;\n      frontier = grown;\n      allFrontiers.push(frontier);\n    }\n    // Emit longest first (greedy)\n    for (let i = allFrontiers.length - 1; i >= 0; i--) {\n      for (const st of allFrontiers[i]) {\n        onMatch(st.sol, st.idx);\n      }\n    }\n  }\n}\n\n// Entry point for array matching\n// Matches items against the entire array (with trailing spread optimization)\nfunction matchArray(items, arr, path, sol, emit, ctx) {\n  // Optimization: trailing bare spread means \"consume rest\" - handle in O(1)\n  const last = items[items.length - 1];\n  const hadTrailingSpread = last && last.type === 'Spread' && last.quant == null;\n  if (hadTrailingSpread) {\n    items = items.slice(0, -1);\n  }\n\n  // Match using range-tracking, then filter for full consumption\n  matchArraySeqWithRange(items, arr, 0, path, sol, (s, endIdx) => {\n    // Accept if: trailing spread (any end position) or exact match (consumed all)\n    if (hadTrailingSpread || endIdx === arr.length) {\n      emit(cloneSolution(s));\n    }\n  }, ctx);\n}\n\n// ------------- Object matching -------------\n\nfunction matchObject(terms, spread, obj, path, sol, emit, ctx, outMatchedKeys = null, objLabel = null) {\n  guard(ctx);\n\n  const DEBUG = false; // Set to true for debugging\n\n  // Process each OTerm sequentially, threading solutions through\n  // Each solution tracks:\n  // - testedKeys: keys that were successfully matched (for backward compat)\n  // - coveredKeys: keys that match any K pattern (for remainder calculation)\n  let solutions = [{sol: cloneSolution(sol), testedKeys: new Set(), coveredKeys: new Set()}];\n\n  // Push bucket level only for labeled objects (to support <collecting> directive)\n  // Each `each` clause will push its own level for -> operator\n  if (objLabel) {\n    pushBucketLevel(solutions[0].sol);\n  }\n\n  if (DEBUG) console.log(`[matchObject] obj keys:`, Object.keys(obj), `terms:`, terms.length);\n\n  for (const term of terms) {\n    // Handle group bindings: @var=(pattern) or @var=(remainder)\n    if (term.type === 'GroupBind') {\n      const isSpread = term.pat.type === 'Spread';\n      const next = [];\n\n      for (const state of solutions) {\n        const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n        if (isSpread) {\n          // @var=(remainder) - capture residual keys\n          // Remainder is keys NOT covered by any key pattern K\n          const residualKeys = Object.keys(obj).filter(k => !coveredKeys.has(k));\n          const residualObj = {};\n          for (const k of residualKeys) {\n            residualObj[k] = obj[k];\n          }\n\n          const s2 = cloneSolution(s0);\n          const groupValue = Group.object(residualObj);\n          if (bindGroup(s2.env, term.name, groupValue)) {\n            if (!s2.sites.has(term.name)) {\n              s2.sites.set(term.name, []);\n            }\n            s2.sites.get(term.name).push({\n              kind: 'group',\n              path: [...path],\n              keys: residualKeys,\n              valueRefs: residualObj\n            });\n            if (ctx.debug?.onBind) {\n              ctx.debug.onBind('group', term.name, groupValue);\n            }\n            // Preserve both testedKeys and coveredKeys for this branch\n            next.push({sol: s2, testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n          }\n        } else {\n          // @var=(pattern) - recursively match pattern, collect matched keys\n          if (term.pat.type !== 'OGroup') {\n            throw new Error(`GroupBind in object context expects OGroup or Spread pattern, got ${term.pat.type}`);\n          }\n\n          const matchedKeys = new Set();\n          matchObject(\n            term.pat.groups,\n            null,\n            obj,\n            path,\n            s0,\n            (s2) => {\n              // Bind the matched keys as a group\n              const capturedObj = {};\n              for (const k of matchedKeys) {\n                capturedObj[k] = obj[k];\n              }\n\n              const s3 = cloneSolution(s2);\n              const groupValue = Group.object(capturedObj);\n              if (bindGroup(s3.env, term.name, groupValue)) {\n                if (!s3.sites.has(term.name)) {\n                  s3.sites.set(term.name, []);\n                }\n                s3.sites.get(term.name).push({\n                  kind: 'group',\n                  path: [...path],\n                  keys: Array.from(matchedKeys),\n                  valueRefs: capturedObj\n                });\n                if (ctx.debug?.onBind) {\n                  ctx.debug.onBind('group', term.name, groupValue);\n                }\n                // Mark matched keys as tested and covered in this branch\n                const newTestedKeys = new Set(testedKeys);\n                const newCoveredKeys = new Set(coveredKeys);\n                for (const k of matchedKeys) {\n                  newTestedKeys.add(k);\n                  newCoveredKeys.add(k);\n                }\n                next.push({sol: s3, testedKeys: newTestedKeys, coveredKeys: newCoveredKeys});\n              }\n            },\n            ctx,\n            matchedKeys  // Collect matched keys\n          );\n        }\n      }\n      solutions = next;\n      continue;\n    }\n\n    // Handle OGroup (parenthesized O_BODY)\n    if (term.type === 'OGroup') {\n      // Process grouped terms - just flatten them into the main sequence\n      const next = [];\n      for (const state of solutions) {\n        const {coveredKeys = new Set()} = state;\n        const groupMatchedKeys = new Set();\n        matchObject(term.groups, null, obj, path, state.sol, (s2) => {\n          // Update covered keys from the group\n          const newCoveredKeys = new Set(coveredKeys);\n          for (const k of groupMatchedKeys) {\n            newCoveredKeys.add(k);\n          }\n          next.push({sol: s2, testedKeys: new Set(state.testedKeys), coveredKeys: newCoveredKeys});\n        }, ctx, groupMatchedKeys);\n      }\n      solutions = next;\n      continue;\n    }\n\n    // Handle object lookaheads\n    if (term.type === 'OLook') {\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n\n        // Special case: (?!..) means \"no residual keys\" (closed object assertion)\n        // This is an optimization of the desugaring (?!((?!OT1)(?!OT2)...(?!OTn)_=_))\n        if (term.neg && term.pat.type === 'Spread') {\n          const residualKeys = Object.keys(obj).filter(k => !coveredKeys.has(k));\n          const noResiduals = residualKeys.length === 0;\n          if (noResiduals) {\n            // No residual keys - negative lookahead succeeds\n            next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n          }\n          // If there are residuals, negative lookahead fails (don't push to next)\n        } else if (term.neg) {\n          // Negative lookahead: succeed if pattern does NOT match, never commit bindings\n          let matched = false;\n          const lookaheadTestedKeys = new Set(testedKeys);\n          matchObjectGroup(term.pat, obj, path, cloneSolution(s0), () => {\n            matched = true;\n          }, ctx, lookaheadTestedKeys);\n          if (!matched) {\n            next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n          }\n        } else {\n          // Positive lookahead: bindings escape\n          // If pattern has bindings, enumerate all solutions; otherwise stop at first (optimization)\n          const hasBindings = patternHasBindings(term.pat);\n          const lookaheadTestedKeys = new Set(testedKeys);\n\n          if (hasBindings) {\n            // Enumerate all solutions\n            matchObjectGroup(term.pat, obj, path, cloneSolution(s0), (s2) => {\n              next.push({sol: s2, testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n            }, ctx, lookaheadTestedKeys);\n          } else {\n            // Optimization: stop at first match when no bindings\n            let matchedSol = null;\n            matchObjectGroup(term.pat, obj, path, cloneSolution(s0), (s2) => {\n              if (!matchedSol) matchedSol = s2;\n            }, ctx, lookaheadTestedKeys);\n            if (matchedSol) {\n              next.push({sol: matchedSol, testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n            }\n          }\n        }\n      }\n      solutions = next;\n      continue;\n    }\n\n    if (term.type !== 'OTerm') {\n      throw new Error(`Expected OTerm, GroupBind, OLook, or OGroup, got ${term.type}`);\n    }\n\n    // Bucket level is pushed once at object start, shared by all terms\n\n    // Slice-based semantics:\n    // - K:V         = slice exists (#{1,}), bad entries allowed\n    // - K:V else !  = slice exists (#{1,}), no bad entries (strong semantics)\n    // - K:V?        = slice may be empty (#{0,}), bad entries allowed\n    // - K:V else !? = slice may be empty (#{0,}), no bad entries\n    //\n    // Where:\n    // - slice = keys where k~K AND v~V\n    // - bad = keys where k~K AND NOT(v~V)\n    // - covered = all keys where k~K (for remainder calculation)\n\n    const isStrong = term.strong === true;\n    const isOptional = term.optional === true;\n\n    // For strong terms (each clauses), push a bucket level for this clause's scope\n    // The -> operator will collect into this level\n    if (isStrong) {\n      for (const state of solutions) {\n        pushBucketLevel(state.sol);\n      }\n    }\n\n    // For each solution, process the term\n    let next = [];\n    for (const state of solutions) {\n      const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n\n      // Special handling for RootKey (leading .. in path like {..password:$x})\n      if (term.key.type === 'RootKey') {\n        // Start breadcrumb navigation from the object itself, not from a matched key\n        const s1 = cloneSolution(s0);\n        navigateBreadcrumbs(\n          term.breadcrumbs,\n          obj,\n          path,\n          s1,\n          (finalNode, finalPath, s2) => {\n            matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n              next.push({sol: s3, testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n            }, ctx);\n          },\n          ctx\n        );\n        continue;\n      }\n\n      // Find all keys matching the key pattern K\n      const matchingKeys = objectKeysMatching(obj, term.key, s0.env);\n      if (DEBUG) console.log(`[matchObject] term.key:`, term.key, `matched keys:`, matchingKeys);\n\n      // All matching keys are \"covered\" for remainder purposes\n      const newCoveredKeys = new Set(coveredKeys);\n      for (const k of matchingKeys) {\n        newCoveredKeys.add(k);\n      }\n\n      // Partition keys into slice (v~V) and bad (NOT v~V)\n      // Must navigate breadcrumbs before testing value!\n      const sliceKeys = [];\n      const badKeys = [];\n\n      for (const k of matchingKeys) {\n        // Test if value matches V (after navigating breadcrumbs)\n        let valueMatches = false;\n\n        // Create a test solution with the label set (if this object has a label)\n        // This is needed because the value test may involve Flows that reference the label\n        const testSol = cloneSolution(s0);\n        if (objLabel) {\n          testSol.labels.set(objLabel, {key: k, bucketLevel: testSol.bucketStack.length - 1});\n        }\n\n        if (term.breadcrumbs && term.breadcrumbs.length > 0) {\n          // Navigate breadcrumbs first, then test value at final node\n          navigateBreadcrumbs(\n            term.breadcrumbs,\n            obj[k],\n            [...path, k],\n            testSol,\n            (finalNode, finalPath, s2) => {\n              matchItem(term.val, finalNode, finalPath, s2, () => {\n                valueMatches = true;\n              }, ctx);\n            },\n            ctx\n          );\n        } else {\n          // No breadcrumbs - test value directly\n          matchItem(term.val, obj[k], [...path, k], testSol, () => {\n            valueMatches = true;\n          }, ctx);\n        }\n\n        if (valueMatches) {\n          sliceKeys.push(k);\n        } else {\n          badKeys.push(k);\n        }\n      }\n\n      if (DEBUG) console.log(`[matchObject] slice:`, sliceKeys, `bad:`, badKeys);\n\n      // Apply constraints based on operator, quantifier, and optional flag\n      //\n      // Semantics (from README):\n      //   K:V         => slice #{1,} bad #{0,}  (at least one matching k,v)\n      //   K:V else !  => slice #{1,} bad #{0}   (at least one, no bad entries)\n      //   K:V?        => slice #{0,} bad #{0,}  (optional, no assertion)\n      //   K:V else !? => slice #{0,} bad #{0}   (optional, no bad entries)\n      //\n      // Explicit quantifier like #{2,4} overrides the default slice bounds.\n\n      // 1. Slice count check\n      const sliceCount = sliceKeys.length;\n      const quant = term.quant;\n      // Default: #{1,} unless optional (#{0,})\n      const minSlice = quant ? quant.min : (isOptional ? 0 : 1);\n      const maxSlice = quant ? quant.max : null; // null means unbounded\n\n      if (sliceCount < minSlice) {\n        if (DEBUG) console.log(`[matchObject] failed: slice count ${sliceCount} < min ${minSlice}`);\n        continue;\n      }\n      if (maxSlice !== null && sliceCount > maxSlice) {\n        if (DEBUG) console.log(`[matchObject] failed: slice count ${sliceCount} > max ${maxSlice}`);\n        continue;\n      }\n\n      // 2. Strong semantics check (else !) - bad #{0}\n      if (isStrong && badKeys.length > 0) {\n        if (DEBUG) console.log(`[matchObject] failed: bad entries exist with strong semantics (else !)`);\n        continue; // Skip this solution - bad entries forbidden\n      }\n\n      // Constraints passed! Now enumerate solutions from slice\n      if (sliceKeys.length > 0) {\n        // Existential branching: each slice key creates an independent solution\n        for (const k of sliceKeys) {\n          const s1 = cloneSolution(s0);\n          const newTestedKeys = new Set(testedKeys);\n          newTestedKeys.add(k);\n\n          // If this object has a label, record the current iteration key and bucket level\n          // This allows inner Flows with <^label> to use this key and add to this bucket level\n          if (objLabel) {\n            s1.labels.set(objLabel, {key: k, bucketLevel: s1.bucketStack.length - 1});\n          }\n\n          // Bind key variables\n          if (!bindKeyVariables(term.key, k, s1, path)) {\n            continue; // Binding failed\n          }\n\n          // Navigate breadcrumbs and match value to get bindings\n          // Set flowKey for Flow operator (bucket collection)\n          const savedFlowKey = ctx.flowKey;\n          ctx.flowKey = k;\n          navigateBreadcrumbs(\n            term.breadcrumbs,\n            obj[k],\n            [...path, k],\n            s1,\n            (finalNode, finalPath, s2) => {\n              matchItem(term.val, finalNode, finalPath, s2, (s3) => {\n                next.push({sol: s3, testedKeys: newTestedKeys, coveredKeys: newCoveredKeys});\n              }, ctx);\n            },\n            ctx\n          );\n          ctx.flowKey = savedFlowKey;\n        }\n      } else {\n        // No slice entries, but constraints passed (must be optional)\n        // Continue with unchanged solution but updated coverage\n        next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys), coveredKeys: newCoveredKeys});\n      }\n    }\n\n    solutions = next;\n\n    // For strong terms (each clauses), finalize this clause's bucket level\n    // This merges collected entries, pops the level, and binds bucket variables\n    if (isStrong && solutions.length > 0) {\n      solutions = finalizeBucketLevel(solutions);\n    }\n\n    if (!solutions.length) break;\n  }\n\n  // Handle spread: bare '%'/'remainder' or '@var=(%)' or '(?!%)' or '$'\n  // Remainder is based on coveredKeys (keys matching any key pattern K), not testedKeys\n  if (spread && solutions.length > 0) {\n    if (spread.type === 'OLook') {\n      // (?!%) - assert no residual keys\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n\n        // Special case: (?!%) means \"no residual keys\" (closed object assertion)\n        if (spread.neg && spread.pat.type === 'Spread') {\n          const residualKeys = Object.keys(obj).filter(k => !coveredKeys.has(k));\n          const noResiduals = residualKeys.length === 0;\n          if (noResiduals) {\n            // No residual keys - negative lookahead succeeds\n            next.push({sol: cloneSolution(s0), testedKeys: new Set(testedKeys), coveredKeys: new Set(coveredKeys)});\n          }\n          // If there are residuals, negative lookahead fails (don't push to next)\n        } else {\n          // General lookahead on remainder (not yet fully implemented)\n          throw new Error('General lookahead on remainder not yet implemented');\n        }\n      }\n      solutions = next;\n    } else if (spread.type === 'GroupBind') {\n      // @var=(%) - bind residual keys to group variable\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n        const residualKeys = Object.keys(obj).filter(k => !coveredKeys.has(k));\n\n        // Check quantifier constraints from the spread pattern\n        let {min, max} = parseQuantRange(spread.pat?.quant);\n        if (!spread.pat?.quant) {\n          // @var=(%) requires at least one key by default\n          min = 1;\n          max = Infinity;\n        } else if (spread.pat.quant === '?') {\n          // @var=(%?) allows empty remainder and unlimited keys\n          min = 0;\n          max = Infinity;\n        }\n        if (residualKeys.length < min || residualKeys.length > max) {\n          continue;\n        }\n\n        const residualObj = {};\n        for (const k of residualKeys) {\n          residualObj[k] = obj[k];\n        }\n\n        const s2 = cloneSolution(s0);\n        const groupValue = Group.object(residualObj);\n        if (bindGroup(s2.env, spread.name, groupValue)) {\n          if (!s2.sites.has(spread.name)) {\n            s2.sites.set(spread.name, []);\n          }\n          s2.sites.get(spread.name).push({\n            kind: 'group',\n            path: [...path],\n            keys: residualKeys,\n            valueRefs: residualObj\n          });\n          if (ctx.debug?.onBind) {\n            ctx.debug.onBind('group', spread.name, groupValue);\n          }\n          next.push({sol: s2, testedKeys, coveredKeys});\n        }\n      }\n      solutions = next;\n    } else {\n      // Bare '%' or '$' - just check count per branch\n      const next = [];\n      for (const state of solutions) {\n        const {sol: s0, testedKeys, coveredKeys = new Set()} = state;\n        let {min, max} = parseQuantRange(spread.quant);\n        // Handle $ which comes through as {min:0, max:0}\n        // Handle bare % which requires nonempty (min:1)\n        if (!spread.quant) min = 1;  // Bare '%' requires nonempty\n        const uncoveredCount = Object.keys(obj).filter(k => !coveredKeys.has(k)).length;\n        if (uncoveredCount >= min && (max === null || uncoveredCount <= max)) {\n          next.push(state);\n        }\n      }\n      solutions = next;\n    }\n  }\n\n  // Finalize bucket level for labeled objects (to support <collecting> directive)\n  // Each `each` clause finalizes its own level separately\n  if (objLabel && solutions.length > 0) {\n    solutions = finalizeBucketLevel(solutions);\n  }\n\n  // Report matched keys to caller if requested (collect from all branches)\n  if (outMatchedKeys) {\n    for (const state of solutions) {\n      for (const k of state.testedKeys) {\n        outMatchedKeys.add(k);\n      }\n    }\n  }\n\n  for (const state of solutions) emit(state.sol);\n}\n\n/**\n * matchObjectGroup - Match a single O_GROUP pattern against an object\n * Used by lookaheads and other contexts where we need to match one group in isolation\n */\nfunction matchObjectGroup(group, obj, path, sol, emit, ctx, testedKeys = new Set()) {\n  guard(ctx);\n\n  // Handle different group types\n  if (group.type === 'OTerm') {\n    // Single object term K:V or K?:V\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'OGroup') {\n    // Group of groups (K1:V1 K2:V2 ...)\n    matchObject(group.groups, null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'GroupBind') {\n    // @var=(pattern)\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'OLook') {\n    // Nested lookahead\n    matchObject([group], null, obj, path, sol, emit, ctx, testedKeys);\n  } else if (group.type === 'Spread') {\n    // Bare .. - match if there are residual keys\n    matchObject([], group, obj, path, sol, emit, ctx, testedKeys);\n  } else {\n    throw new Error(`Unexpected group type in matchObjectGroup: ${group.type}`);\n  }\n}\n\nfunction navigateBreadcrumbs(breadcrumbs, startNode, basePath, sol, emit, ctx) {\n  guard(ctx);\n\n  if (!breadcrumbs || breadcrumbs.length === 0) {\n    emit(startNode, basePath, sol);\n    return;\n  }\n\n  const bc = breadcrumbs[0];\n  const rest = breadcrumbs.slice(1);\n\n  // Navigate the breadcrumb (no quantifiers in v5)\n  navigateSingleBreadcrumb(bc, rest, startNode, basePath, sol, emit, ctx);\n}\n\nfunction navigateSingleBreadcrumb(bc, restBreadcrumbs, node, path, sol, emit, ctx) {\n  if (bc.kind === 'skip') {\n    // ..key navigation - skip any number of levels to find key\n    if (!isObject(node)) return;\n\n    navigateSkipLevels(bc.key, restBreadcrumbs, node, path, sol, emit, ctx);\n  } else if (bc.kind === 'dot') {\n    // .key navigation on objects\n    if (!isObject(node)) return;\n\n    // Special handling for $name binding in key position\n    if (bc.key.type === 'SBind') {\n      const keyPattern = bc.key.pat;\n      const fast = fastBoundKey(bc.key, sol.env, keyMatches, k => node.hasOwnProperty(k));\n\n      if (fast !== undefined) {\n        // Fast path: variable already bound, use its value\n        if (fast.length === 0) return; // Failed validation\n        const boundKey = fast[0];\n        navigateBreadcrumbs(restBreadcrumbs, node[boundKey], [...path, boundKey], sol, emit, ctx);\n        return;\n      }\n\n      // Not bound yet - enumerate all matching keys and try to bind\n      for (const k of Object.keys(node)) {\n        if (!keyMatches(keyPattern, k)) continue;\n        const s2 = cloneSolution(sol);\n        if (bindScalar(s2.env, bc.key.name, k)) {\n          recordScalarSite(s2, bc.key.name, path, k);\n          navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], s2, emit, ctx);\n        }\n      }\n    } else {\n      // Regular key pattern\n      const keys = objectKeysMatching(node, bc.key, sol.env);\n      for (const k of keys) {\n        navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], sol, emit, ctx);\n      }\n    }\n  } else if (bc.kind === 'bracket') {\n    // [key] navigation on arrays\n    if (!Array.isArray(node)) return;\n\n    // bc.key could be:\n    // - Lit (number): specific index\n    // - Any (_): any index\n    // - SBind ($x): bind index variable\n    // - Pattern: match index as string/number\n\n    if (bc.key.type === 'Lit') {\n      const idx = bc.key.value;\n      if (Number.isInteger(idx) && idx in node) {\n        navigateBreadcrumbs(restBreadcrumbs, node[idx], [...path, idx], sol, emit, ctx);\n      }\n    } else if (bc.key.type === 'Any') {\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], sol, emit, ctx);\n        }\n      }\n    } else if (bc.key.type === 'SBind') {\n      const idxPattern = bc.key.pat;\n      const fast = fastBoundKey(bc.key, sol.env, keyMatches, i => Number.isInteger(i) && i in node);\n\n      if (fast !== undefined) {\n        // Fast path: variable already bound, use its value\n        if (fast.length === 0) return; // Failed validation\n        const idx = fast[0];\n        navigateBreadcrumbs(restBreadcrumbs, node[idx], [...path, idx], sol, emit, ctx);\n        return;\n      }\n\n      // Not bound yet - enumerate indices and try to bind\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          const s2 = cloneSolution(sol);\n          if (bindScalar(s2.env, bc.key.name, i)) {\n            recordScalarSite(s2, bc.key.name, path, i);\n            navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], s2, emit, ctx);\n          }\n        }\n      }\n    } else {\n      // General pattern on index\n      for (let i = 0; i < node.length; i++) {\n        if (i in node) {\n          matchItem(bc.key, i, path, sol, (s2) => {\n            navigateBreadcrumbs(restBreadcrumbs, node[i], [...path, i], s2, emit, ctx);\n          }, ctx);\n        }\n      }\n    }\n  }\n}\n\nfunction navigateSkipLevels(keyPattern, restBreadcrumbs, node, path, sol, emit, ctx) {\n  // ..key navigation: recursively search through tree to find matching keys at any depth\n  guard(ctx);\n\n  // Handle arrays: descend into each element\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      navigateSkipLevels(keyPattern, restBreadcrumbs, node[i], [...path, i], sol, emit, ctx);\n    }\n    return;\n  }\n\n  if (!isObject(node)) return;\n\n  // Try to match key at current level\n  // Handle $name binding in key position\n  if (keyPattern.type === 'SBind') {\n    const fast = fastBoundKey(keyPattern, sol.env, keyMatches, k => node.hasOwnProperty(k));\n\n    if (fast !== undefined) {\n      // Fast path: variable already bound, use its value\n      if (fast.length > 0) {\n        const boundKey = fast[0];\n        if (node.hasOwnProperty(boundKey)) {\n          navigateBreadcrumbs(restBreadcrumbs, node[boundKey], [...path, boundKey], sol, emit, ctx);\n        }\n      }\n    } else {\n      // Not bound yet - enumerate all matching keys and try to bind\n      const pattern = keyPattern.pat;\n      for (const k of Object.keys(node)) {\n        if (!keyMatches(pattern, k)) continue;\n        const s2 = cloneSolution(sol);\n        if (bindScalar(s2.env, keyPattern.name, k)) {\n          recordScalarSite(s2, keyPattern.name, path, k);\n          navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], s2, emit, ctx);\n        }\n      }\n    }\n  } else {\n    // Regular key pattern (no variable binding)\n    const keys = objectKeysMatching(node, keyPattern, sol.env);\n    for (const k of keys) {\n      navigateBreadcrumbs(restBreadcrumbs, node[k], [...path, k], sol, emit, ctx);\n    }\n  }\n\n  // Recurse into nested structures to find key at deeper levels\n  for (const k of Object.keys(node)) {\n    const child = node[k];\n    // navigateSkipLevels handles both objects and arrays at its top\n    if (isObject(child) || Array.isArray(child)) {\n      navigateSkipLevels(keyPattern, restBreadcrumbs, child, [...path, k], sol, emit, ctx);\n    }\n  }\n}\n\n// ------------- Helpers -------------\n\n/**\n * fastBoundKey(pat, env, validate, exists) -> undefined | [] | [key]\n *\n * If pat is SBind($name, inner) AND $name is already bound (scalar) AND\n * inner is not itself a binding, then:\n *   - if validate(inner, boundValue) fails, return [] (fast failure)\n *   - else if exists(boundValue) is true, return [boundValue] (fast success)\n *   - else return [] (not present)\n *\n * If no fast path applies, returns undefined to signal caller to fall back.\n *\n * This encodes the \"{ a=$x, $x=$y } \u21D2 second term O(1)\" idea once,\n * reused by object keys and array indices.\n */\nfunction fastBoundKey(pat, env, validate, exists) {\n  if (!pat || pat.type !== 'SBind') return undefined;\n  const binding = env.get(pat.name);\n  if (!binding || binding.kind !== 'scalar') return undefined;\n\n  // If inner pattern is itself a binding, we need normal binding logic\n  if (pat.pat && (pat.pat.type === 'SBind' || pat.pat.type === 'GroupBind')) {\n    return undefined;\n  }\n\n  const key = binding.value;\n  if (!validate(pat.pat, key)) return [];\n  return exists(key) ? [key] : [];\n}\n\nfunction objectKeysMatching(obj, keyPat, env) {\n  const fast = fastBoundKey(keyPat, env, keyMatches, k => obj.hasOwnProperty(k));\n  if (fast !== undefined) return fast;\n\n  // Fall back: enumerate all matching keys\n  const out = [];\n  for (const k of Object.keys(obj)) {\n    if (keyMatches(keyPat, k)) out.push(k);\n  }\n  return out;\n}\n\nfunction keyMatches(pat, key) {\n  switch (pat.type) {\n    case 'Any':\n      return true;\n    case 'TypedAny':\n      // Keys are always strings, so _string matches, _number/_boolean never match\n      return pat.kind === 'string';\n    case 'Lit':\n      return Object.is(String(key), String(pat.value));\n    case 'StringPattern':\n      return pat.matchFn(String(key));\n    case 'SBind':\n      // Key pattern with binding: check inner pattern constraint\n      if (pat.pat) {\n        return keyMatches(pat.pat, key);\n      }\n      return true;  // $x with no constraint matches any key\n    case 'Alt':\n      // Alternation: key matches if any alternative matches\n      return pat.alts.some(alt => keyMatches(alt, key));\n    default:\n      return false;\n  }\n}\n\n// Bind variables from a key pattern (handles SBind and alternations)\n// Returns true if binding succeeded, false if it failed\nfunction bindKeyVariables(keyPat, key, sol, path) {\n  switch (keyPat.type) {\n    case 'SBind':\n      // Direct binding: $x or $x:(pattern)\n      if (!bindScalar(sol.env, keyPat.name, key)) {\n        return false;\n      }\n      recordScalarSite(sol, keyPat.name, path, key);\n      // Add guard expression if present\n      addGuard(sol, keyPat.guard, keyPat.name);\n      // Check guards - prune if any closed guard fails\n      if (!checkGuards(sol)) return false;\n      return true;\n\n    case 'Alt':\n      // Alternation: try each alternative that matches AND whose bindings succeed\n      for (const alt of keyPat.alts) {\n        if (!keyMatches(alt, key)) continue;\n        // Clone solution to avoid corrupting state if binding fails\n        const snapshot = cloneSolution(sol);\n        if (bindKeyVariables(alt, key, snapshot, path)) {\n          // Binding succeeded - commit snapshot back to sol\n          sol.env = snapshot.env;\n          sol.sites = snapshot.sites;\n          return true;\n        }\n        // Binding failed (e.g., unification conflict) - try next alternative\n      }\n      return false; // No alternative matched with successful bindings\n\n    default:\n      // No variables to bind (Lit, Re, Any, etc.)\n      return true;\n  }\n}\n\nfunction isObject(x) {\n  return x !== null && typeof x === 'object' && !Array.isArray(x);\n}\n\nfunction parseQuantRange(quant) {\n  if (!quant) return {min: 0, max: Infinity};\n\n  // If quant is already an object with min/max (from parser), use it directly\n  // Parser now emits Infinity for unbounded max (not null)\n  if (typeof quant === 'object' && 'min' in quant && 'max' in quant) {\n    return {min: quant.min, max: quant.max};\n  }\n\n  // quant could be: '?', '+', '*', '{m}', '{m,}', '{m,n}'\n  if (quant === '?') return {min: 0, max: 1};\n  if (quant === '+') return {min: 1, max: Infinity};\n  if (quant === '*') return {min: 0, max: Infinity};\n\n  // Lazy/possessive variants\n  if (quant === '??') return {min: 0, max: 1};\n  if (quant === '+?') return {min: 1, max: Infinity};\n  if (quant === '*?') return {min: 0, max: Infinity};\n  if (quant === '++') return {min: 1, max: Infinity};\n  if (quant === '*+') return {min: 0, max: Infinity};\n\n  // Range quantifiers: {m}, {m,}, {m,n}\n  const rangeMatch = quant.match(/^\\{(\\d+)(?:,(\\d+)?)?\\}$/);\n  if (rangeMatch) {\n    const m = parseInt(rangeMatch[1], 10);\n    const n = rangeMatch[2] !== undefined ? parseInt(rangeMatch[2], 10) : m;\n    return {min: m, max: n};\n  }\n\n  return {min: 0, max: Infinity};\n}\n\nfunction guard(ctx) {\n  ctx.steps++;\n  if (ctx.steps > ctx.maxSteps) throw new Error('pattern too ambiguous (step budget exceeded)');\n}\n", "// tendril-api.js \u2014 public API vNext (engine-compatible)\n//\n// NOTE:\n// - Group is kept for internal use and for tendril-engine.js.\n//   Users never need to construct Group instances.\n// - Replacement semantics are determined by the *pattern/site kind*:\n//     * scalar sites ($x) treat replacement as a single value\n//     * group sites (@x) treat replacement as a slice/splice (array elements or object props)\n// - $0 (the automatic whole-match binding) is used internally for\n//   locating/replacing, but hidden from user-visible bindings by default.\n\nimport {parsePattern} from './tendril-parser.js';\nimport {\n  match as engineMatch,\n  scan as engineScan,\n  matchExists as engineMatchExists,\n  scanExists as engineScanExists,\n  scanFirst as engineScanFirst,\n} from './tendril-engine.js';\nimport {deepEqual} from './tendril-util.js';\n\n// ------------------- Compile & cache -------------------\n\nconst CACHE_MAX = 64;\nconst _cache = new Map(); // pattern -> ast (LRU-ish)\n\nfunction compile(pattern) {\n  if (pattern && pattern.type) return pattern; // already compiled AST\n  if (_cache.has(pattern)) {\n    const hit = _cache.get(pattern);\n    _cache.delete(pattern);\n    _cache.set(pattern, hit);\n    return hit;\n  }\n  let ast = parsePattern(String(pattern));\n  let isSlicePattern = false;\n\n  // Check for slice patterns and desugar them\n  if (ast.type === 'SlicePattern') {\n    isSlicePattern = true;\n    if (ast.kind === 'object') {\n      // @{ K:V } \u2192 { @0=(K:V) }\n      ast = {\n        type: 'Obj',\n        terms: [{type: 'GroupBind', name: '0', pat: ast.content}],\n        spread: null\n      };\n    } else if (ast.kind === 'array') {\n      // @[ A B ] \u2192 [.. @0=(A B) ..]\n      ast = {\n        type: 'Arr',\n        items: [\n          {type: 'Spread', quant: null},\n          {type: 'GroupBind', name: '0', pat: ast.content},\n          {type: 'Spread', quant: null}\n        ]\n      };\n    }\n  } else {\n    // Wrap AST with $0 binding to capture entire match region\n    ast = {type: 'SBind', name: '0', pat: ast};\n  }\n\n  // Mark slice patterns for match() rejection\n  if (isSlicePattern) {\n    ast._isSlicePattern = true;\n  }\n\n  _cache.set(pattern, ast);\n  if (_cache.size > CACHE_MAX) {\n    const k = _cache.keys().next().value;\n    _cache.delete(k);\n  }\n  return ast;\n}\n\n// ------------------- Group class (internal representation) -------------------\n\n/**\n * Group \u2014 internal wrapper for group bindings and replacements.\n * Represents a contiguous subsequence of an array or subset of object properties.\n *\n * Engine and replacement logic use this to distinguish slice semantics.\n * User-facing APIs never require Group instances.\n */\nexport class Group {\n  constructor(type, value) {\n    Object.defineProperty(this, '_type', {\n      value: type,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.defineProperty(this, '_value', {\n      value: value,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n\n    if (type === 'array') {\n      value.forEach((v, i) => {\n        this[i] = v;\n      });\n      this.length = value.length;\n    } else if (type === 'object') {\n      Object.assign(this, value);\n    }\n  }\n\n  static array(...items) {\n    return new Group('array', items);\n  }\n\n  static object(obj) {\n    return new Group('object', obj);\n  }\n\n  [Symbol.iterator]() {\n    if (this._type !== 'array') {\n      throw new TypeError('Object-type Group is not iterable');\n    }\n    let i = 0;\n    const arr = this._value;\n    return {\n      next() {\n        return i < arr.length ? {value: arr[i++], done: false} : {done: true};\n      }\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return `Group(${this._type})`;\n  }\n\n  at(i) {\n    if (this._type === 'array') return this._value[i];\n    throw new TypeError('Not an array group');\n  }\n}\n\n// ------------------- Helper utilities -------------------\n\n// Deep clone JSON-like values (arrays/objects/primitives)\nfunction cloneDeep(v) {\n  if (Array.isArray(v)) {\n    return v.map(cloneDeep);\n  }\n  if (v && typeof v === 'object') {\n    const out = {};\n    for (const k of Object.keys(v)) {\n      out[k] = cloneDeep(v[k]);\n    }\n    return out;\n  }\n  return v;\n}\n\n// Helper: navigate path to get value\nfunction getAt(root, path) {\n  let current = root;\n  for (const key of path) current = current[key];\n  return current;\n}\n\n// Helper: navigate path and set value (mutates in-place)\nfunction setAtMutate(root, path, value) {\n  let current = root;\n  for (let i = 0; i < path.length - 1; i++) current = current[path[i]];\n  current[path[path.length - 1]] = value;\n}\n\n// Helper: stable key for deduplication across arbitrary JS structures\nfunction stableKey(v) {\n  const seen = new WeakMap();\n  let id = 0;\n  const enc = (x) => {\n    if (x === null) return ['null'];\n    const t = typeof x;\n    if (t === 'undefined') return ['u'];\n    if (t === 'number') return ['n', Number.isNaN(x) ? 'NaN' : String(x)];\n    if (t === 'boolean') return ['b', x ? '1' : '0'];\n    if (t === 'string') return ['s', x];\n    if (t === 'function') return ['f'];\n    if (t !== 'object') return ['o', String(x)];\n    if (seen.has(x)) return ['r', seen.get(x)];\n    seen.set(x, ++id);\n    if (Array.isArray(x)) return ['A', x.map(enc)];\n    const keys = Object.keys(x).sort();\n    return ['O', keys.map(k => [k, enc(x[k])])];\n  };\n  return JSON.stringify(enc(v));\n}\n\n// ------------------- Site identity -------------------\n\n/**\n * Compute a unique identity key for a site.\n * Two sites with the same key target the same structural location.\n */\nfunction siteKey(site) {\n  if (site.kind === 'scalar') {\n    return JSON.stringify(['scalar', site.path]);\n  }\n  // Array group: path + start + end\n  if (site.groupStart !== undefined) {\n    return JSON.stringify(['group-array', site.path, site.groupStart, site.groupEnd]);\n  }\n  // Object group: path + sorted keys\n  if (site.keys !== undefined) {\n    return JSON.stringify(['group-object', site.path, [...site.keys].sort()]);\n  }\n  return JSON.stringify(['unknown', site.path]);\n}\n\n// ------------------- Replacement / editing core -------------------\n\n/**\n * applyEdits mutates the given root in-place.\n * For pure operations, call it on a deep clone.\n *\n * Each edit: {site, to}\n *  - site.kind: 'scalar' | 'group'\n *  - scalar site: {kind:'scalar', path, valueRef}\n *  - group array site: {kind:'group', path, groupStart, groupEnd, valueRefs:[...]}\n *  - group object site: {kind:'group', path, keys:[...], valueRefs:{...}}\n *\n * opts.onCASFailure?: (failure) => 'skip' | 'force'\n *   Called when value at site doesn't match captured valueRef.\n *   Default: skip silently.\n *\n * Returns: {result, failures}\n */\nfunction applyEdits(root, edits, opts = {}) {\n  const failures = [];\n  if (edits.length === 0) return {result: root, failures};\n\n  const onCASFailure = opts.onCASFailure || null;\n  let result = root;\n\n  // Helper: handle CAS failure, returns true if we should force the edit\n  function handleCASFailure(edit, expected, actual) {\n    const failure = {\n      site: edit.site,\n      siteKey: siteKey(edit.site),\n      expected,\n      actual,\n      to: edit.to\n    };\n    if (onCASFailure) {\n      const action = onCASFailure(failure);\n      if (action === 'force') return true;\n    }\n    failures.push(failure);\n    return false;\n  }\n\n  // Group edits by path (sites at the same container need coordinated splices)\n  const editsByPath = new Map();\n  for (const edit of edits) {\n    const pathKey = JSON.stringify(edit.site.path);\n    if (!editsByPath.has(pathKey)) editsByPath.set(pathKey, []);\n    editsByPath.get(pathKey).push(edit);\n  }\n\n  for (const [, pathEdits] of editsByPath) {\n    const sets = pathEdits.filter(e => e.site.kind === 'scalar');\n    const splices = pathEdits.filter(e => e.site.kind === 'group');\n\n    // Scalar replacements\n    for (const edit of sets) {\n      const current = getAt(result, edit.site.path);\n      const matches = deepEqual(current, edit.site.valueRef);\n      if (matches) {\n        if (edit.site.path.length === 0) result = edit.to;\n        else setAtMutate(result, edit.site.path, edit.to);\n      } else {\n        const shouldForce = handleCASFailure(edit, edit.site.valueRef, current);\n        if (shouldForce) {\n          if (edit.site.path.length === 0) result = edit.to;\n          else setAtMutate(result, edit.site.path, edit.to);\n        }\n      }\n    }\n\n    // Group (array/object) replacements\n    if (splices.length > 0) {\n      const arraySplices = splices.filter(e => e.site.groupStart !== undefined);\n      const objectSplices = splices.filter(e => e.site.keys !== undefined);\n\n      // Array group splices: apply in ascending start order, tracking offsets\n      if (arraySplices.length > 0) {\n        arraySplices.sort((a, b) => a.site.groupStart - b.site.groupStart);\n\n        let offset = 0;\n        for (const edit of arraySplices) {\n          const arr = getAt(result, edit.site.path);\n          if (!Array.isArray(arr)) continue;\n\n          const start = edit.site.groupStart + offset;\n          const end = edit.site.groupEnd + offset;\n\n          // Validate the slice still matches the captured refs\n          const actualSlice = arr.slice(start, end);\n          let allMatch = actualSlice.length === edit.site.valueRefs.length;\n          if (allMatch) {\n            for (let i = 0; i < edit.site.valueRefs.length; i++) {\n              if (!deepEqual(actualSlice[i], edit.site.valueRefs[i])) {\n                allMatch = false;\n                break;\n              }\n            }\n          }\n\n          if (!allMatch) {\n            const shouldForce = handleCASFailure(edit, edit.site.valueRefs, actualSlice);\n            if (!shouldForce) continue;\n          }\n\n          if (!edit.to || !(edit.to instanceof Group) || edit.to._type !== 'array') {\n            throw new Error('Internal error: array group splice requires Group.array');\n          }\n\n          const elements = edit.to._value;\n          const oldLength = end - start;\n          const newLength = elements.length;\n          arr.splice(start, oldLength, ...elements);\n          offset += (newLength - oldLength);\n        }\n      }\n\n      // Object group \"splices\": delete captured keys then assign new props\n      for (const edit of objectSplices) {\n        const obj = getAt(result, edit.site.path);\n        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) continue;\n\n        const actualProps = {};\n        let allMatch = true;\n        for (const key of edit.site.keys) {\n          actualProps[key] = obj[key];\n          if (!deepEqual(obj[key], edit.site.valueRefs[key])) {\n            allMatch = false;\n          }\n        }\n\n        if (!allMatch) {\n          const shouldForce = handleCASFailure(edit, edit.site.valueRefs, actualProps);\n          if (!shouldForce) continue;\n        }\n\n        if (!edit.to || !(edit.to instanceof Group) || edit.to._type !== 'object') {\n          throw new Error('Internal error: object group splice requires Group.object');\n        }\n\n        const newProps = edit.to._value;\n        for (const key of edit.site.keys) delete obj[key];\n        Object.assign(obj, newProps);\n      }\n    }\n  }\n\n  return {result, failures};\n}\n\n// Evaluate a plan (object or function) against a solution and add edits for its sites.\n// Low-level: pushes to an array without deduplication.\nfunction collectEditsFromPlan(sol, planOrFn, edits) {\n  const plan = (typeof planOrFn === 'function') ? (planOrFn(sol) || {}) : (planOrFn || {});\n  const sitesMap = sol._sites;\n\n  for (const [varNameRaw, valueSpec] of Object.entries(plan)) {\n    const varName = (varNameRaw.startsWith('$') || varNameRaw.startsWith('@'))\n      ? varNameRaw.slice(1)\n      : varNameRaw;\n    const sites = sitesMap.get(varName) || [];\n    if (!sites.length) continue;\n\n    const value = (typeof valueSpec === 'function') ? valueSpec(sol) : valueSpec;\n    for (const site of sites) edits.push({site, to: convertValueForSite(site, value)});\n  }\n}\n\n/**\n * Collect edits across all (occurrence, solution) pairs with site-based deduplication.\n *\n * opts.per: 'site' (default) | 'occurrence'\n *   - 'site': iterate all solutions, dedupe by site identity (for redaction/normalization)\n *   - 'occurrence': use first solution per occurrence (for $0 replacements)\n *\n * Returns: {edits: [...], conflicts: [...]}\n *   - edits: deduplicated array of {site, to}\n *   - conflicts: array of {siteKey, existing, attempted, ...} for same-site-different-value cases\n */\nfunction collectAllSiteEdits(occurrences, planOrFn, opts = {}) {\n  const per = opts.per || 'site';\n  const editsBySiteKey = new Map(); // siteKey -> {site, to, firstSol}\n  const conflicts = [];\n\n  for (const occ of occurrences) {\n    // 'occurrence' mode: first solution only; 'site' mode: all solutions\n    const sols = per === 'occurrence'\n      ? (occ._solutions.length ? [occ._solutions[0]] : [])\n      : occ._solutions;\n\n    for (const sol of sols) {\n      const plan = (typeof planOrFn === 'function') ? (planOrFn(sol) || {}) : (planOrFn || {});\n      const sitesMap = sol._sites;\n\n      for (const [varNameRaw, valueSpec] of Object.entries(plan)) {\n        const varName = (varNameRaw.startsWith('$') || varNameRaw.startsWith('@'))\n          ? varNameRaw.slice(1)\n          : varNameRaw;\n        const sites = sitesMap.get(varName) || [];\n        if (!sites.length) continue;\n\n        const value = (typeof valueSpec === 'function') ? valueSpec(sol) : valueSpec;\n\n        for (const site of sites) {\n          const key = siteKey(site);\n          const to = convertValueForSite(site, value);\n\n          if (editsBySiteKey.has(key)) {\n            const existing = editsBySiteKey.get(key);\n            // Same site, same to => idempotent, skip\n            if (!deepEqual(existing.to, to)) {\n              // Conflict: same site, different to\n              conflicts.push({\n                siteKey: key,\n                site,\n                existing: existing.to,\n                attempted: to,\n                existingSol: existing.firstSol,\n                attemptedSol: sol\n              });\n            }\n          } else {\n            editsBySiteKey.set(key, {site, to, firstSol: sol});\n          }\n        }\n      }\n    }\n  }\n\n  const edits = Array.from(editsBySiteKey.values()).map(e => ({site: e.site, to: e.to}));\n  return {edits, conflicts};\n}\n\n/**\n * Replacement semantics are determined by the *site kind*:\n *  - scalar site: value is used as-is\n *  - group site:\n *      * array-group: Array => splice elements; non-array => splice single element\n *      * object-group: Object => replace captured keys with provided props\n *\n * Users never have to provide Group explicitly.\n */\nfunction convertValueForSite(site, value) {\n  // Scalar replacement: anything goes (including arrays as a single value)\n  if (site.kind === 'scalar') return value;\n\n  const isArrayGroup = site.groupStart !== undefined;\n  const isObjectGroup = site.keys !== undefined;\n\n  if (isArrayGroup) {\n    // Group replacement = splice.\n    // Arrays splice as elements; non-arrays treated as a single element slice.\n    if (value instanceof Group && value._type === 'array') return value; // internal ok\n    if (Array.isArray(value)) return Group.array(...value);\n    return Group.array(value);\n  }\n\n  if (isObjectGroup) {\n    // Group replacement = object \"patch\" (replace captured keys with new props).\n    if (value instanceof Group && value._type === 'object') return value; // internal ok\n    if (value && typeof value === 'object' && !Array.isArray(value)) return Group.object(value);\n    throw new TypeError('Object group replacement expects a plain object');\n  }\n\n  return value;\n}\n\n// ------------------- Raw solutions -> occurrences -------------------\n\n// Group raw engine solutions by $0 path => occurrence groups\nfunction groupByZeroPath(rawSolutions) {\n  const map = new Map(); // key -> {path, rawSolutions}\n  for (const sol of rawSolutions) {\n    const zeroSites = sol.sites.get('0') || [];\n    if (!zeroSites.length) continue;\n    const path = zeroSites[0].path || [];\n    const key = JSON.stringify(path);\n    let group = map.get(key);\n    if (!group) {\n      group = {path, rawSolutions: []};\n      map.set(key, group);\n    }\n    group.rawSolutions.push(sol);\n  }\n  return Array.from(map.values());\n}\n\n// Normalize bindings for user:\n// - Strip $0 by default\n// - Convert internal Group values to plain arrays/objects for readability\nfunction normalizeBindings(rawBindings, {includeWhole = false} = {}) {\n  const out = {};\n  for (const [k, v] of Object.entries(rawBindings)) {\n    if (k === '0' && !includeWhole) continue;\n    out[k] = groupToPublicValue(v);\n  }\n  return out;\n}\n\nfunction groupToPublicValue(v) {\n  // Duck-type check for Group (works across different Group class instances)\n  if (!v || typeof v !== 'object' || !v._type || !v._value) return v;\n  if (v._type === 'array') return v._value.slice ? v._value.slice() : [...v._value];\n  if (v._type === 'object') return {...v._value};\n  return v;\n}\n\n// ------------------- Core data structures: Occurrence, Solution, Sets -------------------\n\nclass Occurrence {\n  constructor(root, path, rawSolutions, matchSet) {\n    this._root = root;\n    this._path = path;\n    this._rawSolutions = rawSolutions;\n    this._matchSet = matchSet;\n\n    // Precompute Solution objects for this occurrence\n    this._solutions = rawSolutions.map(raw => new Solution(raw, this, matchSet));\n\n    // $0 site (first one) for replace/occurrence value\n    const zeroSites = rawSolutions[0]?.sites.get('0') || [];\n    this._zeroSite = zeroSites[0] || null;\n  }\n\n  path() {\n    return [...this._path];\n  }\n\n  value() {\n    if (!this._zeroSite) return undefined;\n    return getAt(this._root, this._zeroSite.path);\n  }\n\n  solutions() {\n    const sols = this._solutions;\n    return {\n      [Symbol.iterator]() {\n        let i = 0;\n        return {\n          next() {\n            if (i >= sols.length) return {done: true};\n            return {value: sols[i++], done: false};\n          }\n        };\n      }\n    };\n  }\n\n  /**\n   * replace(replOrFn, {mutate?, onCASFailure?}):\n   * Replaces $0 for THIS occurrence using the first solution (deterministic).\n   * Default is pure (returns new root); pass {mutate:true} to edit in-place.\n   */\n  replace(replOrFn, opts = {}) {\n    if (!this._zeroSite) return this._root;\n    const mutate = !!opts.mutate;\n\n    const firstSol = this._solutions[0] || null;\n    const to = (typeof replOrFn === 'function') ? replOrFn(firstSol) : replOrFn;\n\n    const edits = [{site: this._zeroSite, to}];\n    const target = mutate ? this._root : cloneDeep(this._root);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    if (failures.length > 0 && typeof result === 'object' && result !== null) {\n      Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n    }\n    return result;\n  }\n\n  /**\n   * edit(plan, {mutate?, per?, onConflict?, onCASFailure?}):\n   * Applies variable edits for THIS occurrence.\n   *\n   * Options:\n   *   per: 'site' (default) | 'occurrence'\n   *     - 'site': all solutions for this occurrence, dedupe by site\n   *     - 'occurrence': first solution only\n   */\n  edit(planOrFn, opts = {}) {\n    const mutate = !!opts.mutate;\n    const per = opts.per || 'site';\n\n    // Collect edits with site-based deduplication for this single occurrence\n    const {edits, conflicts} = collectAllSiteEdits([this], planOrFn, {per});\n\n    if (conflicts.length > 0 && opts.onConflict) {\n      for (const c of conflicts) opts.onConflict(c);\n    }\n\n    const target = mutate ? this._root : cloneDeep(this._root);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    if ((failures.length > 0 || conflicts.length > 0) && typeof result === 'object' && result !== null) {\n      if (failures.length > 0) {\n        Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n      }\n      if (conflicts.length > 0) {\n        Object.defineProperty(result, '_editConflicts', {value: conflicts, enumerable: false});\n      }\n    }\n    return result;\n  }\n}\n\nclass Solution {\n  constructor(rawSolution, occ, matchSet) {\n    // Internal properties are non-enumerable to avoid JSON.stringify cycles\n    // and to keep Object.keys() clean (showing only bindings)\n    Object.defineProperties(this, {\n      _occ: {value: occ, enumerable: false},\n      _matchSet: {value: matchSet, enumerable: false},\n      _raw: {value: rawSolution, enumerable: false},\n      _sites: {value: rawSolution.sites, enumerable: false},\n      _bindings: {value: null, writable: true, enumerable: false},\n      toObject: {value: () => ({...this._bindings}), enumerable: false}\n    });\n\n    // Public bindings: groups converted to arrays/objects; $0 hidden\n    const publicBindings = normalizeBindings(rawSolution.bindings, {includeWhole: false});\n    this._bindings = publicBindings;\n\n    for (const [k, v] of Object.entries(publicBindings)) this[k] = v;\n  }\n\n  bindings() {\n    return {...this._bindings};\n  }\n\n  occurrence() {\n    return this._occ;\n  }\n\n  sites(name) {\n    const n = name.startsWith('$') || name.startsWith('@') ? name.slice(1) : name;\n    return (this._sites.get(n) || []).slice();\n  }\n\n  /**\n   * edit(plan, {mutate?, onCASFailure?}):\n   * Applies edits using THIS solution only (no site deduplication needed for single solution).\n   */\n  edit(planOrFn, opts = {}) {\n    const mutate = !!opts.mutate;\n    const target = mutate ? this._occ._root : cloneDeep(this._occ._root);\n    const edits = [];\n    collectEditsFromPlan(this, planOrFn, edits);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    if (failures.length > 0 && typeof result === 'object' && result !== null) {\n      Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n    }\n    return result;\n  }\n\n  /**\n   * replace(replOrFn, {mutate?, onCASFailure?}):\n   * Replaces $0 for this occurrence using THIS solution.\n   */\n  replace(replOrFn, opts = {}) {\n    // Use this solution (not necessarily first) for deriving replacement\n    if (!this._occ._zeroSite) return this._occ._root;\n    const mutate = !!opts.mutate;\n\n    const to = (typeof replOrFn === 'function') ? replOrFn(this) : replOrFn;\n    const edits = [{site: this._occ._zeroSite, to}];\n    const target = mutate ? this._occ._root : cloneDeep(this._occ._root);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    if (failures.length > 0 && typeof result === 'object' && result !== null) {\n      Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n    }\n    return result;\n  }\n\n  /**\n   * occurrences():\n   * Iterate all occurrences in the match set that contain an equivalent binding set.\n   * NOTE: This enumerates all occurrences.\n   */\n  occurrences() {\n    const myKey = stableKey(this._bindings);\n    const matchSet = this._matchSet;\n\n    return {\n      [Symbol.iterator]() {\n        const all = [];\n        for (const occ of matchSet) {\n          for (const s of occ._solutions) {\n            if (stableKey(s._bindings) === myKey) {\n              all.push(occ);\n              break;\n            }\n          }\n        }\n        let i = 0;\n        return {\n          next() {\n            if (i >= all.length) return {done: true};\n            return {value: all[i++], done: false};\n          }\n        };\n      }\n    };\n  }\n}\n\nclass OccurrenceSet {\n  constructor(root, groups) {\n    this._root = root;\n    this._occurrences = groups.map(g => new Occurrence(root, g.path, g.rawSolutions, this));\n  }\n\n  [Symbol.iterator]() {\n    return this._occurrences[Symbol.iterator]();\n  }\n\n  occurrences() {\n    return this;\n  }\n\n  first() {\n    return this._occurrences[0] || null;\n  }\n\n  take(n) {\n    const sliced = this._occurrences.slice(0, n);\n    const groups = sliced.map(o => ({path: o._path, rawSolutions: o._rawSolutions}));\n    return new OccurrenceSet(this._root, groups);\n  }\n\n  filter(pred) {\n    const filtered = this._occurrences.filter(pred);\n    const groups = filtered.map(o => ({path: o._path, rawSolutions: o._rawSolutions}));\n    return new OccurrenceSet(this._root, groups);\n  }\n\n  toArray() {\n    return [...this._occurrences];\n  }\n\n  count() {\n    return this._occurrences.length;\n  }\n\n  hasMatch() {\n    return this._occurrences.length > 0;\n  }\n\n  /**\n   * solutions(): returns a SolutionSet of unique solutions across all occurrences.\n   */\n  solutions() {\n    return new SolutionSet(this);\n  }\n\n  /**\n   * replaceAll(replOrFn, {mutate?, onCASFailure?}):\n   * Replaces $0 for each occurrence using the first solution of that occurrence.\n   * This is inherently \"per occurrence\" since $0 is the whole match.\n   */\n  replaceAll(replOrFn, opts = {}) {\n    if (!this._occurrences.length) return this._root;\n    const mutate = !!opts.mutate;\n\n    const edits = [];\n    for (const occ of this._occurrences) {\n      if (!occ._zeroSite) continue;\n      const firstSol = occ._solutions[0] || null;\n      const rawTo = (typeof replOrFn === 'function') ? replOrFn(firstSol) : replOrFn;\n      // Convert value based on site kind (scalar $0 vs group @0)\n      const to = convertValueForSite(occ._zeroSite, rawTo);\n      edits.push({site: occ._zeroSite, to});\n    }\n\n    const target = mutate ? this._root : cloneDeep(this._root);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    // Attach failures for inspection if any\n    if (failures.length > 0 && typeof result === 'object' && result !== null) {\n      Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n    }\n    return result;\n  }\n\n  /**\n   * editAll(planOrFn, opts):\n   * Edits every bound *site* you referenced, wherever it occurs.\n   *\n   * Options:\n   *   per: 'site' (default) | 'occurrence'\n   *     - 'site': iterates all solutions, dedupes by site identity.\n   *       This is the right default for redaction, normalization, \"change every X\".\n   *     - 'occurrence': uses first solution per occurrence only.\n   *       Useful for $0-focused edits or when you want one edit per match location.\n   *   mutate: boolean (default false) - mutate in place vs return copy\n   *   onConflict: (conflict) => void - called for planning-time conflicts (same site, different values)\n   *   onCASFailure: (failure) => 'skip' | 'force' - called for apply-time CAS failures\n   */\n  editAll(planOrFn, opts = {}) {\n    if (!this._occurrences.length) return this._root;\n    const mutate = !!opts.mutate;\n\n    // Collect edits with site-based deduplication\n    const {edits, conflicts} = collectAllSiteEdits(this._occurrences, planOrFn, {per: opts.per});\n\n    // Handle planning-time conflicts\n    if (conflicts.length > 0 && opts.onConflict) {\n      for (const c of conflicts) opts.onConflict(c);\n    }\n\n    const target = mutate ? this._root : cloneDeep(this._root);\n    const {result, failures} = applyEdits(target, edits, {onCASFailure: opts.onCASFailure});\n\n    // Attach metadata for inspection if any\n    if ((failures.length > 0 || conflicts.length > 0) && typeof result === 'object' && result !== null) {\n      if (failures.length > 0) {\n        Object.defineProperty(result, '_editFailures', {value: failures, enumerable: false});\n      }\n      if (conflicts.length > 0) {\n        Object.defineProperty(result, '_editConflicts', {value: conflicts, enumerable: false});\n      }\n    }\n    return result;\n  }\n}\n\nclass SolutionSet {\n  constructor(occSet) {\n    this._occSet = occSet;\n  }\n\n  [Symbol.iterator]() {\n    const occs = this._occSet._occurrences;\n    const seen = new Set();\n    let oi = 0;\n    let si = 0;\n    let curOcc = occs[0] || null;\n\n    return {\n      next() {\n        while (true) {\n          if (!curOcc) return {done: true};\n\n          if (si >= curOcc._solutions.length) {\n            oi++;\n            if (oi >= occs.length) return {done: true};\n            curOcc = occs[oi];\n            si = 0;\n            continue;\n          }\n\n          const sol = curOcc._solutions[si++];\n          const key = stableKey(sol._bindings);\n          if (seen.has(key)) continue;\n          seen.add(key);\n          return {value: sol, done: false};\n        }\n      }\n    };\n  }\n\n  first() {\n    const it = this[Symbol.iterator]();\n    const n = it.next();\n    return n.done ? null : n.value;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  count() {\n    let c = 0;\n    for (const _ of this) c++;\n    return c;\n  }\n\n  filter(pred) {\n    const out = [];\n    for (const sol of this) if (pred(sol)) out.push(sol);\n    return new FilteredSolutionSet(out, this._occSet);\n  }\n\n  take(n) {\n    const out = [];\n    let c = 0;\n    for (const sol of this) {\n      if (c++ >= n) break;\n      out.push(sol);\n    }\n    return new FilteredSolutionSet(out, this._occSet);\n  }\n}\n\nclass FilteredSolutionSet {\n  constructor(solutions, occSet) {\n    this._solutions = solutions;\n    this._occSet = occSet;\n  }\n\n  [Symbol.iterator]() {\n    return this._solutions[Symbol.iterator]();\n  }\n\n  first() {\n    return this._solutions[0] || null;\n  }\n\n  toArray() {\n    return [...this._solutions];\n  }\n\n  count() {\n    return this._solutions.length;\n  }\n\n  filter(pred) {\n    return new FilteredSolutionSet(this._solutions.filter(pred), this._occSet);\n  }\n\n  take(n) {\n    return new FilteredSolutionSet(this._solutions.slice(0, n), this._occSet);\n  }\n}\n\n// ------------------- Simple API wrappers (OnMatcher, InMatcher) -------------------\n\n/**\n * OnMatcher: Simple API for anchored matching.\n * pattern.on(data).test() / .solve() / .solutions() / .replace() / .mutate()\n */\nclass OnMatcher {\n  constructor(pattern, data) {\n    this._pattern = pattern;\n    this._data = data;\n    this._occSet = null; // lazy\n  }\n\n  _getOccSet() {\n    if (!this._occSet) {\n      this._occSet = this._pattern.advancedMatch(this._data);\n    }\n    return this._occSet;\n  }\n\n  /** Boolean: does the pattern match the data at root? */\n  test() {\n    return this._pattern.hasMatch(this._data);\n  }\n\n  /**\n   * First solution as a plain object, or null if no match.\n   * Empty object {} means \"matched but no bindings\".\n   */\n  solve() {\n    const occSet = this._getOccSet();\n    const sol = occSet.solutions().first();\n    return sol ? sol.toObject() : null;\n  }\n\n  /** All solutions as an array of plain objects. */\n  solutions() {\n    const occSet = this._getOccSet();\n    const out = [];\n    for (const sol of occSet.solutions()) {\n      out.push(sol.toObject());\n    }\n    return out;\n  }\n\n  /**\n   * Replace the entire match.\n   * @param replacement - value or function (bindings) => value\n   */\n  replace(replacement) {\n    const occSet = this._getOccSet();\n    if (!occSet.hasMatch()) return this._data;\n    return occSet.replaceAll(replacement, {mutate: false});\n  }\n\n  /**\n   * Mutate (edit in place) specific bindings.\n   * @param mutation - {varName: value|fn, ...} or function (bindings) => {...}\n   */\n  mutate(mutation) {\n    const occSet = this._getOccSet();\n    if (!occSet.hasMatch()) return this._data;\n    return occSet.editAll(mutation, {mutate: false}); // still pure; \"mutate\" refers to surgical edits\n  }\n}\n\n/**\n * InMatcher: Simple API for searching within data.\n * pattern.in(data).count() / .locations() / .replace() / .mutate()\n */\nclass InMatcher {\n  constructor(pattern, data) {\n    this._pattern = pattern;\n    this._data = data;\n    this._occSet = null; // lazy\n  }\n\n  _getOccSet() {\n    if (!this._occSet) {\n      this._occSet = this._pattern.advancedFind(this._data);\n    }\n    return this._occSet;\n  }\n\n  /** Count of matching occurrences. */\n  count() {\n    return this._getOccSet().count();\n  }\n\n  /**\n   * Array of {path, fragment, bindings} for each occurrence.\n   * Uses first solution per occurrence (with warning if multiple solutions).\n   */\n  locations() {\n    const occSet = this._getOccSet();\n    const results = [];\n\n    for (const occ of occSet) {\n      const sols = [...occ.solutions()];\n      if (sols.length > 1) {\n        console.warn(\n          `Tendril: occurrence at path ${JSON.stringify(occ.path())} has ${sols.length} solutions; ` +\n          `using first. Consider refining your pattern for deterministic results.`\n        );\n      }\n\n      const firstSol = sols[0] || null;\n      results.push({\n        path: occ.path(),\n        fragment: occ.value(),\n        bindings: firstSol ? firstSol.toObject() : {}\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Replace all occurrences.\n   * @param replacement - value or function (bindings) => value\n   */\n  replace(replacement) {\n    const occSet = this._getOccSet();\n    if (!occSet.hasMatch()) return this._data;\n\n    // Warn if any occurrence has multiple solutions\n    for (const occ of occSet) {\n      const solCount = [...occ.solutions()].length;\n      if (solCount > 1) {\n        console.warn(\n          `Tendril: occurrence at path ${JSON.stringify(occ.path())} has ${solCount} solutions; ` +\n          `using first for replacement. Consider refining your pattern.`\n        );\n      }\n    }\n\n    return occSet.replaceAll(replacement, {mutate: false});\n  }\n\n  /**\n   * Mutate (surgically edit) specific bindings across all occurrences.\n   * @param mutation - {varName: value|fn, ...} or function (bindings) => {...}\n   */\n  mutate(mutation) {\n    const occSet = this._getOccSet();\n    if (!occSet.hasMatch()) return this._data;\n    return occSet.editAll(mutation, {mutate: false});\n  }\n}\n\n// ------------------- Pattern class (Tendril(pattern)) -------------------\n\nclass PatternImpl {\n  constructor(pattern) {\n    this._pattern = String(pattern);\n    this._ast = null;\n    this._opts = {};\n    this._debug = null;\n  }\n\n  withOptions(opts) {\n    const p = new PatternImpl(this._pattern);\n    p._ast = this._ast;\n    p._opts = {...this._opts, ...opts};\n    p._debug = this._debug;\n    return p;\n  }\n\n  debug(listener) {\n    const p = new PatternImpl(this._pattern);\n    p._ast = this._ast;\n    p._opts = this._opts;\n    p._debug = listener;\n    return p;\n  }\n\n  _getAst() {\n    if (!this._ast) this._ast = compile(this._pattern);\n    return this._ast;\n  }\n\n  _buildOpts() {\n    const opts = {...this._opts};\n    if (this._debug) opts.debug = this._debug;\n    return opts;\n  }\n\n  // ==================== Simple API ====================\n\n  /**\n   * on(data): Simple anchored matching API.\n   * Returns OnMatcher with .test(), .solve(), .solutions(), .replace(), .mutate()\n   */\n  on(input) {\n    return new OnMatcher(this, input);\n  }\n\n  /**\n   * in(data): Simple search-within API.\n   * Returns InMatcher with .count(), .locations(), .replace(), .mutate()\n   */\n  in(input) {\n    return new InMatcher(this, input);\n  }\n\n  // ==================== Advanced API ====================\n\n  /**\n   * advancedMatch(data): anchored match at the root.\n   * Returns an OccurrenceSet (possibly empty; at most one occurrence: []).\n   */\n  advancedMatch(input) {\n    const ast = this._getAst();\n    if (ast._isSlicePattern) {\n      throw new Error('Slice patterns (@{ } and @[ ]) require advancedFind() or first(), not advancedMatch()');\n    }\n    const rawSolutions = engineMatch(ast, input, this._buildOpts());\n    const groups = groupByZeroPath(rawSolutions);\n    return new OccurrenceSet(input, groups);\n  }\n\n  /**\n   * advancedFind(data): scan for matches at any depth.\n   * Returns an OccurrenceSet over all occurrences.\n   */\n  advancedFind(input) {\n    const ast = this._getAst();\n    const rawSolutions = engineScan(ast, input, this._buildOpts());\n    const groups = groupByZeroPath(rawSolutions);\n    return new OccurrenceSet(input, groups);\n  }\n\n  // Legacy aliases for backwards compatibility (will be deprecated)\n  match(input) { return this.advancedMatch(input); }\n  find(input) { return this.advancedFind(input); }\n\n  /**\n   * first(data): first occurrence only (scan + stop).\n   * Returns OccurrenceSet with 0 or 1 occurrence.\n   */\n  first(input) {\n    const ast = this._getAst();\n    const rawSol = engineScanFirst(ast, input, this._buildOpts());\n    if (!rawSol) return new OccurrenceSet(input, []);\n    const zeroSites = rawSol.sites.get('0') || [];\n    const path = zeroSites.length ? zeroSites[0].path : [];\n    return new OccurrenceSet(input, [{path, rawSolutions: [rawSol]}]);\n  }\n\n  // ------------- Short-circuit methods (fast paths) -------------\n\n  hasMatch(input) {\n    const ast = this._getAst();\n    if (ast._isSlicePattern) {\n      throw new Error('Slice patterns (@{ } and @[ ]) require in() or advancedFind(), not on()/advancedMatch()/hasMatch()');\n    }\n    return engineMatchExists(ast, input, this._buildOpts());\n  }\n\n  hasAnyMatch(input) {\n    const ast = this._getAst();\n    return engineScanExists(ast, input, this._buildOpts());\n  }\n}\n\n// ------------------- Fluent factory -------------------\n\nexport function Tendril(pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError(`Tendril(): pattern must be a string, got ${typeof pattern}`);\n  }\n  return new PatternImpl(pattern);\n}\n\n// ------------------- Convenience functions (compat helpers) -------------------\n\n// Helper: get first solution object (plain bindings) from an iterable of Solution\nfunction firstSolutionObject(solutionsIterable) {\n  const it = solutionsIterable[Symbol.iterator]();\n  const n = it.next();\n  if (n.done) return null;\n  return n.value.toObject();\n}\n\n/**\n * Boolean \"does this match the whole data?\" helper (anchored).\n */\nexport function matches(pattern, input) {\n  return Tendril(pattern).match(input).hasMatch();\n}\n\n/**\n * Extract first solution (anchored), as a plain bindings object.\n */\nexport function extract(pattern, input) {\n  const mset = Tendril(pattern).match(input);\n  const solObj = firstSolutionObject(mset.solutions());\n  return solObj;\n}\n\n/**\n * Extract all unique solutions (anchored), as an array of bindings objects.\n */\nexport function extractAll(pattern, input) {\n  const mset = Tendril(pattern).match(input);\n  const out = [];\n  for (const sol of mset.solutions()) out.push(sol.toObject());\n  return out;\n}\n\n/**\n * Convenience replace: find first match and replace it (pure).\n */\nexport function replace(pattern, input, builder) {\n  const occ = Tendril(pattern).first(input).first();\n  if (!occ) return input;\n  return occ.replace(builder, {mutate: false});\n}\n\n/**\n * Convenience replaceAll: scan for occurrences and replace each $0 (pure).\n */\nexport function replaceAll(pattern, input, builder) {\n  return Tendril(pattern).find(input).replaceAll(builder, {mutate: false});\n}\n\n/**\n * Unique matches by variable set, anchored.\n * Returns array of plain bindings objects.\n */\nexport function uniqueMatches(pattern, input, ...vars) {\n  const mset = Tendril(pattern).match(input);\n  const out = [];\n  const seen = new Set();\n\n  for (const sol of mset.solutions()) {\n    const obj = sol.toObject();\n    const projected = {};\n    for (const v of vars) {\n      const key = v.startsWith('$') || v.startsWith('@') ? v.slice(1) : v;\n      if (Object.prototype.hasOwnProperty.call(obj, key)) projected[key] = obj[key];\n    }\n    const key = stableKey(projected);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push(projected);\n  }\n\n  return out;\n}\n"],
  "mappings": "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",
  "names": ["left", "guard", "p", "term", "optional", "result", "sigil", "guard", "matched", "next", "matches", "key"]
}
